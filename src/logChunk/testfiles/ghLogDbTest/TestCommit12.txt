commit 0e63a815aa6af63a21848e04b683d3f506dd41b1
Author: FlyingRat <flyingrat@outlook.com>
Date:   2013-04-07

    [FFmpeg] version bump to n1.2 (rev e820e3a) - lib/ffmpeg
    
    This commit now contains the original patches sub directory:
      patches           - Org dir that contains applied xbmc custom patches.
      patches/README-patches    - New README file with info about xbmc patches.
      patches/obsolete-patches  - New dir with obsolete xbmc patches.

diff --git a/lib/ffmpeg/libavcodec/h264.c b/lib/ffmpeg/libavcodec/h264.c
index c4785db..937ad7a 100644
--- a/lib/ffmpeg/libavcodec/h264.c
+++ b/lib/ffmpeg/libavcodec/h264.c
@@ -1,991 +1,1211 @@
 /*
  * H.26L/H.264/AVC/JVT/14496-10/... decoder
  * Copyright (c) 2003 Michael Niedermayer <michaelni@gmx.at>
  *
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
  *
  * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**
  * @file
  * H.264 / AVC / MPEG4 part10 codec.
  * @author Michael Niedermayer <michaelni@gmx.at>
  */
 
 #define UNCHECKED_BITSTREAM_READER 1
 
 #include "libavutil/imgutils.h"
 #include "libavutil/opt.h"
 #include "internal.h"
 #include "cabac.h"
 #include "cabac_functions.h"
 #include "dsputil.h"
 #include "avcodec.h"
 #include "mpegvideo.h"
 #include "h264.h"
 #include "h264data.h"
+#include "h264chroma.h"
 #include "h264_mvpred.h"
 #include "golomb.h"
 #include "mathops.h"
 #include "rectangle.h"
+#include "svq3.h"
 #include "thread.h"
 #include "vdpau_internal.h"
 #include "libavutil/avassert.h"
 
-//#undef NDEBUG
+// #undef NDEBUG
 #include <assert.h>
 
-static const uint8_t rem6[QP_MAX_NUM+1]={
-0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,
+const uint16_t ff_h264_mb_sizes[4] = { 256, 384, 512, 768 };
+
+static const uint8_t rem6[QP_MAX_NUM + 1] = {
+    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
+    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
+    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
+    0, 1, 2, 3,
 };
 
-static const uint8_t div6[QP_MAX_NUM+1]={
-0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,
+static const uint8_t div6[QP_MAX_NUM + 1] = {
+    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,
+    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,
+    7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,
+   10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,
+   14,14,14,14,
 };
 
-static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {
-    PIX_FMT_DXVA2_VLD,
-    PIX_FMT_VAAPI_VLD,
-    PIX_FMT_VDA_VLD,
-    PIX_FMT_YUVJ420P,
-    PIX_FMT_NONE
+static const enum AVPixelFormat h264_hwaccel_pixfmt_list_420[] = {
+#if CONFIG_H264_DXVA2_HWACCEL
+    AV_PIX_FMT_DXVA2_VLD,
+#endif
+#if CONFIG_H264_VAAPI_HWACCEL
+    AV_PIX_FMT_VAAPI_VLD,
+#endif
+#if CONFIG_H264_VDA_HWACCEL
+    AV_PIX_FMT_VDA_VLD,
+#endif
+#if CONFIG_H264_VDPAU_HWACCEL
+    AV_PIX_FMT_VDPAU,
+#endif
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_NONE
 };
 
+static const enum AVPixelFormat h264_hwaccel_pixfmt_list_jpeg_420[] = {
+#if CONFIG_H264_DXVA2_HWACCEL
+    AV_PIX_FMT_DXVA2_VLD,
+#endif
+#if CONFIG_H264_VAAPI_HWACCEL
+    AV_PIX_FMT_VAAPI_VLD,
+#endif
+#if CONFIG_H264_VDA_HWACCEL
+    AV_PIX_FMT_VDA_VLD,
+#endif
+#if CONFIG_H264_VDPAU_HWACCEL
+    AV_PIX_FMT_VDPAU,
+#endif
+    AV_PIX_FMT_YUVJ420P,
+    AV_PIX_FMT_NONE
+};
+
+int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx)
+{
+    H264Context *h = avctx->priv_data;
+    return h ? h->sps.num_reorder_frames : 0;
+}
+
+static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,
+                              int (*mv)[2][4][2],
+                              int mb_x, int mb_y, int mb_intra, int mb_skipped)
+{
+    H264Context    *h = opaque;
+
+    h->mb_x  = mb_x;
+    h->mb_y  = mb_y;
+    h->mb_xy = mb_x + mb_y * h->mb_stride;
+    memset(h->non_zero_count_cache, 0, sizeof(h->non_zero_count_cache));
+    av_assert1(ref >= 0);
+    /* FIXME: It is possible albeit uncommon that slice references
+     * differ between slices. We take the easy approach and ignore
+     * it for now. If this turns out to have any relevance in
+     * practice then correct remapping should be added. */
+    if (ref >= h->ref_count[0])
+        ref = 0;
+    if (!h->ref_list[0][ref].f.data[0]) {
+        av_log(h->avctx, AV_LOG_DEBUG, "Reference not available for error concealing\n");
+        ref = 0;
+    }
+    if ((h->ref_list[0][ref].f.reference&3) != 3) {
+        av_log(h->avctx, AV_LOG_DEBUG, "Reference invalid\n");
+        return;
+    }
+    fill_rectangle(&h->cur_pic.f.ref_index[0][4 * h->mb_xy],
+                   2, 2, 2, ref, 1);
+    fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);
+    fill_rectangle(h->mv_cache[0][scan8[0]], 4, 4, 8,
+                   pack16to32((*mv)[0][0][0], (*mv)[0][0][1]), 4);
+    h->mb_mbaff =
+    h->mb_field_decoding_flag = 0;
+    ff_h264_hl_decode_mb(h);
+}
+
+void ff_h264_draw_horiz_band(H264Context *h, int y, int height)
+{
+    AVCodecContext *avctx = h->avctx;
+    Picture *cur  = &h->cur_pic;
+    Picture *last = h->ref_list[0][0].f.data[0] ? &h->ref_list[0][0] : NULL;
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+    int vshift = desc->log2_chroma_h;
+    const int field_pic = h->picture_structure != PICT_FRAME;
+    if (field_pic) {
+        height <<= 1;
+        y <<= 1;
+    }
+
+    height = FFMIN(height, avctx->height - y);
+
+    if (field_pic && h->first_field && !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD))
+        return;
+
+    if (avctx->draw_horiz_band) {
+        AVFrame *src;
+        int offset[AV_NUM_DATA_POINTERS];
+        int i;
+
+        if (cur->f.pict_type == AV_PICTURE_TYPE_B || h->low_delay ||
+           (avctx->slice_flags & SLICE_FLAG_CODED_ORDER))
+            src = &cur->f;
+        else if (last)
+            src = &last->f;
+        else
+            return;
+
+        offset[0] = y * src->linesize[0];
+        offset[1] =
+        offset[2] = (y >> vshift) * src->linesize[1];
+        for (i = 3; i < AV_NUM_DATA_POINTERS; i++)
+            offset[i] = 0;
+
+        emms_c();
+
+        avctx->draw_horiz_band(avctx, src, offset,
+                               y, h->picture_structure, height);
+    }
+}
+
+static void free_frame_buffer(H264Context *h, Picture *pic)
+{
+    pic->period_since_free = 0;
+    ff_thread_release_buffer(h->avctx, &pic->f);
+    av_freep(&pic->f.hwaccel_picture_private);
+}
+
+static void free_picture(H264Context *h, Picture *pic)
+{
+    int i;
+
+    if (pic->f.data[0])
+        free_frame_buffer(h, pic);
+
+    av_freep(&pic->qscale_table_base);
+    pic->f.qscale_table = NULL;
+    av_freep(&pic->mb_type_base);
+    pic->f.mb_type = NULL;
+    for (i = 0; i < 2; i++) {
+        av_freep(&pic->motion_val_base[i]);
+        av_freep(&pic->f.ref_index[i]);
+        pic->f.motion_val[i] = NULL;
+    }
+}
+
+static void release_unused_pictures(H264Context *h, int remove_current)
+{
+    int i;
+
+    /* release non reference frames */
+    for (i = 0; i < h->picture_count; i++) {
+        if (h->DPB[i].f.data[0] && !h->DPB[i].f.reference &&
+            (!h->DPB[i].owner2 || h->DPB[i].owner2 == h) &&
+            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
+            free_frame_buffer(h, &h->DPB[i]);
+        }
+    }
+}
+
+static int alloc_scratch_buffers(H264Context *h, int linesize)
+{
+    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);
+
+    if (h->bipred_scratchpad)
+        return 0;
+
+    h->bipred_scratchpad = av_malloc(16 * 6 * alloc_size);
+    // edge emu needs blocksize + filter length - 1
+    // (= 21x21 for  h264)
+    h->edge_emu_buffer = av_mallocz(alloc_size * 2 * 21);
+    h->me.scratchpad   = av_mallocz(alloc_size * 2 * 16 * 2);
+
+    if (!h->bipred_scratchpad || !h->edge_emu_buffer || !h->me.scratchpad) {
+        av_freep(&h->bipred_scratchpad);
+        av_freep(&h->edge_emu_buffer);
+        av_freep(&h->me.scratchpad);
+        return AVERROR(ENOMEM);
+    }
+
+    h->me.temp = h->me.scratchpad;
+
+    return 0;
+}
+
+static int alloc_picture(H264Context *h, Picture *pic)
+{
+    const int big_mb_num    = h->mb_stride * (h->mb_height + 1) + 1;
+    const int mb_array_size = h->mb_stride * h->mb_height;
+    const int b4_stride     = h->mb_width * 4 + 1;
+    const int b4_array_size = b4_stride * h->mb_height * 4;
+    int i, ret = 0;
+
+    av_assert0(!pic->f.data[0]);
+
+    if (h->avctx->hwaccel) {
+        const AVHWAccel *hwaccel = h->avctx->hwaccel;
+        av_assert0(!pic->f.hwaccel_picture_private);
+        if (hwaccel->priv_data_size) {
+            pic->f.hwaccel_picture_private = av_mallocz(hwaccel->priv_data_size);
+            if (!pic->f.hwaccel_picture_private)
+                return AVERROR(ENOMEM);
+        }
+    }
+    ret = ff_thread_get_buffer(h->avctx, &pic->f);
+    if (ret < 0)
+        goto fail;
+
+    h->linesize   = pic->f.linesize[0];
+    h->uvlinesize = pic->f.linesize[1];
+
+    if (pic->f.qscale_table == NULL) {
+        FF_ALLOCZ_OR_GOTO(h->avctx, pic->qscale_table_base,
+                          (big_mb_num + h->mb_stride) * sizeof(uint8_t),
+                          fail)
+        FF_ALLOCZ_OR_GOTO(h->avctx, pic->mb_type_base,
+                          (big_mb_num + h->mb_stride) * sizeof(uint32_t),
+                          fail)
+        pic->f.mb_type = pic->mb_type_base + 2 * h->mb_stride + 1;
+        pic->f.qscale_table = pic->qscale_table_base + 2 * h->mb_stride + 1;
+
+        for (i = 0; i < 2; i++) {
+            FF_ALLOCZ_OR_GOTO(h->avctx, pic->motion_val_base[i],
+                              2 * (b4_array_size + 4) * sizeof(int16_t),
+                              fail)
+            pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
+            FF_ALLOCZ_OR_GOTO(h->avctx, pic->f.ref_index[i],
+                              4 * mb_array_size * sizeof(uint8_t), fail)
+        }
+        pic->f.motion_subsample_log2 = 2;
+
+        pic->f.qstride = h->mb_stride;
+    }
+
+    pic->owner2 = h;
+
+    return 0;
+fail:
+    free_frame_buffer(h, pic);
+    return (ret < 0) ? ret : AVERROR(ENOMEM);
+}
+
+static inline int pic_is_unused(H264Context *h, Picture *pic)
+{
+    if (   (h->avctx->active_thread_type & FF_THREAD_FRAME)
+        && pic->f.qscale_table //check if the frame has anything allocated
+        && pic->period_since_free < h->avctx->thread_count)
+        return 0;
+    if (pic->f.data[0] == NULL)
+        return 1;
+    if (pic->needs_realloc && !(pic->f.reference & DELAYED_PIC_REF))
+        if (!pic->owner2 || pic->owner2 == h)
+            return 1;
+    return 0;
+}
+
+static int find_unused_picture(H264Context *h)
+{
+    int i;
+
+    for (i = h->picture_range_start; i < h->picture_range_end; i++) {
+        if (pic_is_unused(h, &h->DPB[i]))
+            break;
+    }
+    if (i == h->picture_range_end)
+        return AVERROR_INVALIDDATA;
+
+    if (h->DPB[i].needs_realloc) {
+        h->DPB[i].needs_realloc = 0;
+        free_picture(h, &h->DPB[i]);
+        avcodec_get_frame_defaults(&h->DPB[i].f);
+    }
+
+    return i;
+}
+
 /**
  * Check if the top & left blocks are available if needed and
  * change the dc mode so it only uses the available blocks.
  */
-int ff_h264_check_intra4x4_pred_mode(H264Context *h){
-    MpegEncContext * const s = &h->s;
-    static const int8_t top [12]= {-1, 0,LEFT_DC_PRED,-1,-1,-1,-1,-1, 0};
-    static const int8_t left[12]= { 0,-1, TOP_DC_PRED, 0,-1,-1,-1, 0,-1,DC_128_PRED};
+int ff_h264_check_intra4x4_pred_mode(H264Context *h)
+{
+    static const int8_t top[12] = {
+        -1, 0, LEFT_DC_PRED, -1, -1, -1, -1, -1, 0
+    };
+    static const int8_t left[12] = {
+        0, -1, TOP_DC_PRED, 0, -1, -1, -1, 0, -1, DC_128_PRED
+    };
     int i;
 
-    if(!(h->top_samples_available&0x8000)){
-        for(i=0; i<4; i++){
-            int status= top[ h->intra4x4_pred_mode_cache[scan8[0] + i] ];
-            if(status<0){
-                av_log(h->s.avctx, AV_LOG_ERROR, "top block unavailable for requested intra4x4 mode %d at %d %d\n", status, s->mb_x, s->mb_y);
+    if (!(h->top_samples_available & 0x8000)) {
+        for (i = 0; i < 4; i++) {
+            int status = top[h->intra4x4_pred_mode_cache[scan8[0] + i]];
+            if (status < 0) {
+                av_log(h->avctx, AV_LOG_ERROR,
+                       "top block unavailable for requested intra4x4 mode %d at %d %d\n",
+                       status, h->mb_x, h->mb_y);
                 return -1;
-            } else if(status){
-                h->intra4x4_pred_mode_cache[scan8[0] + i]= status;
+            } else if (status) {
+                h->intra4x4_pred_mode_cache[scan8[0] + i] = status;
             }
         }
     }
 
-    if((h->left_samples_available&0x8888)!=0x8888){
-        static const int mask[4]={0x8000,0x2000,0x80,0x20};
-        for(i=0; i<4; i++){
-            if(!(h->left_samples_available&mask[i])){
-                int status= left[ h->intra4x4_pred_mode_cache[scan8[0] + 8*i] ];
-                if(status<0){
-                    av_log(h->s.avctx, AV_LOG_ERROR, "left block unavailable for requested intra4x4 mode %d at %d %d\n", status, s->mb_x, s->mb_y);
+    if ((h->left_samples_available & 0x8888) != 0x8888) {
+        static const int mask[4] = { 0x8000, 0x2000, 0x80, 0x20 };
+        for (i = 0; i < 4; i++)
+            if (!(h->left_samples_available & mask[i])) {
+                int status = left[h->intra4x4_pred_mode_cache[scan8[0] + 8 * i]];
+                if (status < 0) {
+                    av_log(h->avctx, AV_LOG_ERROR,
+                           "left block unavailable for requested intra4x4 mode %d at %d %d\n",
+                           status, h->mb_x, h->mb_y);
                     return -1;
-                } else if(status){
-                    h->intra4x4_pred_mode_cache[scan8[0] + 8*i]= status;
+                } else if (status) {
+                    h->intra4x4_pred_mode_cache[scan8[0] + 8 * i] = status;
                 }
             }
-        }
     }
 
     return 0;
-} //FIXME cleanup like check_intra_pred_mode
+} // FIXME cleanup like ff_h264_check_intra_pred_mode
 
-int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma){
-    MpegEncContext * const s = &h->s;
-    static const int8_t top [7]= {LEFT_DC_PRED8x8, 1,-1,-1};
-    static const int8_t left[7]= { TOP_DC_PRED8x8,-1, 2,-1,DC_128_PRED8x8};
+/**
+ * Check if the top & left blocks are available if needed and
+ * change the dc mode so it only uses the available blocks.
+ */
+int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)
+{
+    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };
+    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };
 
-    if(mode > 6U) {
-        av_log(h->s.avctx, AV_LOG_ERROR, "out of range intra chroma pred mode at %d %d\n", s->mb_x, s->mb_y);
+    if (mode > 6U) {
+        av_log(h->avctx, AV_LOG_ERROR,
+               "out of range intra chroma pred mode at %d %d\n",
+               h->mb_x, h->mb_y);
         return -1;
     }
 
-    if(!(h->top_samples_available&0x8000)){
-        mode= top[ mode ];
-        if(mode<0){
-            av_log(h->s.avctx, AV_LOG_ERROR, "top block unavailable for requested intra mode at %d %d\n", s->mb_x, s->mb_y);
+    if (!(h->top_samples_available & 0x8000)) {
+        mode = top[mode];
+        if (mode < 0) {
+            av_log(h->avctx, AV_LOG_ERROR,
+                   "top block unavailable for requested intra mode at %d %d\n",
+                   h->mb_x, h->mb_y);
             return -1;
         }
     }
 
-    if((h->left_samples_available&0x8080) != 0x8080){
-        mode= left[ mode ];
-        if(is_chroma && (h->left_samples_available&0x8080)){ //mad cow disease mode, aka MBAFF + constrained_intra_pred
-            mode= ALZHEIMER_DC_L0T_PRED8x8 + (!(h->left_samples_available&0x8000)) + 2*(mode == DC_128_PRED8x8);
+    if ((h->left_samples_available & 0x8080) != 0x8080) {
+        mode = left[mode];
+        if (is_chroma && (h->left_samples_available & 0x8080)) {
+            // mad cow disease mode, aka MBAFF + constrained_intra_pred
+            mode = ALZHEIMER_DC_L0T_PRED8x8 +
+                   (!(h->left_samples_available & 0x8000)) +
+                   2 * (mode == DC_128_PRED8x8);
         }
-        if(mode<0){
-            av_log(h->s.avctx, AV_LOG_ERROR, "left block unavailable for requested intra mode at %d %d\n", s->mb_x, s->mb_y);
+        if (mode < 0) {
+            av_log(h->avctx, AV_LOG_ERROR,
+                   "left block unavailable for requested intra mode at %d %d\n",
+                   h->mb_x, h->mb_y);
             return -1;
         }
     }
 
     return mode;
 }
 
-
-const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){
+const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src,
+                                  int *dst_length, int *consumed, int length)
+{
     int i, si, di;
     uint8_t *dst;
     int bufidx;
 
-//    src[0]&0x80;                //forbidden bit
-    h->nal_ref_idc= src[0]>>5;
-    h->nal_unit_type= src[0]&0x1F;
+    // src[0]&0x80; // forbidden bit
+    h->nal_ref_idc   = src[0] >> 5;
+    h->nal_unit_type = src[0] & 0x1F;
 
-    src++; length--;
+    src++;
+    length--;
 
+#define STARTCODE_TEST                                                  \
+        if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \
+            if (src[i + 2] != 3) {                                      \
+                /* startcode, so we must be past the end */             \
+                length = i;                                             \
+            }                                                           \
+            break;                                                      \
+        }
 #if HAVE_FAST_UNALIGNED
-# if HAVE_FAST_64BIT
-#   define RS 7
-    for(i=0; i+1<length; i+=9){
-        if(!((~AV_RN64A(src+i) & (AV_RN64A(src+i) - 0x0100010001000101ULL)) & 0x8000800080008080ULL))
-# else
-#   define RS 3
-    for(i=0; i+1<length; i+=5){
-        if(!((~AV_RN32A(src+i) & (AV_RN32A(src+i) - 0x01000101U)) & 0x80008080U))
-# endif
+#define FIND_FIRST_ZERO                                                 \
+        if (i > 0 && !src[i])                                           \
+            i--;                                                        \
+        while (src[i])                                                  \
+            i++
+#if HAVE_FAST_64BIT
+    for (i = 0; i + 1 < length; i += 9) {
+        if (!((~AV_RN64A(src + i) &
+               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &
+              0x8000800080008080ULL))
             continue;
-        if(i>0 && !src[i]) i--;
-        while(src[i]) i++;
+        FIND_FIRST_ZERO;
+        STARTCODE_TEST;
+        i -= 7;
+    }
 #else
-#   define RS 0
-    for(i=0; i+1<length; i+=2){
-        if(src[i]) continue;
-        if(i>0 && src[i-1]==0) i--;
+    for (i = 0; i + 1 < length; i += 5) {
+        if (!((~AV_RN32A(src + i) &
+               (AV_RN32A(src + i) - 0x01000101U)) &
+              0x80008080U))
+            continue;
+        FIND_FIRST_ZERO;
+        STARTCODE_TEST;
+        i -= 3;
+    }
 #endif
-        if(i+2<length && src[i+1]==0 && src[i+2]<=3){
-            if(src[i+2]!=3){
-                /* startcode, so we must be past the end */
-                length=i;
-            }
-            break;
-        }
-        i-= RS;
+#else
+    for (i = 0; i + 1 < length; i += 2) {
+        if (src[i])
+            continue;
+        if (i > 0 && src[i - 1] == 0)
+            i--;
+        STARTCODE_TEST;
     }
+#endif
 
-    bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0; // use second escape buffer for inter data
-    si=h->rbsp_buffer_size[bufidx];
-    av_fast_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+FF_INPUT_BUFFER_PADDING_SIZE+MAX_MBPAIR_SIZE);
-    dst= h->rbsp_buffer[bufidx];
-    if(si != h->rbsp_buffer_size[bufidx])
-        memset(dst + length, 0, FF_INPUT_BUFFER_PADDING_SIZE+MAX_MBPAIR_SIZE);
+    // use second escape buffer for inter data
+    bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0;
 
-    if (dst == NULL){
+    si = h->rbsp_buffer_size[bufidx];
+    av_fast_padded_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+MAX_MBPAIR_SIZE);
+    dst = h->rbsp_buffer[bufidx];
+
+    if (dst == NULL)
         return NULL;
-    }
 
     if(i>=length-1){ //no escaped 0
         *dst_length= length;
         *consumed= length+1; //+1 for the header
-        if(h->s.avctx->flags2 & CODEC_FLAG2_FAST){
+        if(h->avctx->flags2 & CODEC_FLAG2_FAST){
             return src;
         }else{
             memcpy(dst, src, length);
             return dst;
         }
     }
 
-//printf("decoding esc\n");
     memcpy(dst, src, i);
-    si=di=i;
-    while(si+2<length){
-        //remove escapes (very rare 1:2^22)
-        if(src[si+2]>3){
-            dst[di++]= src[si++];
-            dst[di++]= src[si++];
-        }else if(src[si]==0 && src[si+1]==0){
-            if(src[si+2]==3){ //escape
-                dst[di++]= 0;
-                dst[di++]= 0;
-                si+=3;
+    si = di = i;
+    while (si + 2 < length) {
+        // remove escapes (very rare 1:2^22)
+        if (src[si + 2] > 3) {
+            dst[di++] = src[si++];
+            dst[di++] = src[si++];
+        } else if (src[si] == 0 && src[si + 1] == 0) {
+            if (src[si + 2] == 3) { // escape
+                dst[di++]  = 0;
+                dst[di++]  = 0;
+                si        += 3;
                 continue;
-            }else //next start code
+            } else // next start code
                 goto nsc;
         }
 
-        dst[di++]= src[si++];
+        dst[di++] = src[si++];
     }
-    while(si<length)
-        dst[di++]= src[si++];
+    while (si < length)
+        dst[di++] = src[si++];
 nsc:
 
-    memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+    memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);
 
-    *dst_length= di;
-    *consumed= si + 1;//+1 for the header
-//FIXME store exact number of bits in the getbitcontext (it is needed for decoding)
+    *dst_length = di;
+    *consumed   = si + 1; // +1 for the header
+    /* FIXME store exact number of bits in the getbitcontext
+     * (it is needed for decoding) */
     return dst;
 }
 
 /**
  * Identify the exact end of the bitstream
  * @return the length of the trailing, or 0 if damaged
  */
-static int ff_h264_decode_rbsp_trailing(H264Context *h, const uint8_t *src){
-    int v= *src;
+static int decode_rbsp_trailing(H264Context *h, const uint8_t *src)
+{
+    int v = *src;
     int r;
 
-    tprintf(h->s.avctx, "rbsp trailing %X\n", v);
+    tprintf(h->avctx, "rbsp trailing %X\n", v);
 
-    for(r=1; r<9; r++){
-        if(v&1) return r;
-        v>>=1;
+    for (r = 1; r < 9; r++) {
+        if (v & 1)
+            return r;
+        v >>= 1;
     }
     return 0;
 }
 
-static inline int get_lowest_part_list_y(H264Context *h, Picture *pic, int n, int height,
-                                 int y_offset, int list){
-    int raw_my= h->mv_cache[list][ scan8[n] ][1];
-    int filter_height= (raw_my&3) ? 2 : 0;
-    int full_my= (raw_my>>2) + y_offset;
-    int top = full_my - filter_height, bottom = full_my + height + filter_height;
+static inline int get_lowest_part_list_y(H264Context *h, Picture *pic, int n,
+                                         int height, int y_offset, int list)
+{
+    int raw_my        = h->mv_cache[list][scan8[n]][1];
+    int filter_height_down = (raw_my & 3) ? 3 : 0;
+    int full_my       = (raw_my >> 2) + y_offset;
+    int bottom        = full_my + filter_height_down + height;
+
+    av_assert2(height >= 0);
 
-    return FFMAX(abs(top), bottom);
+    return FFMAX(0, bottom);
 }
 
-static inline void get_lowest_part_y(H264Context *h, int refs[2][48], int n, int height,
-                               int y_offset, int list0, int list1, int *nrefs){
-    MpegEncContext * const s = &h->s;
+static inline void get_lowest_part_y(H264Context *h, int refs[2][48], int n,
+                                     int height, int y_offset, int list0,
+                                     int list1, int *nrefs)
+{
     int my;
 
-    y_offset += 16*(s->mb_y >> MB_FIELD);
+    y_offset += 16 * (h->mb_y >> MB_FIELD);
 
-    if(list0){
-        int ref_n = h->ref_cache[0][ scan8[n] ];
-        Picture *ref= &h->ref_list[0][ref_n];
+    if (list0) {
+        int ref_n    = h->ref_cache[0][scan8[n]];
+        Picture *ref = &h->ref_list[0][ref_n];
 
         // Error resilience puts the current picture in the ref list.
         // Don't try to wait on these as it will cause a deadlock.
         // Fields can wait on each other, though.
-        if (ref->f.thread_opaque != s->current_picture.f.thread_opaque ||
-           (ref->f.reference & 3) != s->picture_structure) {
+        if (ref->f.thread_opaque   != h->cur_pic.f.thread_opaque ||
+            (ref->f.reference & 3) != h->picture_structure) {
             my = get_lowest_part_list_y(h, ref, n, height, y_offset, 0);
-            if (refs[0][ref_n] < 0) nrefs[0] += 1;
+            if (refs[0][ref_n] < 0)
+                nrefs[0] += 1;
             refs[0][ref_n] = FFMAX(refs[0][ref_n], my);
         }
     }
 
-    if(list1){
-        int ref_n = h->ref_cache[1][ scan8[n] ];
-        Picture *ref= &h->ref_list[1][ref_n];
+    if (list1) {
+        int ref_n    = h->ref_cache[1][scan8[n]];
+        Picture *ref = &h->ref_list[1][ref_n];
 
-        if (ref->f.thread_opaque != s->current_picture.f.thread_opaque ||
-           (ref->f.reference & 3) != s->picture_structure) {
+        if (ref->f.thread_opaque   != h->cur_pic.f.thread_opaque ||
+            (ref->f.reference & 3) != h->picture_structure) {
             my = get_lowest_part_list_y(h, ref, n, height, y_offset, 1);
-            if (refs[1][ref_n] < 0) nrefs[1] += 1;
+            if (refs[1][ref_n] < 0)
+                nrefs[1] += 1;
             refs[1][ref_n] = FFMAX(refs[1][ref_n], my);
         }
     }
 }
 
 /**
  * Wait until all reference frames are available for MC operations.
  *
  * @param h the H264 context
  */
-static void await_references(H264Context *h){
-    MpegEncContext * const s = &h->s;
-    const int mb_xy= h->mb_xy;
-    const int mb_type = s->current_picture.f.mb_type[mb_xy];
+static void await_references(H264Context *h)
+{
+    const int mb_xy   = h->mb_xy;
+    const int mb_type = h->cur_pic.f.mb_type[mb_xy];
     int refs[2][48];
-    int nrefs[2] = {0};
+    int nrefs[2] = { 0 };
     int ref, list;
 
     memset(refs, -1, sizeof(refs));
 
-    if(IS_16X16(mb_type)){
+    if (IS_16X16(mb_type)) {
         get_lowest_part_y(h, refs, 0, 16, 0,
-                  IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);
-    }else if(IS_16X8(mb_type)){
+                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);
+    } else if (IS_16X8(mb_type)) {
         get_lowest_part_y(h, refs, 0, 8, 0,
-                  IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);
+                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);
         get_lowest_part_y(h, refs, 8, 8, 8,
-                  IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);
-    }else if(IS_8X16(mb_type)){
+                          IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);
+    } else if (IS_8X16(mb_type)) {
         get_lowest_part_y(h, refs, 0, 16, 0,
-                  IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);
+                          IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);
         get_lowest_part_y(h, refs, 4, 16, 0,
-                  IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);
-    }else{
+                          IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);
+    } else {
         int i;
 
-        assert(IS_8X8(mb_type));
-
-        for(i=0; i<4; i++){
-            const int sub_mb_type= h->sub_mb_type[i];
-            const int n= 4*i;
-            int y_offset= (i&2)<<2;
-
-            if(IS_SUB_8X8(sub_mb_type)){
-                get_lowest_part_y(h, refs, n  , 8, y_offset,
-                          IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);
-            }else if(IS_SUB_8X4(sub_mb_type)){
-                get_lowest_part_y(h, refs, n  , 4, y_offset,
-                          IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);
-                get_lowest_part_y(h, refs, n+2, 4, y_offset+4,
-                          IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);
-            }else if(IS_SUB_4X8(sub_mb_type)){
-                get_lowest_part_y(h, refs, n  , 8, y_offset,
-                          IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);
-                get_lowest_part_y(h, refs, n+1, 8, y_offset,
-                          IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);
-            }else{
+        av_assert2(IS_8X8(mb_type));
+
+        for (i = 0; i < 4; i++) {
+            const int sub_mb_type = h->sub_mb_type[i];
+            const int n           = 4 * i;
+            int y_offset          = (i & 2) << 2;
+
+            if (IS_SUB_8X8(sub_mb_type)) {
+                get_lowest_part_y(h, refs, n, 8, y_offset,
+                                  IS_DIR(sub_mb_type, 0, 0),
+                                  IS_DIR(sub_mb_type, 0, 1),
+                                  nrefs);
+            } else if (IS_SUB_8X4(sub_mb_type)) {
+                get_lowest_part_y(h, refs, n, 4, y_offset,
+                                  IS_DIR(sub_mb_type, 0, 0),
+                                  IS_DIR(sub_mb_type, 0, 1),
+                                  nrefs);
+                get_lowest_part_y(h, refs, n + 2, 4, y_offset + 4,
+                                  IS_DIR(sub_mb_type, 0, 0),
+                                  IS_DIR(sub_mb_type, 0, 1),
+                                  nrefs);
+            } else if (IS_SUB_4X8(sub_mb_type)) {
+                get_lowest_part_y(h, refs, n, 8, y_offset,
+                                  IS_DIR(sub_mb_type, 0, 0),
+                                  IS_DIR(sub_mb_type, 0, 1),
+                                  nrefs);
+                get_lowest_part_y(h, refs, n + 1, 8, y_offset,
+                                  IS_DIR(sub_mb_type, 0, 0),
+                                  IS_DIR(sub_mb_type, 0, 1),
+                                  nrefs);
+            } else {
                 int j;
-                assert(IS_SUB_4X4(sub_mb_type));
-                for(j=0; j<4; j++){
-                    int sub_y_offset= y_offset + 2*(j&2);
-                    get_lowest_part_y(h, refs, n+j, 4, sub_y_offset,
-                              IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);
+                av_assert2(IS_SUB_4X4(sub_mb_type));
+                for (j = 0; j < 4; j++) {
+                    int sub_y_offset = y_offset + 2 * (j & 2);
+                    get_lowest_part_y(h, refs, n + j, 4, sub_y_offset,
+                                      IS_DIR(sub_mb_type, 0, 0),
+                                      IS_DIR(sub_mb_type, 0, 1),
+                                      nrefs);
                 }
             }
         }
     }
 
-    for(list=h->list_count-1; list>=0; list--){
-        for(ref=0; ref<48 && nrefs[list]; ref++){
+    for (list = h->list_count - 1; list >= 0; list--)
+        for (ref = 0; ref < 48 && nrefs[list]; ref++) {
             int row = refs[list][ref];
-            if(row >= 0){
-                Picture *ref_pic = &h->ref_list[list][ref];
-                int ref_field = ref_pic->f.reference - 1;
+            if (row >= 0) {
+                Picture *ref_pic      = &h->ref_list[list][ref];
+                int ref_field         = ref_pic->f.reference - 1;
                 int ref_field_picture = ref_pic->field_picture;
-                int pic_height = 16*s->mb_height >> ref_field_picture;
+                int pic_height        = 16 * h->mb_height >> ref_field_picture;
 
                 row <<= MB_MBAFF;
                 nrefs[list]--;
 
-                if(!FIELD_PICTURE && ref_field_picture){ // frame referencing two fields
-                    ff_thread_await_progress((AVFrame*)ref_pic, FFMIN((row >> 1) - !(row&1), pic_height-1), 1);
-                    ff_thread_await_progress((AVFrame*)ref_pic, FFMIN((row >> 1)           , pic_height-1), 0);
-                }else if(FIELD_PICTURE && !ref_field_picture){ // field referencing one field of a frame
-                    ff_thread_await_progress((AVFrame*)ref_pic, FFMIN(row*2 + ref_field    , pic_height-1), 0);
-                }else if(FIELD_PICTURE){
-                    ff_thread_await_progress((AVFrame*)ref_pic, FFMIN(row, pic_height-1), ref_field);
-                }else{
-                    ff_thread_await_progress((AVFrame*)ref_pic, FFMIN(row, pic_height-1), 0);
+                if (!FIELD_PICTURE && ref_field_picture) { // frame referencing two fields
+                    ff_thread_await_progress(&ref_pic->f,
+                                             FFMIN((row >> 1) - !(row & 1),
+                                                   pic_height - 1),
+                                             1);
+                    ff_thread_await_progress(&ref_pic->f,
+                                             FFMIN((row >> 1), pic_height - 1),
+                                             0);
+                } else if (FIELD_PICTURE && !ref_field_picture) { // field referencing one field of a frame
+                    ff_thread_await_progress(&ref_pic->f,
+                                             FFMIN(row * 2 + ref_field,
+                                                   pic_height - 1),
+                                             0);
+                } else if (FIELD_PICTURE) {
+                    ff_thread_await_progress(&ref_pic->f,
+                                             FFMIN(row, pic_height - 1),
+                                             ref_field);
+                } else {
+                    ff_thread_await_progress(&ref_pic->f,
+                                             FFMIN(row, pic_height - 1),
+                                             0);
                 }
             }
         }
-    }
 }
 
-#if 0
-/**
- * DCT transforms the 16 dc values.
- * @param qp quantization parameter ??? FIXME
- */
-static void h264_luma_dc_dct_c(DCTELEM *block/*, int qp*/){
-//    const int qmul= dequant_coeff[qp][0];
-    int i;
-    int temp[16]; //FIXME check if this is a good idea
-    static const int x_offset[4]={0, 1*stride, 4* stride,  5*stride};
-    static const int y_offset[4]={0, 2*stride, 8* stride, 10*stride};
-
-    for(i=0; i<4; i++){
-        const int offset= y_offset[i];
-        const int z0= block[offset+stride*0] + block[offset+stride*4];
-        const int z1= block[offset+stride*0] - block[offset+stride*4];
-        const int z2= block[offset+stride*1] - block[offset+stride*5];
-        const int z3= block[offset+stride*1] + block[offset+stride*5];
-
-        temp[4*i+0]= z0+z3;
-        temp[4*i+1]= z1+z2;
-        temp[4*i+2]= z1-z2;
-        temp[4*i+3]= z0-z3;
-    }
-
-    for(i=0; i<4; i++){
-        const int offset= x_offset[i];
-        const int z0= temp[4*0+i] + temp[4*2+i];
-        const int z1= temp[4*0+i] - temp[4*2+i];
-        const int z2= temp[4*1+i] - temp[4*3+i];
-        const int z3= temp[4*1+i] + temp[4*3+i];
-
-        block[stride*0 +offset]= (z0 + z3)>>1;
-        block[stride*2 +offset]= (z1 + z2)>>1;
-        block[stride*8 +offset]= (z1 - z2)>>1;
-        block[stride*10+offset]= (z0 - z3)>>1;
-    }
-}
-#endif
-
-#undef xStride
-#undef stride
-
-#if 0
-static void chroma_dc_dct_c(DCTELEM *block){
-    const int stride= 16*2;
-    const int xStride= 16;
-    int a,b,c,d,e;
-
-    a= block[stride*0 + xStride*0];
-    b= block[stride*0 + xStride*1];
-    c= block[stride*1 + xStride*0];
-    d= block[stride*1 + xStride*1];
-
-    e= a-b;
-    a= a+b;
-    b= c-d;
-    c= c+d;
-
-    block[stride*0 + xStride*0]= (a+c);
-    block[stride*0 + xStride*1]= (e+b);
-    block[stride*1 + xStride*0]= (a-c);
-    block[stride*1 + xStride*1]= (e-b);
-}
-#endif
-
-static av_always_inline void
-mc_dir_part(H264Context *h, Picture *pic, int n, int square,
-            int height, int delta, int list,
-            uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-            int src_x_offset, int src_y_offset,
-            qpel_mc_func *qpix_op, h264_chroma_mc_func chroma_op,
-            int pixel_shift, int chroma_idc)
+static av_always_inline void mc_dir_part(H264Context *h, Picture *pic,
+                                         int n, int square, int height,
+                                         int delta, int list,
+                                         uint8_t *dest_y, uint8_t *dest_cb,
+                                         uint8_t *dest_cr,
+                                         int src_x_offset, int src_y_offset,
+                                         qpel_mc_func *qpix_op,
+                                         h264_chroma_mc_func chroma_op,
+                                         int pixel_shift, int chroma_idc)
 {
-    MpegEncContext * const s = &h->s;
-    const int mx= h->mv_cache[list][ scan8[n] ][0] + src_x_offset*8;
-    int my=       h->mv_cache[list][ scan8[n] ][1] + src_y_offset*8;
-    const int luma_xy= (mx&3) + ((my&3)<<2);
-    int offset = ((mx>>2) << pixel_shift) + (my>>2)*h->mb_linesize;
-    uint8_t * src_y = pic->f.data[0] + offset;
-    uint8_t * src_cb, * src_cr;
-    int extra_width= h->emu_edge_width;
-    int extra_height= h->emu_edge_height;
-    int emu=0;
-    const int full_mx= mx>>2;
-    const int full_my= my>>2;
-    const int pic_width  = 16*s->mb_width;
-    const int pic_height = 16*s->mb_height >> MB_FIELD;
+    const int mx      = h->mv_cache[list][scan8[n]][0] + src_x_offset * 8;
+    int my            = h->mv_cache[list][scan8[n]][1] + src_y_offset * 8;
+    const int luma_xy = (mx & 3) + ((my & 3) << 2);
+    int offset        = ((mx >> 2) << pixel_shift) + (my >> 2) * h->mb_linesize;
+    uint8_t *src_y    = pic->f.data[0] + offset;
+    uint8_t *src_cb, *src_cr;
+    int extra_width  = 0;
+    int extra_height = 0;
+    int emu = 0;
+    const int full_mx    = mx >> 2;
+    const int full_my    = my >> 2;
+    const int pic_width  = 16 * h->mb_width;
+    const int pic_height = 16 * h->mb_height >> MB_FIELD;
     int ysh;
 
-    if(mx&7) extra_width -= 3;
-    if(my&7) extra_height -= 3;
-
-    if(   full_mx < 0-extra_width
-       || full_my < 0-extra_height
-       || full_mx + 16/*FIXME*/ > pic_width + extra_width
-       || full_my + 16/*FIXME*/ > pic_height + extra_height){
-        s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_y - (2 << pixel_shift) - 2*h->mb_linesize, h->mb_linesize,
-                                16+5, 16+5/*FIXME*/, full_mx-2, full_my-2, pic_width, pic_height);
-            src_y= s->edge_emu_buffer + (2 << pixel_shift) + 2*h->mb_linesize;
-        emu=1;
-    }
-
-    qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); //FIXME try variable height perhaps?
-    if(!square){
+    if (mx & 7)
+        extra_width -= 3;
+    if (my & 7)
+        extra_height -= 3;
+
+    if (full_mx                <          0 - extra_width  ||
+        full_my                <          0 - extra_height ||
+        full_mx + 16 /*FIXME*/ > pic_width  + extra_width  ||
+        full_my + 16 /*FIXME*/ > pic_height + extra_height) {
+        h->vdsp.emulated_edge_mc(h->edge_emu_buffer,
+                                 src_y - (2 << pixel_shift) - 2 * h->mb_linesize,
+                                 h->mb_linesize,
+                                 16 + 5, 16 + 5 /*FIXME*/, full_mx - 2,
+                                 full_my - 2, pic_width, pic_height);
+        src_y = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;
+        emu   = 1;
+    }
+
+    qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); // FIXME try variable height perhaps?
+    if (!square)
         qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);
-    }
 
-    if(CONFIG_GRAY && s->flags&CODEC_FLAG_GRAY) return;
+    if (CONFIG_GRAY && h->flags & CODEC_FLAG_GRAY)
+        return;
 
-    if(chroma_idc == 3 /* yuv444 */){
+    if (chroma_idc == 3 /* yuv444 */) {
         src_cb = pic->f.data[1] + offset;
-        if(emu){
-            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cb - (2 << pixel_shift) - 2*h->mb_linesize, h->mb_linesize,
-                                    16+5, 16+5/*FIXME*/, full_mx-2, full_my-2, pic_width, pic_height);
-            src_cb= s->edge_emu_buffer + (2 << pixel_shift) + 2*h->mb_linesize;
+        if (emu) {
+            h->vdsp.emulated_edge_mc(h->edge_emu_buffer,
+                                     src_cb - (2 << pixel_shift) - 2 * h->mb_linesize,
+                                     h->mb_linesize,
+                                     16 + 5, 16 + 5 /*FIXME*/,
+                                     full_mx - 2, full_my - 2,
+                                     pic_width, pic_height);
+            src_cb = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;
         }
-        qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); //FIXME try variable height perhaps?
-        if(!square){
+        qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); // FIXME try variable height perhaps?
+        if (!square)
             qpix_op[luma_xy](dest_cb + delta, src_cb + delta, h->mb_linesize);
-        }
 
         src_cr = pic->f.data[2] + offset;
-        if(emu){
-            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cr - (2 << pixel_shift) - 2*h->mb_linesize, h->mb_linesize,
-                                    16+5, 16+5/*FIXME*/, full_mx-2, full_my-2, pic_width, pic_height);
-            src_cr= s->edge_emu_buffer + (2 << pixel_shift) + 2*h->mb_linesize;
+        if (emu) {
+            h->vdsp.emulated_edge_mc(h->edge_emu_buffer,
+                                     src_cr - (2 << pixel_shift) - 2 * h->mb_linesize,
+                                     h->mb_linesize,
+                                     16 + 5, 16 + 5 /*FIXME*/,
+                                     full_mx - 2, full_my - 2,
+                                     pic_width, pic_height);
+            src_cr = h->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;
         }
-        qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); //FIXME try variable height perhaps?
-        if(!square){
+        qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); // FIXME try variable height perhaps?
+        if (!square)
             qpix_op[luma_xy](dest_cr + delta, src_cr + delta, h->mb_linesize);
-        }
         return;
     }
 
     ysh = 3 - (chroma_idc == 2 /* yuv422 */);
-    if(chroma_idc == 1 /* yuv420 */ && MB_FIELD){
+    if (chroma_idc == 1 /* yuv420 */ && MB_FIELD) {
         // chroma offset when predicting from a field of opposite parity
-        my += 2 * ((s->mb_y & 1) - (pic->f.reference - 1));
-        emu |= (my>>3) < 0 || (my>>3) + 8 >= (pic_height>>1);
+        my  += 2 * ((h->mb_y & 1) - (pic->f.reference - 1));
+        emu |= (my >> 3) < 0 || (my >> 3) + 8 >= (pic_height >> 1);
     }
 
-    src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) + (my >> ysh) * h->mb_uvlinesize;
-    src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) + (my >> ysh) * h->mb_uvlinesize;
+    src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) +
+             (my >> ysh) * h->mb_uvlinesize;
+    src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) +
+             (my >> ysh) * h->mb_uvlinesize;
 
-    if(emu){
-        s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cb, h->mb_uvlinesize,
-                                9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),
-                                pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));
-            src_cb= s->edge_emu_buffer;
+    if (emu) {
+        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, src_cb, h->mb_uvlinesize,
+                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),
+                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));
+        src_cb = h->edge_emu_buffer;
     }
-    chroma_op(dest_cb, src_cb, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),
-              mx&7, (my << (chroma_idc == 2 /* yuv422 */)) &7);
+    chroma_op(dest_cb, src_cb, h->mb_uvlinesize,
+              height >> (chroma_idc == 1 /* yuv420 */),
+              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);
 
-    if(emu){
-        s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cr, h->mb_uvlinesize,
-                                9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),
-                                pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));
-            src_cr= s->edge_emu_buffer;
+    if (emu) {
+        h->vdsp.emulated_edge_mc(h->edge_emu_buffer, src_cr, h->mb_uvlinesize,
+                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),
+                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));
+        src_cr = h->edge_emu_buffer;
     }
     chroma_op(dest_cr, src_cr, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),
-              mx&7, (my << (chroma_idc == 2 /* yuv422 */)) &7);
+              mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);
 }
 
-static av_always_inline void
-mc_part_std(H264Context *h, int n, int square, int height, int delta,
-            uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-            int x_offset, int y_offset,
-            qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,
-            qpel_mc_func *qpix_avg, h264_chroma_mc_func chroma_avg,
-            int list0, int list1, int pixel_shift, int chroma_idc)
+static av_always_inline void mc_part_std(H264Context *h, int n, int square,
+                                         int height, int delta,
+                                         uint8_t *dest_y, uint8_t *dest_cb,
+                                         uint8_t *dest_cr,
+                                         int x_offset, int y_offset,
+                                         qpel_mc_func *qpix_put,
+                                         h264_chroma_mc_func chroma_put,
+                                         qpel_mc_func *qpix_avg,
+                                         h264_chroma_mc_func chroma_avg,
+                                         int list0, int list1,
+                                         int pixel_shift, int chroma_idc)
 {
-    MpegEncContext * const s = &h->s;
-    qpel_mc_func *qpix_op=  qpix_put;
-    h264_chroma_mc_func chroma_op= chroma_put;
+    qpel_mc_func *qpix_op         = qpix_put;
+    h264_chroma_mc_func chroma_op = chroma_put;
 
-    dest_y  += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;
+    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;
     if (chroma_idc == 3 /* yuv444 */) {
-        dest_cb += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;
-        dest_cr += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;
+        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;
+        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;
     } else if (chroma_idc == 2 /* yuv422 */) {
-        dest_cb += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;
-        dest_cr += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;
-    } else /* yuv420 */ {
-        dest_cb += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;
-        dest_cr += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;
+        dest_cb += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;
+        dest_cr += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;
+    } else { /* yuv420 */
+        dest_cb += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;
+        dest_cr += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;
     }
-    x_offset += 8*s->mb_x;
-    y_offset += 8*(s->mb_y >> MB_FIELD);
+    x_offset += 8 * h->mb_x;
+    y_offset += 8 * (h->mb_y >> MB_FIELD);
 
-    if(list0){
-        Picture *ref= &h->ref_list[0][ h->ref_cache[0][ scan8[n] ] ];
+    if (list0) {
+        Picture *ref = &h->ref_list[0][h->ref_cache[0][scan8[n]]];
         mc_dir_part(h, ref, n, square, height, delta, 0,
-                           dest_y, dest_cb, dest_cr, x_offset, y_offset,
-                           qpix_op, chroma_op, pixel_shift, chroma_idc);
+                    dest_y, dest_cb, dest_cr, x_offset, y_offset,
+                    qpix_op, chroma_op, pixel_shift, chroma_idc);
 
-        qpix_op=  qpix_avg;
-        chroma_op= chroma_avg;
+        qpix_op   = qpix_avg;
+        chroma_op = chroma_avg;
     }
 
-    if(list1){
-        Picture *ref= &h->ref_list[1][ h->ref_cache[1][ scan8[n] ] ];
+    if (list1) {
+        Picture *ref = &h->ref_list[1][h->ref_cache[1][scan8[n]]];
         mc_dir_part(h, ref, n, square, height, delta, 1,
-                           dest_y, dest_cb, dest_cr, x_offset, y_offset,
-                           qpix_op, chroma_op, pixel_shift, chroma_idc);
+                    dest_y, dest_cb, dest_cr, x_offset, y_offset,
+                    qpix_op, chroma_op, pixel_shift, chroma_idc);
     }
 }
 
-static av_always_inline void
-mc_part_weighted(H264Context *h, int n, int square, int height, int delta,
-                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                 int x_offset, int y_offset,
-                 qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,
-                 h264_weight_func luma_weight_op, h264_weight_func chroma_weight_op,
-                 h264_biweight_func luma_weight_avg, h264_biweight_func chroma_weight_avg,
-                 int list0, int list1, int pixel_shift, int chroma_idc){
-    MpegEncContext * const s = &h->s;
+static av_always_inline void mc_part_weighted(H264Context *h, int n, int square,
+                                              int height, int delta,
+                                              uint8_t *dest_y, uint8_t *dest_cb,
+                                              uint8_t *dest_cr,
+                                              int x_offset, int y_offset,
+                                              qpel_mc_func *qpix_put,
+                                              h264_chroma_mc_func chroma_put,
+                                              h264_weight_func luma_weight_op,
+                                              h264_weight_func chroma_weight_op,
+                                              h264_biweight_func luma_weight_avg,
+                                              h264_biweight_func chroma_weight_avg,
+                                              int list0, int list1,
+                                              int pixel_shift, int chroma_idc)
+{
     int chroma_height;
 
-    dest_y += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;
+    dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;
     if (chroma_idc == 3 /* yuv444 */) {
-        chroma_height = height;
+        chroma_height     = height;
         chroma_weight_avg = luma_weight_avg;
-        chroma_weight_op = luma_weight_op;
-        dest_cb += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;
-        dest_cr += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;
+        chroma_weight_op  = luma_weight_op;
+        dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;
+        dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;
     } else if (chroma_idc == 2 /* yuv422 */) {
         chroma_height = height;
-        dest_cb += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;
-        dest_cr += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;
-    } else /* yuv420 */ {
+        dest_cb      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;
+        dest_cr      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;
+    } else { /* yuv420 */
         chroma_height = height >> 1;
-        dest_cb += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;
-        dest_cr += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;
+        dest_cb      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;
+        dest_cr      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;
     }
-    x_offset += 8*s->mb_x;
-    y_offset += 8*(s->mb_y >> MB_FIELD);
+    x_offset += 8 * h->mb_x;
+    y_offset += 8 * (h->mb_y >> MB_FIELD);
 
-    if(list0 && list1){
+    if (list0 && list1) {
         /* don't optimize for luma-only case, since B-frames usually
          * use implicit weights => chroma too. */
-        uint8_t *tmp_cb = s->obmc_scratchpad;
-        uint8_t *tmp_cr = s->obmc_scratchpad + (16 << pixel_shift);
-        uint8_t *tmp_y  = s->obmc_scratchpad + 16*h->mb_uvlinesize;
-        int refn0 = h->ref_cache[0][ scan8[n] ];
-        int refn1 = h->ref_cache[1][ scan8[n] ];
+        uint8_t *tmp_cb = h->bipred_scratchpad;
+        uint8_t *tmp_cr = h->bipred_scratchpad + (16 << pixel_shift);
+        uint8_t *tmp_y  = h->bipred_scratchpad + 16 * h->mb_uvlinesize;
+        int refn0       = h->ref_cache[0][scan8[n]];
+        int refn1       = h->ref_cache[1][scan8[n]];
 
         mc_dir_part(h, &h->ref_list[0][refn0], n, square, height, delta, 0,
                     dest_y, dest_cb, dest_cr,
                     x_offset, y_offset, qpix_put, chroma_put,
                     pixel_shift, chroma_idc);
         mc_dir_part(h, &h->ref_list[1][refn1], n, square, height, delta, 1,
                     tmp_y, tmp_cb, tmp_cr,
                     x_offset, y_offset, qpix_put, chroma_put,
                     pixel_shift, chroma_idc);
 
-        if(h->use_weight == 2){
-            int weight0 = h->implicit_weight[refn0][refn1][s->mb_y&1];
+        if (h->use_weight == 2) {
+            int weight0 = h->implicit_weight[refn0][refn1][h->mb_y & 1];
             int weight1 = 64 - weight0;
-            luma_weight_avg(  dest_y,  tmp_y,  h->  mb_linesize,
-                              height,        5, weight0, weight1, 0);
+            luma_weight_avg(dest_y, tmp_y, h->mb_linesize,
+                            height, 5, weight0, weight1, 0);
             chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize,
                               chroma_height, 5, weight0, weight1, 0);
             chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize,
                               chroma_height, 5, weight0, weight1, 0);
-        }else{
-            luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height, h->luma_log2_weight_denom,
-                            h->luma_weight[refn0][0][0] , h->luma_weight[refn1][1][0],
-                            h->luma_weight[refn0][0][1] + h->luma_weight[refn1][1][1]);
-            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,
-                            h->chroma_weight[refn0][0][0][0] , h->chroma_weight[refn1][1][0][0],
-                            h->chroma_weight[refn0][0][0][1] + h->chroma_weight[refn1][1][0][1]);
-            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,
-                            h->chroma_weight[refn0][0][1][0] , h->chroma_weight[refn1][1][1][0],
-                            h->chroma_weight[refn0][0][1][1] + h->chroma_weight[refn1][1][1][1]);
+        } else {
+            luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height,
+                            h->luma_log2_weight_denom,
+                            h->luma_weight[refn0][0][0],
+                            h->luma_weight[refn1][1][0],
+                            h->luma_weight[refn0][0][1] +
+                            h->luma_weight[refn1][1][1]);
+            chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height,
+                              h->chroma_log2_weight_denom,
+                              h->chroma_weight[refn0][0][0][0],
+                              h->chroma_weight[refn1][1][0][0],
+                              h->chroma_weight[refn0][0][0][1] +
+                              h->chroma_weight[refn1][1][0][1]);
+            chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height,
+                              h->chroma_log2_weight_denom,
+                              h->chroma_weight[refn0][0][1][0],
+                              h->chroma_weight[refn1][1][1][0],
+                              h->chroma_weight[refn0][0][1][1] +
+                              h->chroma_weight[refn1][1][1][1]);
         }
-    }else{
-        int list = list1 ? 1 : 0;
-        int refn = h->ref_cache[list][ scan8[n] ];
-        Picture *ref= &h->ref_list[list][refn];
+    } else {
+        int list     = list1 ? 1 : 0;
+        int refn     = h->ref_cache[list][scan8[n]];
+        Picture *ref = &h->ref_list[list][refn];
         mc_dir_part(h, ref, n, square, height, delta, list,
                     dest_y, dest_cb, dest_cr, x_offset, y_offset,
                     qpix_put, chroma_put, pixel_shift, chroma_idc);
 
-        luma_weight_op(dest_y, h->mb_linesize, height, h->luma_log2_weight_denom,
-                       h->luma_weight[refn][list][0], h->luma_weight[refn][list][1]);
-        if(h->use_weight_chroma){
-            chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,
-                             h->chroma_weight[refn][list][0][0], h->chroma_weight[refn][list][0][1]);
-            chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,
-                             h->chroma_weight[refn][list][1][0], h->chroma_weight[refn][list][1][1]);
+        luma_weight_op(dest_y, h->mb_linesize, height,
+                       h->luma_log2_weight_denom,
+                       h->luma_weight[refn][list][0],
+                       h->luma_weight[refn][list][1]);
+        if (h->use_weight_chroma) {
+            chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height,
+                             h->chroma_log2_weight_denom,
+                             h->chroma_weight[refn][list][0][0],
+                             h->chroma_weight[refn][list][0][1]);
+            chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height,
+                             h->chroma_log2_weight_denom,
+                             h->chroma_weight[refn][list][1][0],
+                             h->chroma_weight[refn][list][1][1]);
         }
     }
 }
 
-static av_always_inline void
-mc_part(H264Context *h, int n, int square, int height, int delta,
-        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-        int x_offset, int y_offset,
-        qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,
-        qpel_mc_func *qpix_avg, h264_chroma_mc_func chroma_avg,
-        h264_weight_func *weight_op, h264_biweight_func *weight_avg,
-        int list0, int list1, int pixel_shift, int chroma_idc)
-{
-    if((h->use_weight==2 && list0 && list1
-        && (h->implicit_weight[ h->ref_cache[0][scan8[n]] ][ h->ref_cache[1][scan8[n]] ][h->s.mb_y&1] != 32))
-       || h->use_weight==1)
-        mc_part_weighted(h, n, square, height, delta, dest_y, dest_cb, dest_cr,
-                         x_offset, y_offset, qpix_put, chroma_put,
-                         weight_op[0], weight_op[1], weight_avg[0],
-                         weight_avg[1], list0, list1, pixel_shift, chroma_idc);
-    else
-        mc_part_std(h, n, square, height, delta, dest_y, dest_cb, dest_cr,
-                    x_offset, y_offset, qpix_put, chroma_put, qpix_avg,
-                    chroma_avg, list0, list1, pixel_shift, chroma_idc);
-}
-
-static av_always_inline void
-prefetch_motion(H264Context *h, int list, int pixel_shift, int chroma_idc)
+static av_always_inline void prefetch_motion(H264Context *h, int list,
+                                             int pixel_shift, int chroma_idc)
 {
     /* fetch pixels for estimated mv 4 macroblocks ahead
      * optimized for 64byte cache lines */
-    MpegEncContext * const s = &h->s;
     const int refn = h->ref_cache[list][scan8[0]];
-    if(refn >= 0){
-        const int mx= (h->mv_cache[list][scan8[0]][0]>>2) + 16*s->mb_x + 8;
-        const int my= (h->mv_cache[list][scan8[0]][1]>>2) + 16*s->mb_y;
+    if (refn >= 0) {
+        const int mx  = (h->mv_cache[list][scan8[0]][0] >> 2) + 16 * h->mb_x + 8;
+        const int my  = (h->mv_cache[list][scan8[0]][1] >> 2) + 16 * h->mb_y;
         uint8_t **src = h->ref_list[list][refn].f.data;
-        int off= (mx << pixel_shift) + (my + (s->mb_x&3)*4)*h->mb_linesize + (64 << pixel_shift);
-        s->dsp.prefetch(src[0]+off, s->linesize, 4);
+        int off       = (mx << pixel_shift) +
+                        (my + (h->mb_x & 3) * 4) * h->mb_linesize +
+                        (64 << pixel_shift);
+        h->vdsp.prefetch(src[0] + off, h->linesize, 4);
         if (chroma_idc == 3 /* yuv444 */) {
-            s->dsp.prefetch(src[1]+off, s->linesize, 4);
-            s->dsp.prefetch(src[2]+off, s->linesize, 4);
-        }else{
-            off= (((mx>>1)+64)<<pixel_shift) + ((my>>1) + (s->mb_x&7))*s->uvlinesize;
-            s->dsp.prefetch(src[1]+off, src[2]-src[1], 2);
-        }
-    }
-}
-
-static av_always_inline void hl_motion(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                      qpel_mc_func (*qpix_put)[16], h264_chroma_mc_func (*chroma_put),
-                      qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),
-                      h264_weight_func *weight_op, h264_biweight_func *weight_avg,
-                      int pixel_shift, int chroma_idc)
-{
-    MpegEncContext * const s = &h->s;
-    const int mb_xy= h->mb_xy;
-    const int mb_type = s->current_picture.f.mb_type[mb_xy];
-
-    assert(IS_INTER(mb_type));
-
-    if(HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))
-        await_references(h);
-    prefetch_motion(h, 0, pixel_shift, chroma_idc);
-
-    if(IS_16X16(mb_type)){
-        mc_part(h, 0, 1, 16, 0, dest_y, dest_cb, dest_cr, 0, 0,
-                qpix_put[0], chroma_put[0], qpix_avg[0], chroma_avg[0],
-                weight_op, weight_avg,
-                IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1),
-                pixel_shift, chroma_idc);
-    }else if(IS_16X8(mb_type)){
-        mc_part(h, 0, 0, 8, 8 << pixel_shift, dest_y, dest_cb, dest_cr, 0, 0,
-                qpix_put[1], chroma_put[0], qpix_avg[1], chroma_avg[0],
-                weight_op, weight_avg,
-                IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1),
-                pixel_shift, chroma_idc);
-        mc_part(h, 8, 0, 8, 8 << pixel_shift, dest_y, dest_cb, dest_cr, 0, 4,
-                qpix_put[1], chroma_put[0], qpix_avg[1], chroma_avg[0],
-                weight_op, weight_avg,
-                IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1),
-                pixel_shift, chroma_idc);
-    }else if(IS_8X16(mb_type)){
-        mc_part(h, 0, 0, 16, 8*h->mb_linesize, dest_y, dest_cb, dest_cr, 0, 0,
-                qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],
-                &weight_op[1], &weight_avg[1],
-                IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1),
-                pixel_shift, chroma_idc);
-        mc_part(h, 4, 0, 16, 8*h->mb_linesize, dest_y, dest_cb, dest_cr, 4, 0,
-                qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],
-                &weight_op[1], &weight_avg[1],
-                IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1),
-                pixel_shift, chroma_idc);
-    }else{
-        int i;
-
-        assert(IS_8X8(mb_type));
-
-        for(i=0; i<4; i++){
-            const int sub_mb_type= h->sub_mb_type[i];
-            const int n= 4*i;
-            int x_offset= (i&1)<<2;
-            int y_offset= (i&2)<<1;
-
-            if(IS_SUB_8X8(sub_mb_type)){
-                mc_part(h, n, 1, 8, 0, dest_y, dest_cb, dest_cr, x_offset, y_offset,
-                    qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],
-                    &weight_op[1], &weight_avg[1],
-                    IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),
-                    pixel_shift, chroma_idc);
-            }else if(IS_SUB_8X4(sub_mb_type)){
-                mc_part(h, n  , 0, 4, 4 << pixel_shift, dest_y, dest_cb, dest_cr, x_offset, y_offset,
-                    qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],
-                    &weight_op[1], &weight_avg[1],
-                    IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),
-                    pixel_shift, chroma_idc);
-                mc_part(h, n+2, 0, 4, 4 << pixel_shift, dest_y, dest_cb, dest_cr, x_offset, y_offset+2,
-                    qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],
-                    &weight_op[1], &weight_avg[1],
-                    IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),
-                    pixel_shift, chroma_idc);
-            }else if(IS_SUB_4X8(sub_mb_type)){
-                mc_part(h, n  , 0, 8, 4*h->mb_linesize, dest_y, dest_cb, dest_cr, x_offset, y_offset,
-                    qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],
-                    &weight_op[2], &weight_avg[2],
-                    IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),
-                    pixel_shift, chroma_idc);
-                mc_part(h, n+1, 0, 8, 4*h->mb_linesize, dest_y, dest_cb, dest_cr, x_offset+2, y_offset,
-                    qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],
-                    &weight_op[2], &weight_avg[2],
-                    IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),
-                    pixel_shift, chroma_idc);
-            }else{
-                int j;
-                assert(IS_SUB_4X4(sub_mb_type));
-                for(j=0; j<4; j++){
-                    int sub_x_offset= x_offset + 2*(j&1);
-                    int sub_y_offset= y_offset +   (j&2);
-                    mc_part(h, n+j, 1, 4, 0, dest_y, dest_cb, dest_cr, sub_x_offset, sub_y_offset,
-                        qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],
-                        &weight_op[2], &weight_avg[2],
-                        IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),
-                        pixel_shift, chroma_idc);
-                }
-            }
+            h->vdsp.prefetch(src[1] + off, h->linesize, 4);
+            h->vdsp.prefetch(src[2] + off, h->linesize, 4);
+        } else {
+            off= (((mx>>1)+64)<<pixel_shift) + ((my>>1) + (h->mb_x&7))*h->uvlinesize;
+            h->vdsp.prefetch(src[1] + off, src[2] - src[1], 2);
         }
     }
-
-    prefetch_motion(h, 1, pixel_shift, chroma_idc);
-}
-
-static av_always_inline void
-hl_motion_420(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-              qpel_mc_func (*qpix_put)[16], h264_chroma_mc_func (*chroma_put),
-              qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),
-              h264_weight_func *weight_op, h264_biweight_func *weight_avg,
-              int pixel_shift)
-{
-    hl_motion(h, dest_y, dest_cb, dest_cr, qpix_put, chroma_put,
-              qpix_avg, chroma_avg, weight_op, weight_avg, pixel_shift, 1);
 }
 
-static av_always_inline void
-hl_motion_422(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-              qpel_mc_func (*qpix_put)[16], h264_chroma_mc_func (*chroma_put),
-              qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),
-              h264_weight_func *weight_op, h264_biweight_func *weight_avg,
-              int pixel_shift)
+static void free_tables(H264Context *h, int free_rbsp)
 {
-    hl_motion(h, dest_y, dest_cb, dest_cr, qpix_put, chroma_put,
-              qpix_avg, chroma_avg, weight_op, weight_avg, pixel_shift, 2);
-}
-
-static void free_tables(H264Context *h, int free_rbsp){
     int i;
     H264Context *hx;
 
     av_freep(&h->intra4x4_pred_mode);
     av_freep(&h->chroma_pred_mode_table);
     av_freep(&h->cbp_table);
     av_freep(&h->mvd_table[0]);
     av_freep(&h->mvd_table[1]);
     av_freep(&h->direct_table);
     av_freep(&h->non_zero_count);
     av_freep(&h->slice_table_base);
-    h->slice_table= NULL;
+    h->slice_table = NULL;
     av_freep(&h->list_counts);
 
     av_freep(&h->mb2b_xy);
     av_freep(&h->mb2br_xy);
 
-    for(i = 0; i < MAX_THREADS; i++) {
+    for (i = 0; i < 3; i++)
+        av_freep(&h->visualization_buffer[i]);
+
+    if (free_rbsp) {
+        for (i = 0; i < h->picture_count && !h->avctx->internal->is_copy; i++)
+            free_picture(h, &h->DPB[i]);
+        av_freep(&h->DPB);
+        h->picture_count = 0;
+    } else if (h->DPB) {
+        for (i = 0; i < h->picture_count; i++)
+            h->DPB[i].needs_realloc = 1;
+    }
+
+    h->cur_pic_ptr = NULL;
+
+    for (i = 0; i < MAX_THREADS; i++) {
         hx = h->thread_context[i];
-        if(!hx) continue;
+        if (!hx)
+            continue;
         av_freep(&hx->top_borders[1]);
         av_freep(&hx->top_borders[0]);
-        av_freep(&hx->s.obmc_scratchpad);
-        if (free_rbsp){
+        av_freep(&hx->bipred_scratchpad);
+        av_freep(&hx->edge_emu_buffer);
+        av_freep(&hx->dc_val_base);
+        av_freep(&hx->me.scratchpad);
+        av_freep(&hx->er.mb_index2xy);
+        av_freep(&hx->er.error_status_table);
+        av_freep(&hx->er.er_temp_buffer);
+        av_freep(&hx->er.mbintra_table);
+        av_freep(&hx->er.mbskip_table);
+
+        if (free_rbsp) {
             av_freep(&hx->rbsp_buffer[1]);
             av_freep(&hx->rbsp_buffer[0]);
             hx->rbsp_buffer_size[0] = 0;
             hx->rbsp_buffer_size[1] = 0;
         }
-        if (i) av_freep(&h->thread_context[i]);
+        if (i)
+            av_freep(&h->thread_context[i]);
     }
 }
 
-static void init_dequant8_coeff_table(H264Context *h){
-    int i,j,q,x;
-    const int max_qp = 51 + 6*(h->sps.bit_depth_luma-8);
+static void init_dequant8_coeff_table(H264Context *h)
+{
+    int i, j, q, x;
+    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);
 
-    for(i=0; i<6; i++ ){
+    for (i = 0; i < 6; i++) {
         h->dequant8_coeff[i] = h->dequant8_buffer[i];
-        for(j=0; j<i; j++){
-            if(!memcmp(h->pps.scaling_matrix8[j], h->pps.scaling_matrix8[i], 64*sizeof(uint8_t))){
+        for (j = 0; j < i; j++)
+            if (!memcmp(h->pps.scaling_matrix8[j], h->pps.scaling_matrix8[i],
+                        64 * sizeof(uint8_t))) {
                 h->dequant8_coeff[i] = h->dequant8_buffer[j];
                 break;
             }
-        }
-        if(j<i)
+        if (j < i)
             continue;
 
-        for(q=0; q<max_qp+1; q++){
+        for (q = 0; q < max_qp + 1; q++) {
             int shift = div6[q];
-            int idx = rem6[q];
-            for(x=0; x<64; x++)
-                h->dequant8_coeff[i][q][(x>>3)|((x&7)<<3)] =
-                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *
-                    h->pps.scaling_matrix8[i][x]) << shift;
+            int idx   = rem6[q];
+            for (x = 0; x < 64; x++)
+                h->dequant8_coeff[i][q][(x >> 3) | ((x & 7) << 3)] =
+                    ((uint32_t)dequant8_coeff_init[idx][dequant8_coeff_init_scan[((x >> 1) & 12) | (x & 3)]] *
+                     h->pps.scaling_matrix8[i][x]) << shift;
         }
     }
 }
 
-static void init_dequant4_coeff_table(H264Context *h){
-    int i,j,q,x;
-    const int max_qp = 51 + 6*(h->sps.bit_depth_luma-8);
-    for(i=0; i<6; i++ ){
+static void init_dequant4_coeff_table(H264Context *h)
+{
+    int i, j, q, x;
+    const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);
+    for (i = 0; i < 6; i++) {
         h->dequant4_coeff[i] = h->dequant4_buffer[i];
-        for(j=0; j<i; j++){
-            if(!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i], 16*sizeof(uint8_t))){
+        for (j = 0; j < i; j++)
+            if (!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i],
+                        16 * sizeof(uint8_t))) {
                 h->dequant4_coeff[i] = h->dequant4_buffer[j];
                 break;
             }
-        }
-        if(j<i)
+        if (j < i)
             continue;
 
-        for(q=0; q<max_qp+1; q++){
+        for (q = 0; q < max_qp + 1; q++) {
             int shift = div6[q] + 2;
-            int idx = rem6[q];
-            for(x=0; x<16; x++)
-                h->dequant4_coeff[i][q][(x>>2)|((x<<2)&0xF)] =
-                    ((uint32_t)dequant4_coeff_init[idx][(x&1) + ((x>>2)&1)] *
-                    h->pps.scaling_matrix4[i][x]) << shift;
+            int idx   = rem6[q];
+            for (x = 0; x < 16; x++)
+                h->dequant4_coeff[i][q][(x >> 2) | ((x << 2) & 0xF)] =
+                    ((uint32_t)dequant4_coeff_init[idx][(x & 1) + ((x >> 2) & 1)] *
+                     h->pps.scaling_matrix4[i][x]) << shift;
         }
     }
 }
 
-static void init_dequant_tables(H264Context *h){
-    int i,x;
+static void init_dequant_tables(H264Context *h)
+{
+    int i, x;
     init_dequant4_coeff_table(h);
-    if(h->pps.transform_8x8_mode)
+    if (h->pps.transform_8x8_mode)
         init_dequant8_coeff_table(h);
-    if(h->sps.transform_bypass){
-        for(i=0; i<6; i++)
-            for(x=0; x<16; x++)
-                h->dequant4_coeff[i][0][x] = 1<<6;
-        if(h->pps.transform_8x8_mode)
-            for(i=0; i<6; i++)
-                for(x=0; x<64; x++)
-                    h->dequant8_coeff[i][0][x] = 1<<6;
+    if (h->sps.transform_bypass) {
+        for (i = 0; i < 6; i++)
+            for (x = 0; x < 16; x++)
+                h->dequant4_coeff[i][0][x] = 1 << 6;
+        if (h->pps.transform_8x8_mode)
+            for (i = 0; i < 6; i++)
+                for (x = 0; x < 64; x++)
+                    h->dequant8_coeff[i][0][x] = 1 << 6;
     }
 }
 
-
-int ff_h264_alloc_tables(H264Context *h){
-    MpegEncContext * const s = &h->s;
-    const int big_mb_num= s->mb_stride * (s->mb_height+1);
-    const int row_mb_num= 2*s->mb_stride*FFMAX(s->avctx->thread_count, 1);
-    int x,y;
-
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)
-
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)
-
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)
-
-    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));
-    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;
-
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);
-    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);
-    for(y=0; y<s->mb_height; y++){
-        for(x=0; x<s->mb_width; x++){
-            const int mb_xy= x + y*s->mb_stride;
-            const int b_xy = 4*x + 4*y*h->b_stride;
-
-            h->mb2b_xy [mb_xy]= b_xy;
-            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));
+int ff_h264_alloc_tables(H264Context *h)
+{
+    const int big_mb_num    = h->mb_stride * (h->mb_height + 1);
+    const int row_mb_num    = 2*h->mb_stride*FFMAX(h->avctx->thread_count, 1);
+    int x, y, i;
+
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->intra4x4_pred_mode,
+                      row_mb_num * 8 * sizeof(uint8_t), fail)
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->non_zero_count,
+                      big_mb_num * 48 * sizeof(uint8_t), fail)
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->slice_table_base,
+                      (big_mb_num + h->mb_stride) * sizeof(*h->slice_table_base), fail)
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->cbp_table,
+                      big_mb_num * sizeof(uint16_t), fail)
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->chroma_pred_mode_table,
+                      big_mb_num * sizeof(uint8_t), fail)
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->mvd_table[0],
+                      16 * row_mb_num * sizeof(uint8_t), fail);
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->mvd_table[1],
+                      16 * row_mb_num * sizeof(uint8_t), fail);
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->direct_table,
+                      4 * big_mb_num * sizeof(uint8_t), fail);
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->list_counts,
+                      big_mb_num * sizeof(uint8_t), fail)
+
+    memset(h->slice_table_base, -1,
+           (big_mb_num + h->mb_stride) * sizeof(*h->slice_table_base));
+    h->slice_table = h->slice_table_base + h->mb_stride * 2 + 1;
+
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->mb2b_xy,
+                      big_mb_num * sizeof(uint32_t), fail);
+    FF_ALLOCZ_OR_GOTO(h->avctx, h->mb2br_xy,
+                      big_mb_num * sizeof(uint32_t), fail);
+    for (y = 0; y < h->mb_height; y++)
+        for (x = 0; x < h->mb_width; x++) {
+            const int mb_xy = x + y * h->mb_stride;
+            const int b_xy  = 4 * x + 4 * y * h->b_stride;
+
+            h->mb2b_xy[mb_xy]  = b_xy;
+            h->mb2br_xy[mb_xy] = 8 * (FMO ? mb_xy : (mb_xy % (2 * h->mb_stride)));
         }
-    }
-
-    s->obmc_scratchpad = NULL;
 
-    if(!h->dequant4_coeff[0])
+    if (!h->dequant4_coeff[0])
         init_dequant_tables(h);
 
+    if (!h->DPB) {
+        h->picture_count = MAX_PICTURE_COUNT * FFMAX(1, h->avctx->thread_count);
+        h->DPB = av_mallocz_array(h->picture_count, sizeof(*h->DPB));
+        if (!h->DPB)
+            return AVERROR(ENOMEM);
+        for (i = 0; i < h->picture_count; i++)
+            avcodec_get_frame_defaults(&h->DPB[i].f);
+        avcodec_get_frame_defaults(&h->cur_pic.f);
+    }
+
     return 0;
+
 fail:
