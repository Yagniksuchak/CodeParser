......Next: ()
Next: (int stuff)
Next: (int[] stuffToGet)
Next: (int (*functionPtr)
Next: (int, int)
Next: (int one, int (*functionPtr)
Next: (int, int)
Next: ( int arg1, string arg2)
Next: (int stuff)
Next: (unsigned int i)
Next: (jint)
Next: (jint)
Next: (GtkWidget * widget, GdkEventFocus *event, jobject peer)
Class context: stackhelper
Checking if a constructor/destructor: ~StackHelper() {
Class context: windowproperties
Checking if a constructor/destructor: WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable)             , m_fullscreen(fullscreen)         {
Class context: uiclienttest
Checking if a constructor/destructor:       UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true)         , m_allowPermissionRequests(false)         , m_mouseTargetModifiers(0)     {
Checking if function: static void blarg() {
PATTERN 1
Checking if function: int more(int stuff) {
PATTERN 4
Checking if function: ccv_string * getStuff (int[] stuffToGet) {
PATTERN 4
Checking if function: int add2to3(int (*functionPtr)(int, int)) {
PATTERN 4
Checking if function: public static void other(int one, int (*functionPtr)(int, int) {
PATTERN 1
Checking if function: static void
 multiline(
 int arg1, string arg2
) {
PATTERN 1
Checking if function: int lotsOfSpace     (int stuff) {
PATTERN 4
Checking if function:                 .matrix = {
Checking if function: ccv_string* getStuff (int[] stuffToGet) {
PATTERN 4
Checking if function: ccv_string *getStuff (int[] stuffToGet) {
PATTERN 5
Checking if function: void NdbBlob::getBlobEvent(NdbEventImpl& be, const NdbEventImpl* e, const NdbColumnImpl* c) {
PATTERN 4
Checking if function: bool Repair_mrg_table_error_handler::handle_condition(THD *,uint sql_errno,const char*, MYSQL_ERROR::enum_warning_level level,const char*,MYSQL_ERROR ** cond_hdl) {
PATTERN 4
Checking if function: class Repair_mrg_table_error_handler : public Internal_error_handler{
Checking if function: while(1) {
Checking if function: else if(1) {
Checking if function: (_log2) += 1;  static int CeilingLog2(unsigned int i) {
PATTERN 1
Checking if function: static JSC::UString& globalExceptionString(){
PATTERN 1
Checking if function: (jint) AWT_WINDOW_LOST_FOCUS, (jint) AWT_WINDOW_DEACTIVATED,  static gboolean window_focus_in_cb (GtkWidget * widget, GdkEventFocus *event, jobject peer) {
PATTERN 1
The real line: import roboguice.util.RoboAsyncTask;
Current Name Search: 
Depths: 0:0
[]
The real line:  public class TwoFactorAuthActivity extends RoboSherlockActivity {
Current Name Search: import roboguice.util.RoboAsyncTask; 
Checking if function: import roboguice.util.RoboAsyncTask;  public class TwoFactorAuthActivity extends RoboSherlockActivity {
Class: class twofactorauthactivity extends robosherlockactivity {
Depths: 1:1
['twofactorauthactivity']
The real line: 		public xyz foo(){
Current Name Search: 
Checking if function: 		public xyz foo(){
PATTERN 1
Function:  xyz foo(){
Depths: 2:1
['twofactorauthactivity']
The real line: +		test=xyz;
End Check: 2
LINE TO PARSE FOR KEYWORD:		test=xyz;
The real line: 			 try {
End Check: 3
The real line: -                     new LoginActivity.AccountLoader(TwoFactorAuthActivity.this).call();
End Check: 3
LINE TO PARSE FOR KEYWORD:                     new loginactivity.accountloader(twofactorauthactivity.this).call();
LINE TO PARSE FOR KEYWORD:                     new loginactivity.accountloader(twofactorauthactivity.this).call();
The real line: 					 test=123;
End Check: 3
The real line:                  } catch (IOException e) {
End Check: 3
The real line: +                     Log.d(TAG, "Exception loading organizations", e);
End Check: 3
LINE TO PARSE FOR KEYWORD:                     log.d(tag, , e);
LINE TO PARSE FOR KEYWORD:                     log.d(tag, , e);
The real line:                  }
End Check: 2
The real line:                  return user;
End Check: 2
The real line: }
End Check: 1
4 : 19
Next: ()
The real line: 	public xyz foo00022(){
Current Name Search: 
Checking if function: 	public xyz foo00022(){
PATTERN 1
Function:  xyz foo00022(){
Depths: 2:1
['twofactorauthactivity']
The real line: +		test=xyz;
End Check: 2
LINE TO PARSE FOR KEYWORD:		test=xyz;
The real line: 			 try {
End Check: 3
The real line: -                     new LoginActivity.AccountLoader(TwoFactorAuthActivity.this).call();
End Check: 3
LINE TO PARSE FOR KEYWORD:                     new loginactivity.accountloader(twofactorauthactivity.this).call();
LINE TO PARSE FOR KEYWORD:                     new loginactivity.accountloader(twofactorauthactivity.this).call();
The real line: +					 test=123;
End Check: 3
LINE TO PARSE FOR KEYWORD:					 test=123;
LINE TO PARSE FOR KEYWORD:					 test=123;
The real line:                  } catch (IOException e) {
End Check: 3
The real line: +                     Log.d(TAG, "Exception loading organizations", e);
End Check: 3
LINE TO PARSE FOR KEYWORD:                     log.d(tag, , e);
LINE TO PARSE FOR KEYWORD:                     log.d(tag, , e);
The real line:                  }
End Check: 2
The real line: + test 
End Check: 2
LINE TO PARSE FOR KEYWORD: test 
The real line: -     //            return user;
End Check: 2
LINE TO PARSE FOR KEYWORD:     
The real line: }
End Check: 1
22 : 37
Next: ()
The real line: }
Current Name Search: 
Depths: 0:1
['twofactorauthactivity']
Adjusting depth.
Chunk End.
The real line: import org.eclipse.egit.github.core.User;
Current Name Search: 
Depths: 0:0
[]
The real line:  public class AccountUtils {
Current Name Search: import org.eclipse.egit.github.core.User; 
Checking if function: import org.eclipse.egit.github.core.User;  public class AccountUtils {
Class: class accountutils {
Depths: 1:1
['accountutils']
The real line:      private static Account[] getAccounts(final AccountManager manager)
Current Name Search: 
Depths: 1:1
['accountutils']
The real line:              throws OperationCanceledException, AuthenticatorException,
Current Name Search:      private static Account[] getAccounts(final AccountManager manager) 
Depths: 1:1
['accountutils']
The real line:              IOException {
Current Name Search:      private static Account[] getAccounts(final AccountManager manager)              throws OperationCanceledException, AuthenticatorException, 
Checking if function:      private static Account[] getAccounts(final AccountManager manager)              throws OperationCanceledException, AuthenticatorException,              IOException {
PATTERN 7
Function: getAccounts(final AccountManager manager)              throws OperationCanceledException, AuthenticatorException,              IOException {
Depths: 2:1
['accountutils']
The real line:          final AccountManagerFuture<Account[]> future = manager
End Check: 2
The real line: -                .getAccountsByTypeAndFeatures(ACCOUNT_TYPE, null, null,
End Check: 2
LINE TO PARSE FOR KEYWORD:                .getaccountsbytypeandfeatures(account_type, null, null,
The real line: -                        null);
End Check: 2
LINE TO PARSE FOR KEYWORD:                        null);
The real line: +                .getAccountsByTypeAndFeatures(ACCOUNT_TYPE, null, null, null);
End Check: 2
LINE TO PARSE FOR KEYWORD:                .getaccountsbytypeandfeatures(account_type, null, null, null);
The real line:          final Account[] accounts = future.getResult();
End Check: 2
The real line:          return accounts != null ? accounts : new Account[0];
End Check: 2
The real line:      }
End Check: 1
7 : 14
Next: (final AccountManager manager)
The real line:      public static Account getAccount(final AccountManager manager,
Current Name Search: 
Depths: 1:1
['accountutils']
The real line:              final Activity activity) {
Current Name Search:      public static Account getAccount(final AccountManager manager, 
Checking if function:      public static Account getAccount(final AccountManager manager,              final Activity activity) {
PATTERN 1
Function:  Account getAccount(final AccountManager manager,              final Activity activity) {
Depths: 2:1
['accountutils']
The real line:          final boolean loggable = Log.isLoggable(TAG, DEBUG);
End Check: 2
The real line:          if (loggable)
End Check: 2
The real line:              Log.d(TAG, "Getting account");
End Check: 2
The real line:          if (activity == null)
End Check: 2
The real line:              throw new IllegalArgumentException("Activity cannot be null");
End Check: 2
The real line:          Account[] accounts;
End Check: 2
The real line:          try {
End Check: 3
The real line:              while ((accounts = getAccounts(manager)).length == 0) {
End Check: 4
The real line:                  if (loggable)
End Check: 4
The real line:                      Log.d(TAG, "No GitHub accounts for activity=" + activity);
End Check: 4
The real line: -                Bundle result = manager.addAccount(ACCOUNT_TYPE, null,
End Check: 4
LINE TO PARSE FOR KEYWORD:                bundle result = manager.addaccount(account_type, null,
LINE TO PARSE FOR KEYWORD:                bundle result = manager.addaccount(account_type, null,
The real line: -                        null, null, activity, null, null).getResult();
End Check: 4
LINE TO PARSE FOR KEYWORD:                        null, null, activity, null, null).getresult();
LINE TO PARSE FOR KEYWORD:                        null, null, activity, null, null).getresult();
The real line: +                Bundle result = manager.addAccount(ACCOUNT_TYPE, null, null,
End Check: 4
LINE TO PARSE FOR KEYWORD:                bundle result = manager.addaccount(account_type, null, null,
LINE TO PARSE FOR KEYWORD:                bundle result = manager.addaccount(account_type, null, null,
The real line: +                        null, activity, null, null).getResult();
End Check: 4
LINE TO PARSE FOR KEYWORD:                        null, activity, null, null).getresult();
LINE TO PARSE FOR KEYWORD:                        null, activity, null, null).getresult();
The real line:                  if (loggable)
End Check: 4
The real line:                      Log.d(TAG,
End Check: 4
The real line:                              "Added account "
End Check: 4
The real line:                                      + result.getString(KEY_ACCOUNT_NAME));
End Check: 4
The real line:              }
End Check: 3
The real line: +        } catch (OperationCanceledException e) {
End Check: 3
LINE TO PARSE FOR KEYWORD:        } catch (operationcanceledexception e) {
LINE TO PARSE FOR KEYWORD:        } catch (operationcanceledexception e) {
The real line: +            Log.d(TAG, "Excepting retrieving account", e);
End Check: 3
LINE TO PARSE FOR KEYWORD:            log.d(tag, , e);
LINE TO PARSE FOR KEYWORD:            log.d(tag, , e);
The real line: +            activity.finish();
End Check: 3
LINE TO PARSE FOR KEYWORD:            activity.finish();
LINE TO PARSE FOR KEYWORD:            activity.finish();
The real line: +            throw new RuntimeException(e);
End Check: 3
LINE TO PARSE FOR KEYWORD:            throw new runtimeexception(e);
LINE TO PARSE FOR KEYWORD:            throw new runtimeexception(e);
The real line:          } catch (AccountsException e) {
End Check: 3
The real line:              Log.d(TAG, "Excepting retrieving account", e);
End Check: 3
The real line:              throw new RuntimeException(e);
End Check: 3
The real line:          } catch (IOException e) {
End Check: 3
The real line:              Log.d(TAG, "Excepting retrieving account", e);
End Check: 3
The real line:              throw new RuntimeException(e);
End Check: 3
The real line:          }
End Check: 2
The real line:          if (loggable)
End Check: 2
The real line:              Log.d(TAG, "Returning account " + accounts[0].name);
End Check: 2
The real line:          return accounts[0];
End Check: 2
The real line:      }
End Check: 1
17 : 57
Next: (final AccountManager manager,              final Activity activity)
The real line:  }
Current Name Search: 
Depths: 0:1
['accountutils']
Adjusting depth.
Chunk End.
The real line: import java.lang.reflect.Method;
Current Name Search: 
Depths: 0:0
[]
The real line:  class ReflectiveProperty<T, V> extends Property<T, V> {
Current Name Search: import java.lang.reflect.Method; 
Checking if function: import java.lang.reflect.Method;  class ReflectiveProperty<T, V> extends Property<T, V> {
Other type of bracket: import java.lang.reflect.Method;  class ReflectiveProperty<T, V> extends Property<T, V> {
Depths: 1:1
[]
The real line:      private static final String PREFIX_GET = "get";
Current Name Search: 
Depths: 1:1
[]
The real line:      private static final String PREFIX_IS = "is";
Current Name Search:      private static final String PREFIX_GET = ; 
Depths: 1:1
[]
The real line:      private static final String PREFIX_SET = "set";
Current Name Search:      private static final String PREFIX_IS = ; 
Depths: 1:1
[]
The real line:      private Method mSetter;
Current Name Search:      private static final String PREFIX_SET = ; 
Depths: 1:1
[]
The real line:      private Method mGetter;
Current Name Search:      private Method mSetter; 
Depths: 1:1
[]
The real line:      private Field mField;
Current Name Search:      private Method mGetter; 
Depths: 1:1
[]
The real line:      /**
Current Name Search:      private Field mField; 
Depths: 1:1
[]
The real line:       * For given property name 'name', look for getName/isName method or 'name' field.
The real line:       * Also look for setName method (optional - could be readonly). Failing method getters and
The real line:       * field results in throwing NoSuchPropertyException.
The real line:       *
The real line:       * @param propertyHolder The class on which the methods or field are found
The real line:       * @param name The name of the property, where this name is capitalized and appended to
The real line:       * "get" and "is to search for the appropriate methods. If the get/is methods are not found,
The real line:       * the constructor will search for a field with that exact name.
The real line:       */
The real line:      public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name) {
Current Name Search:      private Field mField;       
Checking if function:      private Field mField;            public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name) {
PATTERN 1
Function:  public ReflectiveProperty(Class<T> propertyHolder, Class<V> valueType, String name) {
Depths: 2:1
[]
The real line:           // TODO: cache reflection info for each new class/name pair
End Check: 2
The real line:          super(valueType, name);
End Check: 2
The real line:          char firstLetter = Character.toUpperCase(name.charAt(0));
End Check: 2
The real line:          String theRest = name.substring(1);
End Check: 2
The real line:          String capitalizedName = firstLetter + theRest;
End Check: 2
The real line:          String getterName = PREFIX_GET + capitalizedName;
End Check: 2
The real line: 		.invokeMethod(bean, "privateMethod", new Class[] { String.class }, new Object[] { "calvin" }))//test for "" '' regex
End Check: 2
The real line:          try {
End Check: 3
The real line: -            mGetter = propertyHolder.getMethod(getterName, (Class<?>[])null);
End Check: 3
LINE TO PARSE FOR KEYWORD:            mgetter = propertyholder.getmethod(gettername, (class<?>[])null);
LINE TO PARSE FOR KEYWORD:            mgetter = propertyholder.getmethod(gettername, (class<?>[])null);
The real line: +            // mGetter = propertyHolder.getMethod(getterName, (Class<?>[])null);
End Check: 3
LINE TO PARSE FOR KEYWORD:            
LINE TO PARSE FOR KEYWORD:            
The real line: +            // The native implementation uses JNI to do reflection, which allows access to private methods.
End Check: 3
LINE TO PARSE FOR KEYWORD:            
LINE TO PARSE FOR KEYWORD:            
The real line: +            mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[])null);
End Check: 3
LINE TO PARSE FOR KEYWORD:            mgetter = propertyholder.getdeclaredmethod(gettername, (class<?>[])null);
LINE TO PARSE FOR KEYWORD:            mgetter = propertyholder.getdeclaredmethod(gettername, (class<?>[])null);
The real line: +            mGetter.setAccessible(true);
End Check: 3
LINE TO PARSE FOR KEYWORD:            mgetter.setaccessible(true);
LINE TO PARSE FOR KEYWORD:            mgetter.setaccessible(true);
The real line:          } catch (NoSuchMethodException e) {
End Check: 3
The real line:              // getName() not available - try isName() instead
End Check: 3
The real line:              getterName = PREFIX_IS + capitalizedName;
End Check: 3
The real line:              try {
End Check: 4
The real line: -                mGetter = propertyHolder.getMethod(getterName, (Class<?>[])null);
End Check: 4
LINE TO PARSE FOR KEYWORD:                mgetter = propertyholder.getmethod(gettername, (class<?>[])null);
LINE TO PARSE FOR KEYWORD:                mgetter = propertyholder.getmethod(gettername, (class<?>[])null);
The real line: +                // mGetter = propertyHolder.getMethod(getterName, (Class<?>[])null);
End Check: 4
LINE TO PARSE FOR KEYWORD:                
LINE TO PARSE FOR KEYWORD:                
The real line: +                // The native implementation uses JNI to do reflection, which allows access to private methods.
End Check: 4
LINE TO PARSE FOR KEYWORD:                
LINE TO PARSE FOR KEYWORD:                
The real line: +                mGetter = propertyHolder.getDeclaredMethod(getterName, (Class<?>[])null);
End Check: 4
LINE TO PARSE FOR KEYWORD:                mgetter = propertyholder.getdeclaredmethod(gettername, (class<?>[])null);
LINE TO PARSE FOR KEYWORD:                mgetter = propertyholder.getdeclaredmethod(gettername, (class<?>[])null);
The real line: +                mGetter.setAccessible(true);
End Check: 4
LINE TO PARSE FOR KEYWORD:                mgetter.setaccessible(true);
LINE TO PARSE FOR KEYWORD:                mgetter.setaccessible(true);
The real line:              } catch (NoSuchMethodException e1) {
End Check: 4
The real line:                  // Try public field instead
End Check: 4
The real line:                  try {
End Check: 5
The real line:                      mField = propertyHolder.getField(name);
End Check: 5
The real line:                      Class fieldType = mField.getType();
End Check: 5
The real line:                      if (!typesMatch(valueType, fieldType)) {
End Check: 6
The real line:                          throw new NoSuchPropertyException("Underlying type (" + fieldType + ") " +
End Check: 6
The real line:                                  "does not match Property type (" + valueType + ")");
End Check: 6
The real line:                      }
End Check: 5
The real line:                      return;
End Check: 5
The real line:                  } catch (NoSuchFieldException e2) {
End Check: 5
The real line:                      // no way to access property - throw appropriate exception
End Check: 5
The real line:                      throw new NoSuchPropertyException("No accessor method or field found for"
End Check: 5
The real line:                              + " property with name " + name);
End Check: 5
The real line:                  }
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:          Class getterType = mGetter.getReturnType();
End Check: 2
The real line:          // Check to make sure our getter type matches our valueType
End Check: 2
The real line:          if (!typesMatch(valueType, getterType)) {
End Check: 3
The real line:              throw new NoSuchPropertyException("Underlying type (" + getterType + ") " +
End Check: 3
The real line:                      "does not match Property type (" + valueType + ")");
End Check: 3
The real line:          }
End Check: 2
The real line:          String setterName = PREFIX_SET + capitalizedName;
End Check: 2
The real line:          try {
End Check: 3
The real line: -            mSetter = propertyHolder.getMethod(setterName, getterType);
End Check: 3
LINE TO PARSE FOR KEYWORD:            msetter = propertyholder.getmethod(settername, gettertype);
LINE TO PARSE FOR KEYWORD:            msetter = propertyholder.getmethod(settername, gettertype);
The real line: +            // mSetter = propertyHolder.getMethod(setterName, getterType);
End Check: 3
LINE TO PARSE FOR KEYWORD:            
LINE TO PARSE FOR KEYWORD:            
The real line: +            // The native implementation uses JNI to do reflection, which allows access to private methods.
End Check: 3
LINE TO PARSE FOR KEYWORD:            
LINE TO PARSE FOR KEYWORD:            
The real line: +            mSetter = propertyHolder.getDeclaredMethod(setterName, getterType);
End Check: 3
LINE TO PARSE FOR KEYWORD:            msetter = propertyholder.getdeclaredmethod(settername, gettertype);
LINE TO PARSE FOR KEYWORD:            msetter = propertyholder.getdeclaredmethod(settername, gettertype);
The real line: +            mSetter.setAccessible(true);
End Check: 3
LINE TO PARSE FOR KEYWORD:            msetter.setaccessible(true);
LINE TO PARSE FOR KEYWORD:            msetter.setaccessible(true);
The real line:          } catch (NoSuchMethodException ignored) {
End Check: 3
The real line:              // Okay to not have a setter - just a readonly property
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
21 : 78
Next: (Class<T> propertyHolder, Class<V> valueType, String name)
The real line:      /**
Current Name Search: 
Depths: 1:1
[]
The real line:       * Utility method to check whether the type of the underlying field/method on the target
The real line:       * object matches the type of the Property. The extra checks for primitive types are because
The real line:       * generics will force the Property type to be a class, whereas the type of the underlying
The real line:       * method/field will probably be a primitive type instead. Accept float as matching Float,
The real line:       * etc.
The real line:       */
The real line:      private boolean typesMatch(Class<V> valueType, Class getterType) {
Current Name Search:       
Checking if function:            private boolean typesMatch(Class<V> valueType, Class getterType) {
PATTERN 1
Function:  boolean typesMatch(Class<V> valueType, Class getterType) {
Depths: 2:1
[]
The real line:          if (getterType != valueType) {
End Check: 3
The real line:              if (getterType.isPrimitive()) {
End Check: 4
The real line:                  return (getterType == float.class && valueType == Float.class) ||
End Check: 4
The real line:                          (getterType == int.class && valueType == Integer.class) ||
End Check: 4
The real line:                          (getterType == boolean.class && valueType == Boolean.class) ||
End Check: 4
The real line:                          (getterType == long.class && valueType == Long.class) ||
End Check: 4
The real line:                          (getterType == double.class && valueType == Double.class) ||
End Check: 4
The real line:                          (getterType == short.class && valueType == Short.class) ||
End Check: 4
The real line:                          (getterType == byte.class && valueType == Byte.class) ||
End Check: 4
The real line:                          (getterType == char.class && valueType == Character.class);
End Check: 4
The real line:              }
End Check: 3
The real line:              return false;
End Check: 3
The real line:          }
End Check: 2
The real line:          return true;
End Check: 2
The real line:      }
End Check: 1
87 : 102
Next: (Class<V> valueType, Class getterType)
The real line:      @Override
Current Name Search: 
Depths: 1:1
[]
The real line:      public void set(T object, V value) {
Current Name Search:      @Override 
Checking if function:      @Override      public void set(T object, V value) {
PATTERN 1
Function:  void set(T object, V value) {
Depths: 2:1
[]
The real line:          if (mSetter != null) {
End Check: 3
The real line:              try {
End Check: 4
The real line:                  mSetter.invoke(object, value);
End Check: 4
The real line:              } catch (IllegalAccessException e) {
End Check: 4
The real line:                  throw new AssertionError();
End Check: 4
The real line:              } catch (InvocationTargetException e) {
End Check: 4
The real line:                  throw new RuntimeException(e.getCause());
End Check: 4
The real line:              }
End Check: 3
The real line:          } else if (mField != null) {
End Check: 3
The real line:              try {
End Check: 4
The real line:                  mField.set(object, value);
End Check: 4
The real line:              } catch (IllegalAccessException e) {
End Check: 4
The real line:                  throw new AssertionError();
End Check: 4
The real line:              }
End Check: 3
The real line:          } else {
End Check: 3
The real line:              throw new UnsupportedOperationException("Property " + getName() +" is read-only");
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
105 : 123
Next: (T object, V value)
The real line:      @Override
Current Name Search: 
Depths: 1:1
[]
The real line:      public V get(T object) {
Current Name Search:      @Override 
Checking if function:      @Override      public V get(T object) {
PATTERN 1
Function:  V get(T object) {
Depths: 2:1
[]
The real line:          if (mGetter != null) {
End Check: 3
The real line:              try {
End Check: 4
The real line:                  return (V) mGetter.invoke(object, (Object[])null);
End Check: 4
The real line:              } catch (IllegalAccessException e) {
End Check: 4
The real line:                  throw new AssertionError();
End Check: 4
The real line:              } catch (InvocationTargetException e) {
End Check: 4
The real line:                  throw new RuntimeException(e.getCause());
End Check: 4
The real line:              }
End Check: 3
The real line:          } else if (mField != null) {
End Check: 3
The real line:              try {
End Check: 4
The real line:                  return (V) mField.get(object);
End Check: 4
The real line:              } catch (IllegalAccessException e) {
End Check: 4
The real line:                  throw new AssertionError();
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:          // Should not get here: there should always be a non-null getter or field
End Check: 2
The real line:          throw new AssertionError();
End Check: 2
The real line:      }
End Check: 1
126 : 144
Next: (T object)
The real line:      /**
Current Name Search: 
Depths: 1:1
[]
The real line:       * Returns false if there is no setter or public field underlying this Property.
The real line:       */
The real line:      @Override
Current Name Search:       
Depths: 1:1
[]
The real line:      public boolean isReadOnly() {
Current Name Search:            @Override 
Checking if function:            @Override      public boolean isReadOnly() {
PATTERN 1
Function:  boolean isReadOnly() {
Depths: 2:1
[]
The real line:          return (mSetter == null && mField == null);
End Check: 2
The real line:      }
End Check: 1
150 : 152
Next: ()
The real line:  }
Current Name Search: 
Depths: 0:1
[]
Adjusting depth.
Chunk End.
The real line:  import org.bukkit.scoreboard.Scoreboard;
Current Name Search: 
Depths: 0:0
[]
The real line:  public class CraftPlayer extends CraftHumanEntity implements Player {
Current Name Search:  import org.bukkit.scoreboard.Scoreboard; 
Checking if function:  import org.bukkit.scoreboard.Scoreboard;  public class CraftPlayer extends CraftHumanEntity implements Player {
Class: class craftplayer extends crafthumanentity implements player {
Depths: 1:1
['craftplayer']
The real line:      public void setHandle(final EntityPlayer entity) {
Current Name Search: 
Checking if function:      public void setHandle(final EntityPlayer entity) {
PATTERN 1
Function:  void setHandle(final EntityPlayer entity) {
Depths: 2:1
['craftplayer']
The real line:          super.setHandle(entity);
End Check: 2
The real line: +		 return "CraftPlayer'{'" + "name=" + getName() + '}'+"{'}'";
End Check: 2
LINE TO PARSE FOR KEYWORD:		 return  +  + getname() + +;
The real line: - {
End Check: 2
LINE TO PARSE FOR KEYWORD: {
The real line: 	++y;
End Check: 2
The real line: 	--z;
End Check: 2
The real line:      }
End Check: 1
5 : 13
Next: (final EntityPlayer entity)
The real line:  		          return "CraftPlayer'{'" + "name=" + getName() + '}'+"{'}'";
Current Name Search: 
Depths: 1:1
['craftplayer']
The real line:  }
Current Name Search:  		          return  +  + getName() + +; 
Depths: 0:1
['craftplayer']
Adjusting depth.
Chunk End.
The real line: +	private void copy(InputStream is, OutputStream os, int max) throws IOException{
Current Name Search: 
Checking if function: 	private void copy(InputStream is, OutputStream os, int max) throws IOException{
PATTERN 7
Function: void copy(InputStream is, OutputStream os, int max) throws IOException{
LINE TO PARSE FOR KEYWORD:	private void copy(inputstream is, outputstream os, int max) throws ioexception{
Depths: 1:0
[]
The real line: -	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	/*
The real line: -	private void copy(InputStream is, OutputStream os, String encoding, int max) throws IOException{
End Check: 1
LINE TO PARSE FOR KEYWORD:	private void copy(inputstream is, outputstream os, string encoding, int max) throws ioexception{
The real line: -		if("gzip".equalsIgnoreCase(encoding)){
End Check: 1
LINE TO PARSE FOR KEYWORD:		if(.equalsignorecase(encoding)){
The real line: -			is = new GZIPInputStream(is);
End Check: 1
LINE TO PARSE FOR KEYWORD:			is = new gzipinputstream(is);
The real line: -		}
End Check: 1
LINE TO PARSE FOR KEYWORD:		}
The real line:  		Object o = null;
End Check: 1
The real line:  		if(progress != null){
End Check: 2
The real line:  			o = progress.get();
End Check: 2
The real line:  		}
End Check: 1
The real line:  		Progress p = null;
End Check: 1
The real line:  		if(o != null){
End Check: 2
The real line:  			p = new Progress(o); 
End Check: 2
The real line:  		}
End Check: 1
The real line:  		AQUtility.copy(is, os, max, p);
End Check: 1
The real line:  	}
End Check: 0
2 : 26
Next: (InputStream is, OutputStream os, int max)
The real line: -	*/
Current Name Search: 
LINE TO PARSE FOR KEYWORD:	*/
Depths: 0:0
[]
Chunk End.
The real line: import org.androidannotations.validation.rest.RestValidator;
Current Name Search: 
Depths: 0:0
[]
The real line:  public class AndroidAnnotationProcessor extends AbstractProcessor {
Current Name Search: import org.androidannotations.validation.rest.RestValidator; 
Checking if function: import org.androidannotations.validation.rest.RestValidator;  public class AndroidAnnotationProcessor extends AbstractProcessor {
Class: class androidannotationprocessor extends abstractprocessor {
Depths: 1:1
['androidannotationprocessor']
The real line:  	public synchronized void init(ProcessingEnvironment processingEnv) {
Current Name Search: 
Checking if function:  	public synchronized void init(ProcessingEnvironment processingEnv) {
PATTERN 1
Function:  void init(ProcessingEnvironment processingEnv) {
Depths: 2:1
['androidannotationprocessor']
The real line:  		try {
End Check: 3
The real line:  			loadPropertyFile();
End Check: 3
The real line:  			loadApiPropertyFile();
End Check: 3
The real line:  		} catch (Exception e) {
End Check: 3
The real line:  			messager.printMessage(Diagnostic.Kind.ERROR, "AndroidAnnotations processing failed: " + e.getMessage());
End Check: 3
The real line: -			throw new RuntimeException("AndroidAnnotations processing failed", e);
End Check: 3
LINE TO PARSE FOR KEYWORD:			throw new runtimeexception(, e);
LINE TO PARSE FOR KEYWORD:			throw new runtimeexception(, e);
The real line:  		}
End Check: 2
The real line:  	}
End Check: 1
5 : 15
Next: (ProcessingEnvironment processingEnv)
The real line: }
Current Name Search: 
Depths: 0:1
['androidannotationprocessor']
Adjusting depth.
Chunk End.
The real line: import roboguice.util.RoboAsyncTask;
Current Name Search: 
Depths: 0:0
[]
The real line: public class MyGistsFragment extends GistsFragment {
Current Name Search: import roboguice.util.RoboAsyncTask; 
Checking if function: import roboguice.util.RoboAsyncTask; public class MyGistsFragment extends GistsFragment {
Class: class mygistsfragment extends gistsfragment {
Depths: 1:1
['mygistsfragment']
The real line:      @Override
Current Name Search: 
Depths: 1:1
['mygistsfragment']
The real line:      public Loader<List<Gist>> onCreateLoader(int i, Bundle bundle) {
Current Name Search:      @Override 
Checking if function:      @Override      public Loader<List<Gist>> onCreateLoader(int i, Bundle bundle) {
PATTERN 2
Function:  Loader<List<Gist>> onCreateLoader(int i, Bundle bundle) {
Depths: 2:1
['mygistsfragment']
The real line: -        return new AsyncLoader<List<Gist>>(getActivity()) {
End Check: 2
LINE TO PARSE FOR KEYWORD:        return new asyncloader<list<gist>>(getactivity()) {
The real line: +        return new ThrowableLoader<List<Gist>>(getActivity(), listItems) {
End Check: 3
LINE TO PARSE FOR KEYWORD:        return new throwableloader<list<gist>>(getactivity(), listitems) {
The real line:              @Override
End Check: 3
The real line: -            public List<Gist> loadInBackground() {
End Check: 3
LINE TO PARSE FOR KEYWORD:            public list<gist> loadinbackground() {
The real line: -                try {
End Check: 3
LINE TO PARSE FOR KEYWORD:                try {
The real line: +            public List<Gist> loadData() throws IOException {
End Check: 4
LINE TO PARSE FOR KEYWORD:            public list<gist> loaddata() throws ioexception {
The real line:                  List<Gist> userGists = service.getGists(service.getClient().getUser());
End Check: 4
The real line:                  List<Gist> gists = new ArrayList<Gist>(userGists.size());
End Check: 4
The real line:                  for (Gist gist : userGists)
End Check: 4
The real line:                      gists.add(store.addGist(gist));
End Check: 4
The real line:                  Collections.sort(gists, MyGistsFragment.this);
End Check: 4
The real line:                  return gists;
End Check: 4
The real line: -                } catch (IOException e) {
End Check: 4
LINE TO PARSE FOR KEYWORD:                } catch (ioexception e) {
The real line: -                    showError(e, string.error_gists_load);
End Check: 4
LINE TO PARSE FOR KEYWORD:                    showerror(e, string.error_gists_load);
The real line: -                    return Collections.emptyList();
End Check: 4
LINE TO PARSE FOR KEYWORD:                    return collections.emptylist();
The real line: -                }
End Check: 4
LINE TO PARSE FOR KEYWORD:                }
The real line:              }
End Check: 3
The real line:          };
End Check: 2
The real line:      }
End Check: 1
5 : 24
Next: (int i, Bundle bundle)
The real line:  }
Current Name Search: 
Depths: 0:1
['mygistsfragment']
Adjusting depth.
Chunk End.
The real line:  @Override
Current Name Search: 
Depths: 0:0
[]
The real line:      public Bundle getAuthToken(AccountAuthenticatorResponse response,
Current Name Search:  @Override 
Depths: 0:0
[]
The real line:              Account account, String authTokenType, Bundle options)
Current Name Search:  @Override      public Bundle getAuthToken(AccountAuthenticatorResponse response, 
Depths: 0:0
[]
The real line:              throws NetworkErrorException {
Current Name Search:  @Override      public Bundle getAuthToken(AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options) 
Checking if function:  @Override      public Bundle getAuthToken(AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options)              throws NetworkErrorException {
PATTERN 7
Function: Bundle getAuthToken(AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options)              t.hrows NetworkErrorException {
Depths: 1:0
[]
The real line:         try {
End Check: 2
The real line:             // Clear password from account
End Check: 2
The real line:              am.clearPassword(account);
End Check: 2
The real line:              return bundle;
End Check: 2
The real line: +        } catch (IOException e) {
End Check: 2
LINE TO PARSE FOR KEYWORD:        } catch (ioexception e) {
LINE TO PARSE FOR KEYWORD:        } catch (ioexception e) {
The real line: -        } catch (Exception e) {
End Check: 2
LINE TO PARSE FOR KEYWORD:        } catch (exception e) {
LINE TO PARSE FOR KEYWORD:        } catch (exception e) {
The real line:              Log.e(TAG, e.getMessage());
End Check: 2
The real line: +            throw new NetworkErrorException(e);
End Check: 2
LINE TO PARSE FOR KEYWORD:            throw new networkerrorexception(e);
LINE TO PARSE FOR KEYWORD:            throw new networkerrorexception(e);
The real line:          }
End Check: 1
The real line: -        return bundle;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return bundle;
The real line:      }
End Check: 0
4 : 16
Next: (AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options)
Chunk End.
The real line:   @Override
Current Name Search: 
Depths: 0:0
[]
The real line:      public Bundle getAuthToken(AccountAuthenticatorResponse response,
Current Name Search:   @Override 
Depths: 0:0
[]
The real line:              Account account, String authTokenType, Bundle options)
Current Name Search:   @Override      public Bundle getAuthToken(AccountAuthenticatorResponse response, 
Depths: 0:0
[]
The real line:              throws NetworkErrorException {
Current Name Search:   @Override      public Bundle getAuthToken(AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options) 
Checking if function:   @Override      public Bundle getAuthToken(AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options)              throws NetworkErrorException {
PATTERN 7
Function: Bundle getAuthToken(AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options)              throws NetworkErrorException {
Depths: 1:0
[]
The real line:         try {
End Check: 2
The real line:             // Clear password from account
End Check: 2
The real line:              am.clearPassword(account);
End Check: 2
The real line:              return bundle;
End Check: 2
The real line:           } 
End Check: 1
The real line: -         catch (Exception e) {
End Check: 1
LINE TO PARSE FOR KEYWORD:         catch (exception e) {
The real line: +        catch (IOException e) {
End Check: 2
LINE TO PARSE FOR KEYWORD:        catch (ioexception e) {
LINE TO PARSE FOR KEYWORD:        catch (ioexception e) {
The real line:              Log.e(TAG, e.getMessage());
End Check: 2
The real line: +            throw new NetworkErrorException(e);
End Check: 2
LINE TO PARSE FOR KEYWORD:            throw new networkerrorexception(e);
LINE TO PARSE FOR KEYWORD:            throw new networkerrorexception(e);
The real line:          }
End Check: 1
The real line: -        return bundle;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return bundle;
The real line:      }
End Check: 0
4 : 17
Next: (AccountAuthenticatorResponse response,              Account account, String authTokenType, Bundle options)
Chunk End.
The real line: +#include <assert.h> 
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#include <> 
Depths: 0:0
[]
The real line: +
Current Name Search: #include <assert.h>  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: #include <assert.h>   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +int
Current Name Search: #include <assert.h>    
LINE TO PARSE FOR KEYWORD:int
Depths: 0:0
[]
The real line: +NdbBlob::getBlobEventName(char* bename, Ndb* anNdb, const char* eventName, const char* columnName)
Current Name Search: #include <assert.h>    int 
LINE TO PARSE FOR KEYWORD:ndbblob::getblobeventname(char* bename, ndb* anndb, const char* eventname, const char* columnname)
Depths: 0:0
[]
The real line: +{
Current Name Search: #include <assert.h>    int NdbBlob::getBlobEventName(char* bename, Ndb* anNdb, const char* eventName, const char* columnName) 
Checking if function: #include <assert.h>    int NdbBlob::getBlobEventName(char* bename, Ndb* anNdb, const char* eventName, const char* columnName) {
PATTERN 1
Function:  int NdbBlob::getBlobEventName(char* bename, Ndb* anNdb,char* eventName,char* columnName) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  NdbEventImpl* e = anNdb->theDictionary->m_impl.getEvent(eventName);
End Check: 1
LINE TO PARSE FOR KEYWORD:  ndbeventimpl* e = anndb->thedictionary->m_impl.getevent(eventname);
The real line: +  if (e == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (e == null)
The real line: +    return -1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return -1;
The real line: +  NdbColumnImpl* c = e->m_tableImpl->getColumn(columnName);
End Check: 1
LINE TO PARSE FOR KEYWORD:  ndbcolumnimpl* c = e->m_tableimpl->getcolumn(columnname);
The real line: +  if (c == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (c == null)
The real line: +    return -1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return -1;
The real line: +  getBlobEventName(bename, e, c);
End Check: 1
LINE TO PARSE FOR KEYWORD:  getblobeventname(bename, e, c);
The real line: +  return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return 0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
6 : 15
Next: (char* bename, Ndb* anNdb,char* eventName,char* columnName)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +NdbBlob::getBlobEventName(char* bename, const NdbEventImpl* e, const NdbColumnImpl* c)
Current Name Search:  void 
LINE TO PARSE FOR KEYWORD:ndbblob::getblobeventname(char* bename, const ndbeventimpl* e, const ndbcolumnimpl* c)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void NdbBlob::getBlobEventName(char* bename, const NdbEventImpl* e, const NdbColumnImpl* c) 
Checking if function:  void NdbBlob::getBlobEventName(char* bename, const NdbEventImpl* e, const NdbColumnImpl* c) {
PATTERN 4
Function: void NdbBlob::getBlobEventName(char* bename,NdbEventImpl* e,NdbColumnImpl* c) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  // XXX events should have object id
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  snprintf(bename, MAX_TAB_NAME_SIZE, "NDB$BLOBEVENT_%s_%d", e->m_name.c_str(), (int)c->m_column_no);
End Check: 1
LINE TO PARSE FOR KEYWORD:  snprintf(bename, max_tab_name_size, , e->m_name.c_str(), (int)c->m_column_no);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
19 : 22
Next: (char* bename,NdbEventImpl* e,NdbColumnImpl* c)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +NdbBlob::getBlobEvent(NdbEventImpl& be, const NdbEventImpl* e, const NdbColumnImpl* c)
Current Name Search:  void 
LINE TO PARSE FOR KEYWORD:ndbblob::getblobevent(ndbeventimpl& be, const ndbeventimpl* e, const ndbcolumnimpl* c)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void NdbBlob::getBlobEvent(NdbEventImpl& be, const NdbEventImpl* e, const NdbColumnImpl* c) 
Checking if function:  void NdbBlob::getBlobEvent(NdbEventImpl& be, const NdbEventImpl* e, const NdbColumnImpl* c) {
PATTERN 4
Function: void NdbBlob::getBlobEvent(NdbEventImpl& be,NdbEventImpl* e,NdbColumnImpl* c) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  DBUG_ENTER("NdbBlob::getBlobEvent");
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_enter();
The real line: +  // blob table
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  assert(c->m_blobTable != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:  assert(c->m_blobtable != null);
The real line: +  const NdbTableImpl& bt = *c->m_blobTab.le;
End Check: 1
LINE TO PARSE FOR KEYWORD:  const ndbtableimpl& bt = *c->m_blobtable;
The real line: +  // blob event name
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  char bename[NdbBlobImpl::BlobTableNameSize];
End Check: 1
LINE TO PARSE FOR KEYWORD:  char bename[ndbblobimpl::blobtablenamesize];
The real line: +  getBlobEventName(bename, e, c);
End Check: 1
LINE TO PARSE FOR KEYWORD:  getblobeventname(bename, e, c);
The real line: +  be.setName(bename);
End Check: 1
LINE TO PARSE FOR KEYWORD:  be.setname(bename);
The real line: +  be.setTable(bt);
End Check: 1
LINE TO PARSE FOR KEYWORD:  be.settable(bt);
The real line: +  // simple assigments
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  be.mi_type = e->mi_type;
End Check: 1
LINE TO PARSE FOR KEYWORD:  be.mi_type = e->mi_type;
The real line: +  be.m_dur = e->m_dur;
End Check: 1
LINE TO PARSE FOR KEYWORD:  be.m_dur = e->m_dur;
The real line: +  be.m_mergeEvents = e->m_mergeEvents;
End Check: 1
LINE TO PARSE FOR KEYWORD:  be.m_mergeevents = e->m_mergeevents;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  assert(MockAssert == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:  assert(mockassert == 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  // report unchanged data
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  // not really needed now since UPD is DEL o INS and we subscribe to all
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  be.setReport(NdbDictionary::Event::ER_ALL);
End Check: 1
LINE TO PARSE FOR KEYWORD:  be.setreport(ndbdictionary::event::er_all);
The real line: +  // columns PK - DIST - PART - DATA
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  { const NdbColumnImpl* bc = bt.getColumn((Uint32)0);
End Check: 2
LINE TO PARSE FOR KEYWORD:  { const ndbcolumnimpl* bc = bt.getcolumn((uint32)0);
The real line: +    be.addColumn(*bc);
End Check: 2
LINE TO PARSE FOR KEYWORD:    be.addcolumn(*bc);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  { const NdbColumnImpl* bc = bt.getColumn((Uint32)1);
End Check: 2
LINE TO PARSE FOR KEYWORD:  { const ndbcolumnimpl* bc = bt.getcolumn((uint32)1);
The real line: +    be.addColumn(*bc);
End Check: 2
LINE TO PARSE FOR KEYWORD:    be.addcolumn(*bc);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  { const NdbColumnImpl* bc = bt.getColumn((Uint32)2);
End Check: 2
LINE TO PARSE FOR KEYWORD:  { const ndbcolumnimpl* bc = bt.getcolumn((uint32)2);
The real line: +    be.addColumn(*bc);
End Check: 2
LINE TO PARSE FOR KEYWORD:    be.addcolumn(*bc);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  { const NdbColumnImpl* bc = bt.getColumn((Uint32)3);
End Check: 2
LINE TO PARSE FOR KEYWORD:  { const ndbcolumnimpl* bc = bt.getcolumn((uint32)3);
The real line: +    be.addColumn(*bc);
End Check: 2
LINE TO PARSE FOR KEYWORD:    be.addcolumn(*bc);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  DBUG_VOID_RETURN;
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_void_return;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
26 : 60
Next: (NdbEventImpl& be,NdbEventImpl* e,NdbColumnImpl* c)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
Chunk End.
The real line: +/*
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * Copyright (C) 1998-2000 Netscape Communications Corporation.
The real line: + * Copyright (C) 2003-6 Apple Computer
The real line: + *
The real line: + * Other contributors:
The real line: + *   Nick Blievers <nickb@adacel.com.au>
The real line: + *   Jeff Hostetler <jeff@nerdone.com>
The real line: + *   Tom Rini <trini@kernel.crashing.org>
The real line: + *   Raffaele Sena <raff@netwinder.org>
The real line: + *
The real line: + * This library is free software; you can redistribute it and/or
The real line: + * modify it under the terms of the GNU Lesser General Public
The real line: + * License as published by the Free Software Foundation; either
The real line: + * version 2.1 of the License, or (at your option) any later version.
The real line: + *
The real line: + * This library is distributed in the hope that it will be useful,
The real line: + * but WITHOUT ANY WARRANTY; without even the implied warranty of
The real line: + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
The real line: + * Lesser General Public License for more details.
The real line: + *
The real line: + * You should have received a copy of the GNU Lesser General Public
The real line: + * License along with this library; if not, write to the Free Software
The real line: + * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
The real line: + *
The real line: + * Alternatively, the contents of this file may be used under the terms
The real line: + * of either the Mozilla Public License Version 1.1, found at
The real line: + * http://www.mozilla.org/MPL/ (the "MPL") or the GNU General Public
The real line: + * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
The real line: + * (the "GPL"), in which case the provisions of the MPL or the GPL are
The real line: + * applicable instead of those above.  If you wish to allow use of your
The real line: + * version of this file only under the terms of one of those two
The real line: + * licenses (the MPL or the GPL) and not to allow others to use your
The real line: + * version of this file under the LGPL, indicate your decision by
The real line: + * deletingthe provisions above and replace them with the notice and
The real line: + * other provisions required by the MPL or the GPL, as the case may be.
The real line: + * If you do not delete the provisions above, a recipient may use your
The real line: + * version of this file under any of the LGPL, the MPL or the GPL.
The real line: + */
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * Lifetime-based fast allocation, inspired by much prior art, including
The real line: + * "Fast Allocation and Deallocation of Memory Based on Object Lifetimes"
The real line: + * David R. Hanson, Software -- Practice and Experience, Vol. 20(1).
The real line: + */
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "config.h"
Current Name Search:     
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "Arena.h"
Current Name Search:     #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:     #include  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include <algorithm>
Current Name Search:     #include  #include   
LINE TO PARSE FOR KEYWORD:#include <algorithm>
Depths: 0:0
[]
The real line: +#include <stdlib.h>
Current Name Search:     #include  #include   #include <algorithm> 
LINE TO PARSE FOR KEYWORD:#include <stdlib.h>
Depths: 0:0
[]
The real line: +#include <string.h>
Current Name Search:     #include  #include   #include <algorithm> #include <stdlib.h> 
LINE TO PARSE FOR KEYWORD:#include <string.h>
Depths: 0:0
[]
The real line: +#include <wtf/Assertions.h>
Current Name Search:     #include  #include   #include <algorithm> #include <stdlib.h> #include <string.h> 
LINE TO PARSE FOR KEYWORD:#include <>
Depths: 0:0
[]
The real line: +#include <wtf/FastMalloc.h>
Current Name Search:     #include  #include   #include <algorithm> #include <stdlib.h> #include <string.h> #include <wtf/Assertions.h> 
LINE TO PARSE FOR KEYWORD:#include <wtf/fastmalloc.h>
Depths: 0:0
[]
The real line: +
Current Name Search:     #include  #include   #include <algorithm> #include <stdlib.h> #include <string.h> #include <wtf/Assertions.h> #include <wtf/FastMalloc.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +using namespace std;
Current Name Search:     #include  #include   #include <algorithm> #include <stdlib.h> #include <string.h> #include <wtf/Assertions.h> #include <wtf/FastMalloc.h>  
LINE TO PARSE FOR KEYWORD:using namespace std;
Depths: 0:0
[]
The real line: +
Current Name Search: using namespace std; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +namespace WebCore {
Current Name Search: using namespace std;  
Checking if function: using namespace std;  namespace WebCore {
Namespace:using namespace std;  namespace WebCore {
LINE TO PARSE FOR KEYWORD:namespace webcore {
Depths: 1:1
[]
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +//#define DEBUG_ARENA_MALLOC
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#ifdef DEBUG_ARENA_MALLOC
Current Name Search:   
LINE TO PARSE FOR KEYWORD:#ifdef debug_arena_malloc
Depths: 1:1
[]
The real line: +static int i = 0;
Current Name Search:   #ifdef DEBUG_ARENA_MALLOC 
LINE TO PARSE FOR KEYWORD:static int i = 0;
Depths: 1:1
[]
The real line: +#endif
Current Name Search: static int i = 0; 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: static int i = 0; #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#define FREELIST_MAX 30
Current Name Search: static int i = 0; #endif  
LINE TO PARSE FOR KEYWORD:#define freelist_max 30
Depths: 1:1
[]
The real line: +static Arena *arena_freelist;
Current Name Search: static int i = 0; #endif  #define FREELIST_MAX 30 
LINE TO PARSE FOR KEYWORD:static arena *arena_freelist;
Depths: 1:1
[]
The real line: +static int freelist_count = 0;
Current Name Search: static Arena *arena_freelist; 
LINE TO PARSE FOR KEYWORD:static int freelist_count = 0;
Depths: 1:1
[]
The real line: +
Current Name Search: static int freelist_count = 0; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#define ARENA_DEFAULT_ALIGN  sizeof(double)
Current Name Search: static int freelist_count = 0;  
LINE TO PARSE FOR KEYWORD:#define arena_default_align  sizeof(double)
Depths: 1:1
[]
The real line: +#define BIT(n)                          ((unsigned int)1 << (n))
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) 
LINE TO PARSE FOR KEYWORD:#define bit(n)                          ((unsigned int)1 << (n))
Depths: 1:1
[]
The real line: +#define BITMASK(n)                      (BIT(n) - 1)
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) 
LINE TO PARSE FOR KEYWORD:#define bitmask(n)                      (bit(n) - 1)
Depths: 1:1
[]
The real line: +#define CEILING_LOG2(_log2,_n)   \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) 
LINE TO PARSE FOR KEYWORD:#define ceiling_log2(_log2,_n)   \
Depths: 1:1
[]
The real line: +      unsigned int j_ = (unsigned int)(_n);   \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \ 
LINE TO PARSE FOR KEYWORD:      unsigned int j_ = (unsigned int)(_n);   \
Depths: 1:1
[]
The real line: +      (_log2) = 0;                    \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \ 
LINE TO PARSE FOR KEYWORD:      (_log2) = 0;                    \
Depths: 1:1
[]
The real line: +      if ((j_) & ((j_)-1))            \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \ 
LINE TO PARSE FOR KEYWORD:      if ((j_) & ((j_)-1))            \
Depths: 1:1
[]
The real line: +      (_log2) += 1;               \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \ 
LINE TO PARSE FOR KEYWORD:      (_log2) += 1;               \
Depths: 1:1
[]
The real line: +      if ((j_) >> 16)                 \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \ 
LINE TO PARSE FOR KEYWORD:      if ((j_) >> 16)                 \
Depths: 1:1
[]
The real line: +      (_log2) += 16, (j_) >>= 16; \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \ 
LINE TO PARSE FOR KEYWORD:      (_log2) += 16, (j_) >>= 16; \
Depths: 1:1
[]
The real line: +      if ((j_) >> 8)                  \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \ 
LINE TO PARSE FOR KEYWORD:      if ((j_) >> 8)                  \
Depths: 1:1
[]
The real line: +      (_log2) += 8, (j_) >>= 8;   \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \ 
LINE TO PARSE FOR KEYWORD:      (_log2) += 8, (j_) >>= 8;   \
Depths: 1:1
[]
The real line: +      if ((j_) >> 4)                  \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \       (_log2) += 8, (j_) >>= 8;   \ 
LINE TO PARSE FOR KEYWORD:      if ((j_) >> 4)                  \
Depths: 1:1
[]
The real line: +      (_log2) += 4, (j_) >>= 4;   \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \       (_log2) += 8, (j_) >>= 8;   \       if ((j_) >> 4)                  \ 
LINE TO PARSE FOR KEYWORD:      (_log2) += 4, (j_) >>= 4;   \
Depths: 1:1
[]
The real line: +      if ((j_) >> 2)                  \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \       (_log2) += 8, (j_) >>= 8;   \       if ((j_) >> 4)                  \       (_log2) += 4, (j_) >>= 4;   \ 
LINE TO PARSE FOR KEYWORD:      if ((j_) >> 2)                  \
Depths: 1:1
[]
The real line: +      (_log2) += 2, (j_) >>= 2;   \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \       (_log2) += 8, (j_) >>= 8;   \       if ((j_) >> 4)                  \       (_log2) += 4, (j_) >>= 4;   \       if ((j_) >> 2)                  \ 
LINE TO PARSE FOR KEYWORD:      (_log2) += 2, (j_) >>= 2;   \
Depths: 1:1
[]
The real line: +      if ((j_) >> 1)                  \
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \       (_log2) += 8, (j_) >>= 8;   \       if ((j_) >> 4)                  \       (_log2) += 4, (j_) >>= 4;   \       if ((j_) >> 2)                  \       (_log2) += 2, (j_) >>= 2;   \ 
LINE TO PARSE FOR KEYWORD:      if ((j_) >> 1)                  \
Depths: 1:1
[]
The real line: +      (_log2) += 1;
Current Name Search: static int freelist_count = 0;  #define ARENA_DEFAULT_ALIGN  sizeof(double) #define BIT(n)                          ((unsigned int)1 << (n)) #define BITMASK(n)                      (BIT(n) - 1) #define CEILING_LOG2(_log2,_n)   \       unsigned int j_ = (unsigned int)(_n);   \       (_log2) = 0;                    \       if ((j_) & ((j_)-1))            \       (_log2) += 1;               \       if ((j_) >> 16)                 \       (_log2) += 16, (j_) >>= 16; \       if ((j_) >> 8)                  \       (_log2) += 8, (j_) >>= 8;   \       if ((j_) >> 4)                  \       (_log2) += 4, (j_) >>= 4;   \       if ((j_) >> 2)                  \       (_log2) += 2, (j_) >>= 2;   \       if ((j_) >> 1)                  \ 
LINE TO PARSE FOR KEYWORD:      (_log2) += 1;
Depths: 1:1
[]
The real line: +
Current Name Search:       (_log2) += 1; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +static int CeilingLog2(unsigned int i) {
Current Name Search:       (_log2) += 1;  
Checking if function:       (_log2) += 1;  static int CeilingLog2(unsigned int i) {
PATTERN 1
Function:  int CeilingLog2(unsigned int i) {
LINE TO PARSE FOR KEYWORD:static int ceilinglog2(unsigned int i) {
Depths: 2:1
[]
The real line: +    int log2;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int log2;
The real line: +    CEILING_LOG2(log2,i);
End Check: 2
LINE TO PARSE FOR KEYWORD:    ceiling_log2(log2,i);
The real line: +    return log2;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return log2;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
87 : 91
Next: (unsigned int i)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +void InitArenaPool(ArenaPool* pool, const char*, unsigned size, unsigned align)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void initarenapool(arenapool* pool, const char*, unsigned size, unsigned align)
Depths: 1:1
[]
The real line: +{
Current Name Search:  void InitArenaPool(ArenaPool* pool, const char*, unsigned size, unsigned align) 
Checking if function:  void InitArenaPool(ArenaPool* pool, const char*, unsigned size, unsigned align) {
PATTERN 4
Function: void InitArenaPool(ArenaPool* pool,char*, unsigned size, unsigned align) {
LINE TO PARSE FOR KEYWORD:{
Depths: 2:1
[]
The real line: +     if (align == 0)
End Check: 2
LINE TO PARSE FOR KEYWORD:     if (align == 0)
The real line: +         align = ARENA_DEFAULT_ALIGN;
End Check: 2
LINE TO PARSE FOR KEYWORD:         align = arena_default_align;
The real line: +     pool->mask = BITMASK(CeilingLog2(align));
End Check: 2
LINE TO PARSE FOR KEYWORD:     pool->mask = bitmask(ceilinglog2(align));
The real line: +     pool->first.next = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:     pool->first.next = null;
The real line: +     pool->first.base = pool->first.avail = pool->first.limit =
End Check: 2
LINE TO PARSE FOR KEYWORD:     pool->first.base = pool->first.avail = pool->first.limit =
The real line: +         (uword)ARENA_ALIGN(&pool->first + 1);
End Check: 2
LINE TO PARSE FOR KEYWORD:         (uword)arena_align(&pool->first + 1);
The real line: +     pool->current = &pool->first;
End Check: 2
LINE TO PARSE FOR KEYWORD:     pool->current = &pool->first;
The real line: +     pool->arenasize = size;                                  
End Check: 2
LINE TO PARSE FOR KEYWORD:     pool->arenasize = size;                                  
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
94 : 103
Next: (ArenaPool* pool,char*, unsigned size, unsigned align)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + ** ArenaAllocate() -- allocate space from an arena pool
The real line: + ** 
The real line: + ** Description: ArenaAllocate() allocates space from an arena
The real line: + ** pool. 
The real line: + **
The real line: + ** First try to satisfy the request from arenas starting at
The real line: + ** pool->current.
The real line: + **
The real line: + ** If there is not enough space in the arena pool->current, try
The real line: + ** to claim an arena, on a first fit basis, from the global
The real line: + ** freelist (arena_freelist).
The real line: + ** 
The real line: + ** If no arena in arena_freelist is suitable, then try to
The real line: + ** allocate a new arena from the heap.
The real line: + **
The real line: + ** Returns: pointer to allocated space or NULL
The real line: + ** 
The real line: + */
The real line: +void* ArenaAllocate(ArenaPool *pool, unsigned int nb)
Current Name Search:    
LINE TO PARSE FOR KEYWORD:void* arenaallocate(arenapool *pool, unsigned int nb)
Depths: 1:1
[]
The real line: +{
Current Name Search:    void* ArenaAllocate(ArenaPool *pool, unsigned int nb) 
Checking if function:    void* ArenaAllocate(ArenaPool *pool, unsigned int nb) {
PATTERN 4
Function: void* ArenaAllocate(ArenaPool *pool, unsigned int nb) {
LINE TO PARSE FOR KEYWORD:{
Depths: 2:1
[]
The real line: +    Arena *a;   
End Check: 2
LINE TO PARSE FOR KEYWORD:    arena *a;   
The real line: +    char *rp;     /* returned pointer */
End Check: 2
LINE TO PARSE FOR KEYWORD:    char *rp;     
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    ASSERT((nb & pool->mask) == 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert((nb & pool->mask) == 0);
The real line: +    
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    nb = (uword)ARENA_ALIGN(nb); /* force alignment */
End Check: 2
LINE TO PARSE FOR KEYWORD:    nb = (uword)arena_align(nb); 
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    /* attempt to allocate from arenas at pool->current */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +        a = pool->current;
End Check: 3
LINE TO PARSE FOR KEYWORD:        a = pool->current;
The real line: +        do {
End Check: 4
LINE TO PARSE FOR KEYWORD:        do {
The real line: +            if ( a->avail +nb <= a->limit )  {
End Check: 5
LINE TO PARSE FOR KEYWORD:            if ( a->avail +nb <= a->limit )  {
The real line: +                pool->current = a;
End Check: 5
LINE TO PARSE FOR KEYWORD:                pool->current = a;
The real line: +                rp = (char *)a->avail;
End Check: 5
LINE TO PARSE FOR KEYWORD:                rp = (char *)a->avail;
The real line: +                a->avail += nb;
End Check: 5
LINE TO PARSE FOR KEYWORD:                a->avail += nb;
The real line: +                return rp;
End Check: 5
LINE TO PARSE FOR KEYWORD:                return rp;
The real line: +            }
End Check: 4
LINE TO PARSE FOR KEYWORD:            }
The real line: +        } while( NULL != (a = a->next) );
End Check: 3
LINE TO PARSE FOR KEYWORD:        } while( null != (a = a->next) );
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    /* attempt to allocate from arena_freelist */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +        Arena *p = NULL; /* previous pointer, for unlinking from freelist */
End Check: 3
LINE TO PARSE FOR KEYWORD:        arena *p = null; 
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +        for ( a = arena_freelist; a != NULL ; p = a, a = a->next ) {
End Check: 4
LINE TO PARSE FOR KEYWORD:        for ( a = arena_freelist; a != null ; p = a, a = a->next ) {
The real line: +            if ( a->base +nb <= a->limit )  {
End Check: 5
LINE TO PARSE FOR KEYWORD:            if ( a->base +nb <= a->limit )  {
The real line: +                if ( p == NULL )
End Check: 5
LINE TO PARSE FOR KEYWORD:                if ( p == null )
The real line: +                    arena_freelist = a->next;
End Check: 5
LINE TO PARSE FOR KEYWORD:                    arena_freelist = a->next;
The real line: +                else
End Check: 5
LINE TO PARSE FOR KEYWORD:                else
The real line: +                    p->next = a->next;
End Check: 5
LINE TO PARSE FOR KEYWORD:                    p->next = a->next;
The real line: +                a->avail = a->base;
End Check: 5
LINE TO PARSE FOR KEYWORD:                a->avail = a->base;
The real line: +                rp = (char *)a->avail;
End Check: 5
LINE TO PARSE FOR KEYWORD:                rp = (char *)a->avail;
The real line: +                a->avail += nb;
End Check: 5
LINE TO PARSE FOR KEYWORD:                a->avail += nb;
The real line: +                /* the newly allocated arena is linked after pool->current 
End Check: 5
LINE TO PARSE FOR KEYWORD:                
The real line: +                 *  and becomes pool->current */
The real line: +                a->next = pool->current->next;
End Check: 5
LINE TO PARSE FOR KEYWORD:                a->next = pool->current->next;
The real line: +                pool->current->next = a;
End Check: 5
LINE TO PARSE FOR KEYWORD:                pool->current->next = a;
The real line: +                pool->current = a;
End Check: 5
LINE TO PARSE FOR KEYWORD:                pool->current = a;
The real line: +                if ( 0 == pool->first.next )
End Check: 5
LINE TO PARSE FOR KEYWORD:                if ( 0 == pool->first.next )
The real line: +                    pool->first.next = a;
End Check: 5
LINE TO PARSE FOR KEYWORD:                    pool->first.next = a;
The real line: +                freelist_count--;
End Check: 5
LINE TO PARSE FOR KEYWORD:                freelist_count--;
The real line: +                return(rp);
End Check: 5
LINE TO PARSE FOR KEYWORD:                return(rp);
The real line: +            }
End Check: 4
LINE TO PARSE FOR KEYWORD:            }
The real line: +        }
End Check: 3
LINE TO PARSE FOR KEYWORD:        }
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    /* attempt to allocate from the heap */ 
End Check: 2
LINE TO PARSE FOR KEYWORD:     
The real line: +    {  
End Check: 3
LINE TO PARSE FOR KEYWORD:    {  
The real line: +        unsigned int sz = max(pool->arenasize, nb);
End Check: 3
LINE TO PARSE FOR KEYWORD:        unsigned int sz = max(pool->arenasize, nb);
The real line: +        sz += sizeof *a + pool->mask;  /* header and alignment slop */
End Check: 3
LINE TO PARSE FOR KEYWORD:        sz += sizeof *a + pool->mask;  
The real line: +#ifdef DEBUG_ARENA_MALLOC
End Check: 3
LINE TO PARSE FOR KEYWORD:#ifdef debug_arena_malloc
The real line: +        i++;
End Check: 3
LINE TO PARSE FOR KEYWORD:        i++;
The real line: +        printf("Malloc: %d\n", i);
End Check: 3
LINE TO PARSE FOR KEYWORD:        printf(, i);
The real line: +#endif
End Check: 3
LINE TO PARSE FOR KEYWORD:#endif
The real line: +        a = (Arena*)fastMalloc(sz);
End Check: 3
LINE TO PARSE FOR KEYWORD:        a = (arena*)fastmalloc(sz);
The real line: +        // fastMalloc will abort() if it fails, so we are guaranteed that a is not 0.
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        a->limit = (uword)a + sz;
End Check: 3
LINE TO PARSE FOR KEYWORD:        a->limit = (uword)a + sz;
The real line: +        a->base = a->avail = (uword)ARENA_ALIGN(a + 1);
End Check: 3
LINE TO PARSE FOR KEYWORD:        a->base = a->avail = (uword)arena_align(a + 1);
The real line: +        rp = (char *)a->avail;
End Check: 3
LINE TO PARSE FOR KEYWORD:        rp = (char *)a->avail;
The real line: +        a->avail += nb;
End Check: 3
LINE TO PARSE FOR KEYWORD:        a->avail += nb;
The real line: +        /* the newly allocated arena is linked after pool->current 
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        *  and becomes pool->current */
The real line: +        a->next = pool->current->next;
End Check: 3
LINE TO PARSE FOR KEYWORD:        a->next = pool->current->next;
The real line: +        pool->current->next = a;
End Check: 3
LINE TO PARSE FOR KEYWORD:        pool->current->next = a;
The real line: +        pool->current = a;
End Check: 3
LINE TO PARSE FOR KEYWORD:        pool->current = a;
The real line: +        if ( !pool->first.next )
End Check: 3
LINE TO PARSE FOR KEYWORD:        if ( !pool->first.next )
The real line: +            pool->first.next = a;
End Check: 3
LINE TO PARSE FOR KEYWORD:            pool->first.next = a;
The real line: +        return(rp);
End Check: 3
LINE TO PARSE FOR KEYWORD:        return(rp);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +} /* --- end ArenaAllocate() --- */
End Check: 1
LINE TO PARSE FOR KEYWORD:} 
126 : 196
Next: (ArenaPool *pool, unsigned int nb)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/*
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * Free tail arenas linked after head, which may not be the true list head.
The real line: + * Reset pool->current to point to head in case it pointed at a tail arena.
The real line: + */
The real line: +static void FreeArenaList(ArenaPool *pool, Arena *head, bool reallyFree)
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static void freearenalist(arenapool *pool, arena *head, bool reallyfree)
Depths: 1:1
[]
The real line: +{
Current Name Search:   static void FreeArenaList(ArenaPool *pool, Arena *head, bool reallyFree) 
Checking if function:   static void FreeArenaList(ArenaPool *pool, Arena *head, bool reallyFree) {
PATTERN 1
Function:  void FreeArenaList(ArenaPool *pool, Arena *head, bool reallyFree) {
LINE TO PARSE FOR KEYWORD:{
Depths: 2:1
[]
The real line: +    Arena **ap, *a;
End Check: 2
LINE TO PARSE FOR KEYWORD:    arena **ap, *a;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    ap = &head->next;
End Check: 2
LINE TO PARSE FOR KEYWORD:    ap = &head->next;
The real line: +    a = *ap;
End Check: 2
LINE TO PARSE FOR KEYWORD:    a = *ap;
The real line: +    if (!a)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (!a)
The real line: +        return;
End Check: 2
LINE TO PARSE FOR KEYWORD:        return;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef DEBUG
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef debug
The real line: +    do {
End Check: 3
LINE TO PARSE FOR KEYWORD:    do {
The real line: +        ASSERT(a->base <= a->avail && a->avail <= a->limit);
End Check: 3
LINE TO PARSE FOR KEYWORD:        assert(a->base <= a->avail && a->avail <= a->limit);
The real line: +        a->avail = a->base;
End Check: 3
LINE TO PARSE FOR KEYWORD:        a->avail = a->base;
The real line: +        CLEAR_UNUSED(a);
End Check: 3
LINE TO PARSE FOR KEYWORD:        clear_unused(a);
The real line: +    } while ((a = a->next) != 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:    } while ((a = a->next) != 0);
The real line: +    a = *ap;
End Check: 2
LINE TO PARSE FOR KEYWORD:    a = *ap;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    if (freelist_count >= FREELIST_MAX)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (freelist_count >= freelist_max)
The real line: +        reallyFree = true;
End Check: 2
LINE TO PARSE FOR KEYWORD:        reallyfree = true;
The real line: +        
End Check: 2
LINE TO PARSE FOR KEYWORD:        
The real line: +    if (reallyFree) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (reallyfree) {
The real line: +        do {
End Check: 4
LINE TO PARSE FOR KEYWORD:        do {
The real line: +            *ap = a->next;
End Check: 4
LINE TO PARSE FOR KEYWORD:            *ap = a->next;
The real line: +            CLEAR_ARENA(a);
End Check: 4
LINE TO PARSE FOR KEYWORD:            clear_arena(a);
The real line: +#ifdef DEBUG_ARENA_MALLOC
End Check: 4
LINE TO PARSE FOR KEYWORD:#ifdef debug_arena_malloc
The real line: +            if (a) {
End Check: 5
LINE TO PARSE FOR KEYWORD:            if (a) {
The real line: +                i--;
End Check: 5
LINE TO PARSE FOR KEYWORD:                i--;
The real line: +                printf("Free: %d\n", i);
End Check: 5
LINE TO PARSE FOR KEYWORD:                printf(, i);
The real line: +            }
End Check: 4
LINE TO PARSE FOR KEYWORD:            }
The real line: +#endif
End Check: 4
LINE TO PARSE FOR KEYWORD:#endif
The real line: +            fastFree(a); a = 0;
End Check: 4
LINE TO PARSE FOR KEYWORD:            fastfree(a); a = 0;
The real line: +        } while ((a = *ap) != 0);
End Check: 3
LINE TO PARSE FOR KEYWORD:        } while ((a = *ap) != 0);
The real line: +    } else {
End Check: 3
LINE TO PARSE FOR KEYWORD:    } else {
The real line: +        /* Insert the whole arena chain at the front of the freelist. */
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        do {
End Check: 4
LINE TO PARSE FOR KEYWORD:        do {
The real line: +            ap = &(*ap)->next;
End Check: 4
LINE TO PARSE FOR KEYWORD:            ap = &(*ap)->next;
The real line: +            freelist_count++;
End Check: 4
LINE TO PARSE FOR KEYWORD:            freelist_count++;
The real line: +        } while (*ap);
End Check: 3
LINE TO PARSE FOR KEYWORD:        } while (*ap);
The real line: +        *ap = arena_freelist;
End Check: 3
LINE TO PARSE FOR KEYWORD:        *ap = arena_freelist.;
The real line: +        arena_freelist = a;
End Check: 3
LINE TO PARSE FOR KEYWORD:        arena_freelist = a;
The real line: +        head->next = 0;
End Check: 3
LINE TO PARSE FOR KEYWORD:        head->next = 0;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    pool->current = head;
End Check: 2
LINE TO PARSE FOR KEYWORD:    pool->current = head;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
203 : 246
Next: (ArenaPool *pool, Arena *head, bool reallyFree)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +void FreeArenaPool(ArenaPool *pool)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void freearenapool(arenapool *pool)
Depths: 1:1
[]
The real line: +{
Current Name Search:  void FreeArenaPool(ArenaPool *pool) 
Checking if function:  void FreeArenaPool(ArenaPool *pool) {
PATTERN 4
Function: void FreeArenaPool(ArenaPool *pool) {
LINE TO PARSE FOR KEYWORD:{
Depths: 2:1
[]
The real line: +    FreeArenaList(pool, &pool->first, false);
End Check: 2
LINE TO PARSE FOR KEYWORD:    freearenalist(pool, &pool->first, false);
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
249 : 251
Next: (ArenaPool *pool)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +void FinishArenaPool(ArenaPool *pool)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void finisharenapool(arenapool *pool)
Depths: 1:1
[]
The real line: +{
Current Name Search:  void FinishArenaPool(ArenaPool *pool) 
Checking if function:  void FinishArenaPool(ArenaPool *pool) {
PATTERN 4
Function: void FinishArenaPool(ArenaPool *pool) {
LINE TO PARSE FOR KEYWORD:{
Depths: 2:1
[]
The real line: +    FreeArenaList(pool, &pool->first, true);
End Check: 2
LINE TO PARSE FOR KEYWORD:    freearenalist(pool, &pool->first, true);
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
254 : 256
Next: (ArenaPool *pool)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +}
Current Name Search:  
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
Chunk End.
The real line: -///////////////////////////////////////////////////////////////////////////////
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/////////////////////////////////////////////////////////////////////////////
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// Extension argument API
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void countArgs(const char *format, unsigned &min, unsigned &max) {
Current Name Search:     
Checking if function:     static void countArgs(const char *format, unsigned &min, unsigned &max) {
PATTERN 1
Function:  void countArgs(const char *format, unsigned &min, unsigned &max) {
LINE TO PARSE FOR KEYWORD:static void countargs(const char *format, unsigned &min, unsigned &max) {
Depths: 1:0
[]
The real line: +  bool required = true;
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool required = true;
The real line: +  min = max = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  min = max = 0;
The real line: +  while (auto c = *(format++)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  while (auto c = *(format++)) {
The real line: +    if (c == '|') {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (c == ) {
The real line: +      required = false;
End Check: 3
LINE TO PARSE FOR KEYWORD:      required = false;
The real line: +      continue;
End Check: 3
LINE TO PARSE FOR KEYWORD:      continue;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    if (c == '!') {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (c == ) {
The real line: +      continue;
End Check: 3
LINE TO PARSE FOR KEYWORD:      continue;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    if (required) min++;
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (required) min++;
The real line: +    max++;
End Check: 2
LINE TO PARSE FOR KEYWORD:    max++;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
5 : 19
Next: (const char *format, unsigned &min, unsigned &max)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static const char *argTypeName(DataType dt) {
Current Name Search:  
Checking if function:  static const char *argTypeName(DataType dt) {
PATTERN 5
Function: staticchar *argTypeName(DataType dt) {
LINE TO PARSE FOR KEYWORD:static const char *argtypename(datatype dt) {
Depths: 1:0
[]
The real line: +  switch (dt) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  switch (dt) {
The real line: +    case KindOfNull: return "null";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofnull: return ;
The real line: +    case KindOfBoolean: return "boolean";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofboolean: return ;
The real line: +    case KindOfInt64: return "integer";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofint64: return ;
The real line: +    case KindOfDouble: return "double";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofdouble: return ;
The real line: +    case KindOfString:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofstring:
The real line: +    case KindOfStaticString: return "string";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofstaticstring: return ;
The real line: +    case KindOfArray: return "array";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofarray: return ;
The real line: +    case KindOfObject: return "object";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofobject: return ;
The real line: +    case KindOfResource: return "resource";
End Check: 2
LINE TO PARSE FOR KEYWORD:    case kindofresource: return ;
The real line: +    default: return "unknown";
End Check: 2
LINE TO PARSE FOR KEYWORD:    default: return ;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  not_reached();
End Check: 1
LINE TO PARSE FOR KEYWORD:  not_reached();
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
21 : 35
Next: (DataType dt)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +template <DataType DType, class T>
Current Name Search:  
LINE TO PARSE FOR KEYWORD:template <datatype dtype, class t>
Depths: 0:0
[]
The real line: +void parseArgValue(TypedValue *tv,
Current Name Search:  template <DataType DType, class T> 
LINE TO PARSE FOR KEYWORD:void parseargvalue(typedvalue *tv,
Depths: 0:0
[]
The real line: +                   va_list va, bool check_null) {
Current Name Search:  template <DataType DType, class T> void parseArgValue(TypedValue *tv, 
Checking if function:  template <DataType DType, class T> void parseArgValue(TypedValue *tv,                    va_list va, bool check_null) {
PATTERN T5
Function: template <DataType DType, class T> void parseArgValue(TypedValue *tv,                    va_list va, bool check_null) {
LINE TO PARSE FOR KEYWORD:                   va_list va, bool check_null) {
Depths: 1:0
[]
The real line: +  T* pval = va_arg(va, T*);
End Check: 1
LINE TO PARSE FOR KEYWORD:  t* pval = va_arg(va, t*);
The real line: +  if (check_null) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  if (check_null) {
The real line: +     *va_arg(va, bool*) = (tv->m_type == KindOfNull);
End Check: 2
LINE TO PARSE FOR KEYWORD:     *va_arg(va, bool*) = (tv->m_type == kindofnull);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  if (!tvCoerceParamInPlace(tv, DType)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  if (!tvcoerceparaminplace(tv, dtype)) {
The real line: +    throw_invalid_argument("Expected %s, got %s",
End Check: 2
LINE TO PARSE FOR KEYWORD:    throw_invalid_argument(,
The real line: +                           argTypeName(DType),
End Check: 2
LINE TO PARSE FOR KEYWORD:                           argtypename(dtype),
The real line: +                           argTypeName(tv->m_type));
End Check: 2
LINE TO PARSE FOR KEYWORD:                           argtypename(tv->m_type));
The real line: +    tvCastInPlace(tv, DType);
End Check: 2
LINE TO PARSE FOR KEYWORD:    tvcastinplace(tv, dtype);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  *pval = unpack_tv<DType>(tv);
End Check: 1
LINE TO PARSE FOR KEYWORD:  *pval = unpack_tv<dtype>(tv);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
39 : 51
Next: (TypedValue *tv,                    va_list va, bool check_null)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +template <DataType DType, class T>
Current Name Search:  
LINE TO PARSE FOR KEYWORD:template <datatype dtype, class t>
Depths: 0:0
[]
The real line: +bool parseArgPointer(TypedValue *tv,
Current Name Search:  template <DataType DType, class T> 
LINE TO PARSE FOR KEYWORD:bool parseargpointer(typedvalue *tv,
Depths: 0:0
[]
The real line: +                     va_list va, bool check_null) {
Current Name Search:  template <DataType DType, class T> bool parseArgPointer(TypedValue *tv, 
Checking if function:  template <DataType DType, class T> bool parseArgPointer(TypedValue *tv,                      va_list va, bool check_null) {
PATTERN T5
Function: template <DataType DType, class T> bool parseArgPointer(TypedValue *tv,                      va_list va, bool check_null) {
LINE TO PARSE FOR KEYWORD:                     va_list va, bool check_null) {
Depths: 1:0
[]
The real line: +  T* pval = va_arg(va, T*);
End Check: 1
LINE TO PARSE FOR KEYWORD:  t* pval = va_arg(va, t*);
The real line: +  if (check_null && (tv->m_type == KindOfNull)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  if (check_null && (tv->m_type == kindofnull)) {
The real line: +    *pval = nullptr;
End Check: 2
LINE TO PARSE FOR KEYWORD:    *pval = nullptr;
The real line: +    return true;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return true;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  if (tv->m_type != DType) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  if (tv->m_type != dtype) {
The real line: +    throw_invalid_argument("Expected %s, got %s",
End Check: 2
LINE TO PARSE FOR KEYWORD:    throw_invalid_argument(,
The real line: +                           argTypeName(DType),
End Check: 2
LINE TO PARSE FOR KEYWORD:                           argtypename(dtype),
The real line: +                           argTypeName(tv->m_type));
End Check: 2
LINE TO PARSE FOR KEYWORD:                           argtypename(tv->m_type));
The real line: +    return false;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return false;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  *pval = unpack_tv<DType>(tv);
End Check: 1
LINE TO PARSE FOR KEYWORD:  *pval = unpack_tv<dtype>(tv);
The real line: +  return true;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return true;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
55 : 69
Next: (TypedValue *tv,                      va_list va, bool check_null)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#define PARSE_ARG_VAL(fmt, dt) \
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#define parse_arg_val(fmt, dt) \
Depths: 0:0
[]
The real line: +  case fmt: \
Current Name Search:  #define PARSE_ARG_VAL(fmt, dt) \ 
LINE TO PARSE FOR KEYWORD:  case fmt: \
Depths: 0:0
[]
The real line: +    parseArgValue<dt, typename DataTypeCPPType<dt>::type> \
Current Name Search:  #define PARSE_ARG_VAL(fmt, dt) \   case fmt: \ 
LINE TO PARSE FOR KEYWORD:    parseargvalue<dt, typename datatypecpptype<dt>::type> \
Depths: 0:0
[]
The real line: +      (tv, va, check_null); break;
Current Name Search:  #define PARSE_ARG_VAL(fmt, dt) \   case fmt: \     parseArgValue<dt, typename DataTypeCPPType<dt>::type> \ 
LINE TO PARSE FOR KEYWORD:      (tv, va, check_null); break;
Depths: 0:0
[]
The real line: +
Current Name Search:       (tv, va, check_null); break; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#define PARSE_ARG_PTR(fmt, dt) \
Current Name Search:       (tv, va, check_null); break;  
LINE TO PARSE FOR KEYWORD:#define parse_arg_ptr(fmt, dt) \
Depths: 0:0
[]
The real line: +  case fmt: \
Current Name Search:       (tv, va, check_null); break;  #define PARSE_ARG_PTR(fmt, dt) \ 
LINE TO PARSE FOR KEYWORD:  case fmt: \
Depths: 0:0
[]
The real line: +    if (!parseArgPointer<dt, typename DataTypeCPPType<dt>::type> \
Current Name Search:       (tv, va, check_null); break;  #define PARSE_ARG_PTR(fmt, dt) \   case fmt: \ 
LINE TO PARSE FOR KEYWORD:    if (!parseargpointer<dt, typename datatypecpptype<dt>::type> \
Depths: 0:0
[]
The real line: +      (tv, va, check_null)) { return false; } break;
Current Name Search:       (tv, va, check_null); break;  #define PARSE_ARG_PTR(fmt, dt) \   case fmt: \     if (!parseArgPointer<dt, typename DataTypeCPPType<dt>::type> \ 
Checking if function:       (tv, va, check_null)) {
Other type of bracket:       (tv, va, check_null)) {
LINE TO PARSE FOR KEYWORD:      (tv, va, check_null)) { return false; } break;
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool parseArgs(ActRec *ar, const char *format, ...) {
Current Name Search:  
Checking if function:  bool parseArgs(ActRec *ar, const char *format, ...) {
PATTERN 4
Function: bool parseArgs(ActRec *ar,char *format, ) {
LINE TO PARSE FOR KEYWORD:bool parseargs(actrec *ar, const char *format, ...) {
Depths: 1:0
[]
The real line: +  unsigned min, max, count = ar->numArgs();
End Check: 1
LINE TO PARSE FOR KEYWORD:  unsigned min, max, count = ar->numargs();
The real line: +  countArgs(format, min, max);
End Check: 1
LINE TO PARSE FOR KEYWORD:  countargs(format, min, max);
The real line: +  if (count < min) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  if (count < min) {
The real line: +    throw_wrong_arguments_nr(ar->func()->name()->data(), count, min, max);
End Check: 2
LINE TO PARSE FOR KEYWORD:    throw_wrong_arguments_nr(ar->func()->name()->data(), count, min, max);
The real line: +    return false;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return false;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  unsigned arg = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  unsigned arg = 0;
The real line: +  va_list va;
End Check: 1
LINE TO PARSE FOR KEYWORD:  va_list va;
The real line: +  va_start(va, format);
End Check: 1
LINE TO PARSE FOR KEYWORD:  va_start(va, format);
The real line: +  SCOPE_EXIT { va_end(va); };
End Check: 1
LINE TO PARSE FOR KEYWORD:  scope_exit { va_end(va); };
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  while (auto c = *(format++)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  while (auto c = *(format++)) {
The real line: +    if (c == '|' || c == '!') {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (c ==  || c == ) {
The real line: +      continue;
End Check: 3
LINE TO PARSE FOR KEYWORD:      continue;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    if (arg >= count) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (arg >= count) {
The real line: +      // Still have format specs, but no more args passed
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      // throw_wrong_arguments_nr check should guarantee
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      // that we're already past min args
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      assert(arg >= min);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(arg >= min);
The real line: +      break;
End Check: 3
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    bool check_null = (format[1] == '!');
End Check: 2
LINE TO PARSE FOR KEYWORD:    bool check_null = (format[1] == );
The real line: +    TypedValue *tv = getArg(ar, arg++);
End Check: 2
LINE TO PARSE FOR KEYWORD:    typedvalue *tv = getarg(ar, arg++);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    switch (c) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    switch (c) {
The real line: +      PARSE_ARG_VAL('b', KindOfBoolean);
End Check: 3
LINE TO PARSE FOR KEYWORD:      parse_arg_val(, kindofboolean);
The real line: +      PARSE_ARG_VAL('l', KindOfInt64);
End Check: 3
LINE TO PARSE FOR KEYWORD:      parse_arg_val(, kindofint64);
The real line: +      PARSE_ARG_VAL('d', KindOfDouble);
End Check: 3
LINE TO PARSE FOR KEYWORD:      parse_arg_val(, kindofdouble);
The real line: +      PARSE_ARG_PTR('r', KindOfResource);
End Check: 3
LINE TO PARSE FOR KEYWORD:      parse_arg_ptr(, kindofresource);
The real line: +      PARSE_ARG_PTR('a', KindOfArray);
End Check: 3
LINE TO PARSE FOR KEYWORD:      parse_arg_ptr(, kindofarray);
The real line: +      PARSE_ARG_PTR('o', KindOfObject);
End Check: 3
LINE TO PARSE FOR KEYWORD:      parse_arg_ptr(, kindofobject);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      case 's': { // KindOfString
End Check: 4
LINE TO PARSE FOR KEYWORD:      case : { 
The real line: +        StringData **psval = va_arg(va, StringData**);
End Check: 4
LINE TO PARSE FOR KEYWORD:        stringdata **psval = va_arg(va, stringdata**);
The real line: +        if (check_null && (tv->m_type == KindOfNull)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (check_null && (tv->m_type == kindofnull)) {
The real line: +          *psval = nullptr;
End Check: 5
LINE TO PARSE FOR KEYWORD:          *psval = nullptr;
The real line: +          break;
End Check: 5
LINE TO PARSE FOR KEYWORD:          break;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        if (!tvCoerceParamInPlace(tv, KindOfString)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (!tvcoerceparaminplace(tv, kindofstring)) {
The real line: +          throw_invalid_argument("Expected string, got %s",
End Check: 5
LINE TO PARSE FOR KEYWORD:          throw_invalid_argument(,
The real line: +                                 argTypeName(tv->m_type));
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 argtypename(tv->m_type));
The real line: +          return false;
End Check: 5
LINE TO PARSE FOR KEYWORD:          return false;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        *psval = unpack_tv<KindOfString>(tv);
End Check: 4
LINE TO PARSE FOR KEYWORD:        *psval = unpack_tv<kindofstring>(tv);
The real line: +        break;
End Check: 4
LINE TO PARSE FOR KEYWORD:        break;
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      case 'O': { // KindOfObject (specific type)
End Check: 4
LINE TO PARSE FOR KEYWORD:      case : { 
The real line: +        ObjectData **objval = va_arg(va, ObjectData**);
End Check: 4
LINE TO PARSE FOR KEYWORD:        objectdata **objval = va_arg(va, objectdata**);
The real line: +        Class *expClass = va_arg(va, Class*);
End Check: 4
LINE TO PARSE FOR KEYWORD:        class *expclass = va_arg(va, class*);
The real line: +        if (check_null && (tv->m_type == KindOfNull)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (check_null && (tv->m_type == kindofnull)) {
The real line: +          *objval = nullptr;
End Check: 5
LINE TO PARSE FOR KEYWORD:          *objval = nullptr;
The real line: +          break;
End Check: 5
LINE TO PARSE FOR KEYWORD:          break;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        if (tv->m_type != KindOfObject) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (tv->m_type != kindofobject) {
The real line: +          throw_invalid_argument("Expected %s, got %s",
End Check: 5
LINE TO PARSE FOR KEYWORD:          throw_invalid_argument(,
The real line: +                                 expClass->name()->data(),
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 expclass->name()->data(),
The real line: +                                 argTypeName(tv->m_type));
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 argtypename(tv->m_type));
The real line: +          return false;
End Check: 5
LINE TO PARSE FOR KEYWORD:          return false;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        auto odata = unpack_tv<KindOfObject>(tv);
End Check: 4
LINE TO PARSE FOR KEYWORD:        auto odata = unpack_tv<kindofobject>(tv);
The real line: +        Class *cls = odata->getVMClass();
End Check: 4
LINE TO PARSE FOR KEYWORD:        class *cls = odata->getvmclass();
The real line: +        if ((cls != expClass) && !cls->classof(expClass)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if ((cls != expclass) && !cls->classof(expclass)) {
The real line: +          throw_invalid_argument("Expected %s, got %s",
End Check: 5
LINE TO PARSE FOR KEYWORD:          throw_invalid_argument(,
The real line: +                                 expClass->name()->data(),
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 expclass->name()->data(),
The real line: +                                 cls->name()->data());
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 cls->name()->data());
The real line: +          return false;
End Check: 5
LINE TO PARSE FOR KEYWORD:          return false;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        *objval = odata;
End Check: 4
LINE TO PARSE FOR KEYWORD:        *objval = odata;
The real line: +        break;
End Check: 4
LINE TO PARSE FOR KEYWORD:        break;
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      case 'C': { // KindOfClass
End Check: 4
LINE TO PARSE FOR KEYWORD:      case : { 
The real line: +        Class **clsval = va_arg(va, Class**);
End Check: 4
LINE TO PARSE FOR KEYWORD:        class **clsval = va_arg(va, class**);
The real line: +        if (check_null && (tv->m_type == KindOfNull)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (check_null && (tv->m_type == kindofnull)) {
The real line: +          *clsval = nullptr;
End Check: 5
LINE TO PARSE FOR KEYWORD:          *clsval = nullptr;
The real line: +          break;
End Check: 5
LINE TO PARSE FOR KEYWORD:          break;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        if (!tvCoerceParamInPlace(tv, KindOfString)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (!tvcoerceparaminplace(tv, kindofstring)) {
The real line: +          throw_invalid_argument("Expected string class name, got %s",
End Check: 5
LINE TO PARSE FOR KEYWORD:          throw_invalid_argument(,
The real line: +                                 argTypeName(tv->m_type));
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 argtypename(tv->m_type));
The real line: +          return false;
End Check: 5
LINE TO PARSE FOR KEYWORD:          return false;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        auto cls = Unit::loadClass(tv->m_data.pstr);
End Check: 4
LINE TO PARSE FOR KEYWORD:        auto cls = unit::loadclass(tv->m_data.pstr);
The real line: +        if (!cls) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (!cls) {
The real line: +          throw_invalid_argument("Unknown class %s",
End Check: 5
LINE TO PARSE FOR KEYWORD:          throw_invalid_argument(,
The real line: +                                 tv->m_data.pstr->data());
End Check: 5
LINE TO PARSE FOR KEYWORD:                                 tv->m_data.pstr->data());
The real line: +          return false;
End Check: 5
LINE TO PARSE FOR KEYWORD:          return false;
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +        *clsval = cls;
End Check: 4
LINE TO PARSE FOR KEYWORD:        *clsval = cls;
The real line: +        break;
End Check: 4
LINE. TO PARSE FOR KEYWORD:        break;
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      case 'A': // KindOfArray || KindOfObject
End Check: 3
LINE TO PARSE FOR KEYWORD:      case : 
The real line: +        if ((tv->m_type != KindOfArray) &&
End Check: 3
LINE TO PARSE FOR KEYWORD:        if ((tv->m_type != kindofarray) &&
The real line: +            (tv->m_type != KindOfObject)) {
End Check: 4
LINE TO PARSE FOR KEYWORD:            (tv->m_type != kindofobject)) {
The real line: +          throw_invalid_argument("Expected array or object, got %s",
End Check: 4
LINE TO PARSE FOR KEYWORD:          throw_invalid_argument(,
The real line: +                                 argTypeName(tv->m_type));
End Check: 4
LINE TO PARSE FOR KEYWORD:                                 argtypename(tv->m_type));
The real line: +          return false;
End Check: 4
LINE TO PARSE FOR KEYWORD:          return false;
The real line: +        }
End Check: 3
LINE TO PARSE FOR KEYWORD:        }
The real line: +        /* fallthrough */
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +      case 'v': // KindOfAny (Variant)
End Check: 3
LINE TO PARSE FOR KEYWORD:      case : 
The real line: +        *va_arg(va, Variant*) = tv ? tvAsVariant(tv) : uninit_null();
End Check: 3
LINE TO PARSE FOR KEYWORD:        *va_arg(va, variant*) = tv ? tvasvariant(tv) : uninit_null();
The real line: +        break;
End Check: 3
LINE TO PARSE FOR KEYWORD:        break;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      case 'V': // KindOfAny (TypedValue*)
End Check: 3
LINE TO PARSE FOR KEYWORD:      case : 
The real line: +        *va_arg(va, TypedValue**) = tv;
End Check: 3
LINE TO PARSE FOR KEYWORD:        *va_arg(va, typedvalue**) = tv;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      default:
End Check: 3
LINE TO PARSE FOR KEYWORD:      default:
The real line: +        not_reached();
End Check: 3
LINE TO PARSE FOR KEYWORD:        not_reached();
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return true;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return true;
The real line:  }
End Check: 0
81 : 199
Next: (ActRec *ar,char *format, )
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/////////////////////////////////////////////////////////////////////////////
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +} // namespace HPHP
Current Name Search:   
LINE TO PARSE FOR KEYWORD:} 
Depths: -1:0
[]
Adjusting depth.
Chunk End.
===========================================
countArgs
5
19
15
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
*argTypeName
21
35
15
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
parseArgValue
39
51
13
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
parseArgPointer
55
69
15
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
parseArgs
81
199
118
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 1, 'ut_a Dels': 0}
===========================================
The real line: +/*
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * charset=UTF-8
The real line: + * vim600: encoding=utf-8
The real line: + */
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * "streamable kanji code filter and converter"
The real line: + *
The real line: + * Copyright (c) 1998,1999,2000,2001 HappySize, Inc. All rights reserved.
The real line: + *
The real line: + * This software is released under the GNU Lesser General Public License.
The real line: + * (Version 2.1, February 1999)
The real line: + * Please read the following detail of the licence (in japanese).
The real line: + *
The real line: + * ◆使用許諾条件◆
The real line: + *
The real line: + * このソフトウェアは株式会社ハッピーサイズによって開発されました。株式会社ハッ
The real line: + * ピーサイズは、著作権法および万国著作権条約の定めにより、このソフトウェアに関
The real line: + * するすべての権利を留保する権利を持ち、ここに行使します。株式会社ハッピーサイ
The real line: + * ズは以下に明記した条件に従って、このソフトウェアを使用する排他的ではない権利
The real line: + * をお客様に許諾します。何人たりとも、以下の条件に反してこのソフトウェアを使用
The real line: + * することはできません。
The real line: + *
The real line: + * このソフトウェアを「GNU Lesser General Public License (Version 2.1, February
The real line: + * 1999)」に示された条件で使用することを、全ての方に許諾します。「GNU Lesser
The real line: + * General Public License」を満たさない使用には、株式会社ハッピーサイズから書面
The real line: + * による許諾を得る必要があります。
The real line: + *
The real line: + * 「GNU Lesser General Public License」の全文は以下のウェブページから取得でき
The real line: + * ます。「GNU Lesser General Public License」とは、これまでLibrary General
The real line: + * Public Licenseと呼ばれていたものです。
The real line: + *     http://www.gnu.org/ --- GNUウェブサイト
The real line: + *     http://www.gnu.org/copyleft/lesser.html --- ライセンス文面
The real line: + * このライセンスの内容がわからない方、守れない方には使用を許諾しません。
The real line: + *
The real line: + * しかしながら、当社とGNUプロジェクトとの特定の関係を示唆または主張するもので
The real line: + * はありません。
The real line: + *
The real line: + * ◆保証内容◆
The real line: + *
The real line: + * このソフトウェアは、期待された動作・機能・性能を持つことを目標として設計され
The real line: + * 開発されていますが、これを保証するものではありません。このソフトウェアは「こ
The real line: + * のまま」の状態で提供されており、たとえばこのソフトウェアの有用性ないし特定の
The real line: + * 目的に合致することといった、何らかの保証内容が、明示されたり暗黙に示されてい
The real line: + * る場合であっても、その保証は無効です。このソフトウェアを使用した結果ないし使
The real line: + * 用しなかった結果によって、直接あるいは間接に受けた身体的な傷害、財産上の損害
The real line: + * 、データの損失あるいはその他の全ての損害については、その損害の可能性が使用者
The real line: + * 、当社あるいは第三者によって警告されていた場合であっても、当社はその損害の賠
The real line: + * 償および補填を行いません。この規定は他の全ての、書面上または書面に無い保証・
The real line: + * 契約・規定に優先します。
The real line: + *
The real line: + * ◆著作権者の連絡先および使用条件についての問い合わせ先◆
The real line: + *
The real line: + * 〒102-0073
The real line: + * 東京都千代田区九段北1-13-5日本地所第一ビル4F
The real line: + * 株式会社ハッピーサイズ
The real line: + * Phone: 03-3512-3655, Fax: 03-3512-3656
The real line: + * Email: sales@happysize.co.jp
The real line: + * Web: http://happysize.com/
The real line: + *
The real line: + * ◆著者◆
The real line: + *
The real line: + * 金本　茂 <sgk@happysize.co.jp>
The real line: + *
The real line: + * ◆履歴◆
The real line: + *
The real line: + * 1998/11/10 sgk implementation in C++
The real line: + * 1999/4/25  sgk Cで書きなおし。
The real line: + * 1999/4/26  sgk 入力フィルタを実装。漢字コードを推定しながらフィルタを追加。
The real line: + * 1999/6/??      Unicodeサポート。
The real line: + * 1999/6/22  sgk ライセンスをLGPLに変更。
The real line: + *
The real line: + */
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* 
Current Name Search:     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * Unicode support
The real line: + *
The real line: + * Portions copyright (c) 1999,2000,2001 by the PHP3 internationalization team.
The real line: + * All rights reserved.
The real line: + *
The real line: + */
The real line: +
Current Name Search:      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef HAVE_CONFIG_H
Current Name Search:        
LINE TO PARSE FOR KEYWORD:#ifdef have_config_h
Depths: 0:0
[]
The real line: +#include "config.h"
Current Name Search:        #ifdef HAVE_CONFIG_H 
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#endif
Current Name Search:        #ifdef HAVE_CONFIG_H #include  
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include <stddef.h>
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  
LINE TO PARSE FOR KEYWORD:#include <stddef.h>
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef HAVE_STRING_H
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  
LINE TO PARSE FOR KEYWORD:#ifdef have_string_h
Depths: 0:0
[]
The real line: +#include <string.h>
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H 
LINE TO PARSE FOR KEYWORD:#include <string.h>
Depths: 0:0
[]
The real line: +#endif
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef HAVE_STRINGS_H
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  
LINE TO PARSE FOR KEYWORD:#ifdef have_strings_h
Depths: 0:0
[]
The real line: +#include <strings.h>
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H 
LINE TO PARSE FOR KEYWORD:#include <strings.h>
Depths: 0:0
[]
The real line: +#endif
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef HAVE_STDDEF_H
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  
LINE TO PARSE FOR KEYWORD:#ifdef have_stddef_h
Depths: 0:0
[]
The real line: +#include <stddef.h>
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H 
LINE TO PARSE FOR KEYWORD:#include <stddef.h>
Depths: 0:0
[]
The real line: +#endif
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "mbfilter.h"
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "mbfl_filter_output.h"
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "mbfilter_pass.h"
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "eaw_table.h"
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include   
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include   #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* hex character table "0123456789ABCDEF" */
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include   #include   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static char mbfl_hexchar_table[] = {
Current Name Search:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include   #include    
Checking if function:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include   #include    static char mbfl_hexchar_table[] = {
Other type of bracket:        #ifdef HAVE_CONFIG_H #include  #endif  #include <stddef.h>  #ifdef HAVE_STRING_H #include <string.h> #endif  #ifdef HAVE_STRINGS_H #include <strings.h> #endif  #ifdef HAVE_STDDEF_H #include <stddef.h> #endif  #include  #include  #include   #include    static char mbfl_hexchar_table[] = {
LINE TO PARSE FOR KEYWORD:static char mbfl_hexchar_table[] = {
Depths: 1:1
[]
The real line: +	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46
Current Name Search: 
LINE TO PARSE FOR KEYWORD:	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46
Depths: 1:1
[]
The real line: +};
Current Name Search: 	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,0x45,0x46 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: };   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search: };    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * encoding filter
The real line: + */
The real line: +#define CK(statement)	do { if ((statement) < 0) return (-1); } while (0)
Current Name Search: };     
Checking if function: };     #define CK(statement)	do {
Other type of bracket: };     #define CK(statement)	do {
LINE TO PARSE FOR KEYWORD:#define ck(statement)	do { if ((statement) < 0) return (-1); } while (0)
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + *  buffering converter
The real line: + */
The real line: +mbfl_buffer_converter *
Current Name Search:    
LINE TO PARSE FOR KEYWORD:mbfl_buffer_converter *
Depths: 0:0
[]
The real line: +mbfl_buffer_converter_new(
Current Name Search:    mbfl_buffer_converter * 
LINE TO PARSE FOR KEYWORD:mbfl_buffer_converter_new(
Depths: 0:0
[]
The real line: +    enum mbfl_no_encoding from,
Current Name Search:    mbfl_buffer_converter * mbfl_buffer_converter_new( 
LINE TO PARSE FOR KEYWORD:    enum mbfl_no_encoding from,
Depths: 0:0
[]
The real line: +    enum mbfl_no_encoding to,
Current Name Search:    mbfl_buffer_converter * mbfl_buffer_converter_new(     enum mbfl_no_encoding from, 
LINE TO PARSE FOR KEYWORD:    enum mbfl_no_encoding to,
Depths: 0:0
[]
The real line: +    int buf_initsz)
Current Name Search:    mbfl_buffer_converter * mbfl_buffer_converter_new(     enum mbfl_no_encoding from,     enum mbfl_no_encoding to, 
LINE TO PARSE FOR KEYWORD:    int buf_initsz)
Depths: 0:0
[]
The real line: +{
Current Name Search:    mbfl_buffer_converter * mbfl_buffer_converter_new(     enum mbfl_no_encoding from,     enum mbfl_no_encoding to,     int buf_initsz) 
Checking if function:    mbfl_buffer_converter * mbfl_buffer_converter_new(     enum mbfl_no_encoding from,     enum mbfl_no_encoding to,     int buf_initsz) {
PATTERN 4
Function: mbfl_buffer_converter * mbfl_buffer_converter_new(     enum mbfl_no_encoding from,     enum mbfl_no_encoding to,     int buf_initsz) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	mbfl_buffer_converter *convd;
End Check: 1
LINE TO PARSE FOR KEYWORD:	mbfl_buffer_converter *convd;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* allocate */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	convd = (mbfl_buffer_converter*)mbfl_malloc(sizeof (mbfl_buffer_converter));
End Check: 1
LINE TO PARSE FOR KEYWORD:	convd = (mbfl_buffer_converter*)mbfl_malloc(sizeof (mbfl_buffer_converter));
The real line: +	if (convd == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (convd == null) {
The real line: +		return NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		return null;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* initialize */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	convd->from = mbfl_no2encoding(from);
End Check: 1
LINE TO PARSE FOR KEYWORD:	convd->from = mbfl_no2encoding(from);
The real line: +	convd->to = mbfl_no2encoding(to);
End Check: 1
LINE TO PARSE FOR KEYWORD:	convd->to = mbfl_no2encoding(to);
The real line: +	if (convd->from == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (convd->from == null) {
The real line: +		convd->from = &mbfl_encoding_pass;
End Check: 2
LINE TO PARSE FOR KEYWORD:		convd->from = &mbfl_encoding_pass;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	if (convd->to == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (convd->to == null) {
The real line: +		convd->to = &mbfl_encoding_pass;
End Check: 2
LINE TO PARSE FOR KEYWORD:		convd->to = &mbfl_encoding_pass;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* create convert filter */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	convd->filter1 = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	convd->filter1 = null;
The real line: +	convd->filter2 = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	convd->filter2 = null;
The real line: +	if (mbfl_convert_filter_get_vtbl(convd->from->no_encoding, convd->to->no_encoding) != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mbfl_convert_filter_get_vtbl(convd->from->no_encoding, convd->to->no_encoding) != null) {
The real line: +		convd->filter1 = mbfl_convert_filter_new(convd->from->no_encoding, convd->to->no_encoding, mbfl_memory_device_output, 0, &convd->device);
End Check: 2
LINE TO PARSE FOR KEYWORD:		convd->filter1 = mbfl_convert_filter_new(convd->from->no_encoding, convd->to->no_encoding, mbfl_memory_device_output, 0, &convd->device);
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		convd->filter2 = mbfl_convert_filter_new(mbfl_no_encoding_wchar, convd->to->no_encoding, mbfl_memory_device_output, 0, &convd->device);
End Check: 2
LINE TO PARSE FOR KEYWORD:		convd->filter2 = mbfl_convert_filter_new(mbfl_no_encoding_wchar, convd->to->no_encoding, mbfl_memory_device_output, 0, &convd->device);
The real line: +		if (convd->filter2 != NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (convd->filter2 != null) {
The real line: +			convd->filter1 = mbfl_convert_filter_new(convd->from->no_encoding, mbfl_no_encoding_wchar, (int (*)(int, void*))convd->filter2->filter_function, NULL, convd->filter2);
End Check: 3
LINE TO PARSE FOR KEYWORD:			convd->filter1 = mbfl_convert_filter_new(convd->from->no_encoding, mbfl_no_encoding_wchar, (int (*)(int, void*))convd->filter2->filter_function, null, convd->filter2);
The real line: +			if (convd->filter1 == NULL) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (convd->filter1 == null) {
The real line: +				mbfl_convert_filter_delete(convd->filter2);
End Check: 4
LINE TO PARSE FOR KEYWORD:				mbfl_convert_filter_delete(convd->filter2);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	if (convd->filter1 == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (convd->filter1 == null) {
The real line: +		return NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		return null;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	mbfl_memory_device_init(&convd->device, buf_initsz, buf_initsz/4);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mbfl_memory_device_init(&convd->device, buf_initsz, buf_initsz/4);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return convd;
End Check: 1
LINE TO PARSE FOR KEYWORD:	return convd;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
129 : 169
Next: (     enum mbfl_no_encoding from,     enum mbfl_no_encoding to,     int buf_initsz)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +mbfl_buffer_converter_delete(mbfl_buffer_converter *convd)
Current Name. Search:  void 
LINE TO PARSE FOR KEYWORD:mbfl_buffer_converter_delete(mbfl_buffer_converter *convd)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void mbfl_buffer_converter_delete(mbfl_buffer_converter *convd) 
Checking if function:  void mbfl_buffer_converter_delete(mbfl_buffer_converter *convd) {
PATTERN 4
Function: void mbfl_buffer_converter_delete(mbfl_buffer_converter *convd) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	if (convd != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (convd != null) {
The real line: +		if (convd->filter1) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (convd->filter1) {
The real line: +			mbfl_convert_filter_delete(convd->filter1);
End Check: 3
LINE TO PARSE FOR KEYWORD:			mbfl_convert_filter_delete(convd->filter1);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		if (convd->filter2) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (convd->filter2) {
The real line: +			mbfl_convert_filter_delete(convd->filter2);
End Check: 3
LINE TO PARSE FOR KEYWORD:			mbfl_convert_filter_delete(convd->filter2);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		mbfl_memory_device_clear(&convd->device);
End Check: 2
LINE TO PARSE FOR KEYWORD:		mbfl_memory_device_clear(&convd->device);
The real line: +		mbfl_free((void*)convd);
End Check: 2
LINE TO PARSE FOR KEYWORD:		mbfl_free((void*)convd);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
173 : 184
Next: (mbfl_buffer_converter *convd)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +mbfl_buffer_converter_reset(mbfl_buffer_converter *convd)
Current Name Search:  void 
LINE TO PARSE FOR KEYWORD:mbfl_buffer_converter_reset(mbfl_buffer_converter *convd)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void mbfl_buffer_converter_reset(mbfl_buffer_converter *convd) 
Checking if function:  void mbfl_buffer_converter_reset(mbfl_buffer_converter *convd) {
PATTERN 4
Function: void mbfl_buffer_converter_reset(mbfl_buffer_converter *convd) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	mbfl_memory_device_reset(&convd->device);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mbfl_memory_device_reset(&convd->device);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
188 : 190
Next: (mbfl_buffer_converter *convd)
Chunk End.
The real line: //=============================================================================
Current Name Search: 
Depths: 0:0
[]
The real line: -// ClassCache
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -template<>
Current Name Search:    
LINE TO PARSE FOR KEYWORD:template<>
Depths: 0:0
[]
The real line: -inline int
Current Name Search:    template<> 
LINE TO PARSE FOR KEYWORD:inline int
Depths: 0:0
[]
The real line: -ClassCache::hashKey(StringData* sd) {
Current Name Search:    template<> inline int 
LINE TO PARSE FOR KEYWORD:classcache::hashkey(stringdata* sd) {
Depths: 0:0
[]
The real line: -  return sd->hash();
Current Name Search:    template<> inline int ClassCache::hashKey(StringData* sd) { 
LINE TO PARSE FOR KEYWORD:  return sd->hash();
Depths: 0:0
[]
The real line: -}
Current Name Search:   return sd->hash(); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:0
[]
The real line: -
Current Name Search:   return sd->hash(); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -template<>
Current Name Search:   return sd->hash(); }  
LINE TO PARSE FOR KEYWORD:template<>
Depths: 0:0
[]
The real line: -const Class*
Current Name Search:   return sd->hash(); }  template<> 
LINE TO PARSE FOR KEYWORD:const class*
Depths: 0:0
[]
The real line: -ClassCache::lookup(RDS::Handle handle, StringData *name,
Current Name Search:   return sd->hash(); }  template<> const Class* 
LINE TO PARSE FOR KEYWORD:classcache::lookup(rds::handle handle, stringdata *name,
Depths: 0:0
[]
The real line: -                   const void* unused) {
Current Name Search:   return sd->hash(); }  template<> const Class* ClassCache::lookup(RDS::Handle handle, StringData *name, 
LINE TO PARSE FOR KEYWORD:                   const void* unused) {
Depths: 0:0
[]
The real line: -  auto const thiz = handleToPtr<ClassCache>(handle);
Current Name Search:   return sd->hash(); }  template<> const Class* ClassCache::lookup(RDS::Handle handle, StringData *name,                    const void* unused) { 
LINE TO PARSE FOR KEYWORD:  auto const thiz = handletoptr<classcache>(handle);
Depths: 0:0
[]
The real line: -  Pair *pair = thiz->keyToPair(name);
Current Name Search:   auto const thiz = handleToPtr<ClassCache>(handle); 
LINE TO PARSE FOR KEYWORD:  pair *pair = thiz->keytopair(name);
Depths: 0:0
[]
The real line: -  const StringData* pairSd = pair->m_key;
Current Name Search:   Pair *pair = thiz->keyToPair(name); 
LINE TO PARSE FOR KEYWORD:  const stringdata* pairsd = pair->m_key;
Depths: 0:0
[]
The real line: -  if (!stringMatches(pairSd, name)) {
Current Name Search:   const StringData* pairSd = pair->m_key; 
LINE TO PARSE FOR KEYWORD:  if (!stringmatches(pairsd, name)) {
Depths: 0:0
[]
The real line: -    TRACE(1, "ClassCache miss: %s\n", name->data());
Current Name Search:   const StringData* pairSd = pair->m_key;   if (!stringMatches(pairSd, name)) { 
LINE TO PARSE FOR KEYWORD:    trace(1, , name->data());
Depths: 0:0
[]
The real line: -    const NamedEntity *ne = Unit::GetNamedEntity(name);
Current Name Search:     TRACE(1, , name->data()); 
LINE TO PARSE FOR KEYWORD:    const namedentity *ne = unit::getnamedentity(name);
Depths: 0:0
[]
The real line: -    Class *c = Unit::lookupClass(ne);
Current Name Search:     const NamedEntity *ne = Unit::GetNamedEntity(name); 
LINE TO PARSE FOR KEYWORD:    class *c = unit::lookupclass(ne);
Depths: 0:0
[]
The real line: -    if (UNLIKELY(!c)) {
Current Name Search:     Class *c = Unit::lookupClass(ne); 
LINE TO PARSE FOR KEYWORD:    if (unlikely(!c)) {
Depths: 0:0
[]
The real line: -      String normName = normalizeNS(name);
Current Name Search:     Class *c = Unit::lookupClass(ne);     if (UNLIKELY(!c)) { 
LINE TO PARSE FOR KEYWORD:      string normname = normalizens(name);
Depths: 0:0
[]
The real line: -      if (normName) {
Current Name Search:       String normName = normalizeNS(name); 
LINE TO PARSE FOR KEYWORD:      if (normname) {
Depths: 0:0
[]
The real line: -        return lookup(handle, normName.get(), unused);
Current Name Search:       String normName = normalizeNS(name);       if (normName) { 
LINE TO PARSE FOR KEYWORD:        return lookup(handle, normname.get(), unused);
Depths: 0:0
[]
The real line: -      } else {
Current Name Search:         return lookup(handle, normName.get(), unused); 
LINE TO PARSE FOR KEYWORD:      } else {
Depths: 0:0
[]
The real line: -        c = Unit::loadMissingClass(ne, name);
Current Name Search:         return lookup(handle, normName.get(), unused);       } else { 
LINE TO PARSE FOR KEYWORD:        c = unit::loadmissingclass(ne, name);
Depths: 0:0
[]
The real line: -      }
Current Name Search:         c = Unit::loadMissingClass(ne, name); 
LINE TO PARSE FOR KEYWORD:      }
Depths: 0:0
[]
The real line: -      if (UNLIKELY(!c)) {
Current Name Search:         c = Unit::loadMissingClass(ne, name);       } 
LINE TO PARSE FOR KEYWORD:      if (unlikely(!c)) {
Depths: 0:0
[]
The real line: -        raise_error(Strings::UNKNOWN_CLASS, name->data());
Current Name Search:         c = Unit::loadMissingClass(ne, name);       }       if (UNLIKELY(!c)) { 
LINE TO PARSE FOR KEYWORD:        raise_error(strings::unknown_class, name->data());
Depths: 0:0
[]
The real line: -      }
Current Name Search:         raise_error(Strings::UNKNOWN_CLASS, name->data()); 
LINE TO PARSE FOR KEYWORD:      }
Depths: 0:0
[]
The real line: -    }
Current Name Search:         raise_error(Strings::UNKNOWN_CLASS, name->data());       } 
LINE TO PARSE FOR KEYWORD:    }
Depths: 0:0
[]
The real line: -
Current Name Search:  F       raise_error(Strings::UNKNOWN_CLASS, name->data());       }     } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -    if (pair->m_key) decRefStr(pair->m_key);
Current Name Search:         raise_error(Strings::UNKNOWN_CLASS, name->data());       }     }  
LINE TO PARSE FOR KEYWORD:    if (pair->m_key) decrefstr(pair->m_key);
Depths: 0:0
[]
The real line: -    pair->m_key = name;
Current Name Search:     if (pair->m_key) decRefStr(pair->m_key); 
LINE TO PARSE FOR KEYWORD:    pair->m_key = name;
Depths: 0:0
[]
The real line: -    name->incRefCount();
Current Name Search:     pair->m_key = name; 
LINE TO PARSE FOR KEYWORD:    name->increfcount();
Depths: 0:0
[]
The real line: -    pair->m_value = c;
Current Name Search:     name->incRefCount(); 
LINE TO PARSE FOR KEYWORD:    pair->m_value = c;
Depths: 0:0
[]
The real line: -  } else {
Current Name Search:     pair->m_value = c; 
LINE TO PARSE FOR KEYWORD:  } else {
Depths: 0:0
[]
The real line: -    TRACE(1, "ClassCache hit: %s\n", name->data());
Current Name Search:     pair->m_value = c;   } else { 
LINE TO PARSE FOR KEYWORD:    trace(1, , name->data());
Depths: 0:0
[]
The real line: -  }
Current Name Search:     TRACE(1, , name->data()); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 0:0
[]
The real line: -  return pair->m_value;
Current Name Search:     TRACE(1, , name->data());   } 
LINE TO PARSE FOR KEYWORD:  return pair->m_value;
Depths: 0:0
[]
The real line: -}
Current Name Search:   return pair->m_value; 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:0
[]
The real line: -
Current Name Search:   return pair->m_value; } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//=============================================================================
Current Name Search:   return pair->m_value; }  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line:  // *SPropCache
Current Name Search:   return pair->m_value; }   
Depths: 0:0
[]
Chunk End.
The real line: +static RuntimeType
Current Name Search: 
LINE TO PARSE FOR KEYWORD:static runtimetype
Depths: 0:0
[]
The real line: +getDynLocType(const vector<DynLocation*>& inputs,
Current Name Search: static RuntimeType 
LINE TO PARSE FOR KEYWORD:getdynloctype(const vector<dynlocation*>& inputs,
Depths: 0:0
[]
The real line: +              const Tracelet& t,
Current Name Search: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs, 
LINE TO PARSE FOR KEYWORD:              const tracelet& t,
Depths: 0:0
[]
The real line: +              Opcode opcode,
Current Name Search: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs,               const Tracelet& t, 
LINE TO PARSE FOR KEYWORD:              opcode opcode,
Depths: 0:0
[]
The real line: +              NormalizedInstruction* ni,
Current Name Search: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs,               const Tracelet& t,               Opcode opcode, 
LINE TO PARSE FOR KEYWORD:              normalizedinstruction* ni,
Depths: 0:0
[]
The real line: +              Operands op,
Current Name Search: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs,               const Tracelet& t,               Opcode opcode,               NormalizedInstruction* ni, 
LINE TO PARSE FOR KEYWORD:              operands op,
Depths: 0:0
[]
The real line: +              OutTypeConstraints constraint,
Current Name Search: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs,               const Tracelet& t,               Opcode opcode,               NormalizedInstruction* ni,               Operands op, 
LINE TO PARSE FOR KEYWORD:              outtypeconstraints constraint,
Depths: 0:0
[]
The real line: +              DynLocation* outDynLoc) {
Current Name Search: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs,               const Tracelet& t,               Opcode opcode,               NormalizedInstruction* ni,               Operands op,               OutTypeConstraints constraint, 
Checking if function: static RuntimeType getDynLocType(const vector<DynLocation*>& inputs,               const Tracelet& t,               Opcode opcode,               NormalizedInstruction* ni,               Operands op,               OutTypeConstraints constraint,               DynLocation* outDynLoc) {
PATTERN 1
Function:  RuntimeType getDynLocType(const vector<DynLocation*>& inputs,              Tracelet& t,               Opcode opcode,               NormalizedInstruction* ni,               Operands op,               OutTypeConstraints constraint,               DynLocation* outDynLoc) {
LINE TO PARSE FOR KEYWORD:              dynlocation* outdynloc) {
Depths: 1:0
[]
The real line: +  assert(constraint != OutFInputL);
End Check: 1
LINE TO PARSE FOR KEYWORD:  assert(constraint != outfinputl);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  switch (constraint) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  switch (constraint) {
The real line: +#define CS(OutXLike, KindOfX) \
End Check: 2
LINE TO PARSE FOR KEYWORD:#define cs(outxlike, kindofx) \
The real line: +    case OutXLike:            \
End Check: 2
LINE TO PARSE FOR KEYWORD:    case outxlike:            \
The real line: +      return RuntimeType(KindOfX);
End Check: 2
LINE TO PARSE FOR KEYWORD:      return runtimetype(kindofx);
The real line: +    CS(OutInt64,       KindOfInt64);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outint64,       kindofint64);
The real line: +    CS(OutBoolean,     KindOfBoolean);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outboolean,     kindofboolean);
The real line: +    CS(OutDouble,      KindOfDouble);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outdouble,      kindofdouble);
The real line: +    CS(OutString,      KindOfString);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outstring,      kindofstring);
The real line: +    CS(OutNull,        KindOfNull);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outnull,        kindofnull);
The real line: +    CS(OutUnknown,     KindOfInvalid); // Subtle interaction with BB-breaking.
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outunknown,     kindofinvalid); 
The real line: +    CS(OutFDesc,       KindOfInvalid); // Unclear if OutFDesc has a purpose.
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outfdesc,       kindofinvalid); 
The real line: +    CS(OutArray,       KindOfArray);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outarray,       kindofarray);
The real line: +    CS(OutObject,      KindOfObject);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cs(outobject,      kindofobject);
The real line: +#undef CS
End Check: 2
LINE TO PARSE FOR KEYWORD:#undef cs
The real line: +    case OutPred: return RuntimeType(predictOutputs(t, ni));
End Check: 2
LINE TO PARSE FOR KEYWORD:    case outpred: return runtimetype(predictoutputs(t, ni));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutClassRef: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outclassref: {
The real line: +      Op op = Op(ni->op());
End Check: 3
LINE TO PARSE FOR KEYWORD:      op op = op(ni->op());
The real line: +      if ((op == OpAGetC && inputs[0]->isString())) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if ((op == opagetc && inputs[0]->isstring())) {
The real line: +        const StringData *sd = inputs[0]->rtt.valueString();
End Check: 4
LINE TO PARSE FOR KEYWORD:        const stringdata *sd = inputs[0]->rtt.valuestring();
The real line: +        if (sd) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (sd) {
The real line: +          Class *klass = Unit::lookupUniqueClass(sd);
End Check: 5
LINE TO PARSE FOR KEYWORD:          class *klass = unit::lookupuniqueclass(sd);
The real line: +          TRACE(3, "KindOfClass: derived class \"%s\" from string literal\n",
End Check: 5
LINE TO PARSE FOR KEYWORD:          trace(3, %s\,
The real line: +                klass ? klass->preClass()->name()->data() : "NULL");
End Check: 5
LINE TO PARSE FOR KEYWORD:                klass ? klass->preclass()->name()->data() : );
The real line: +          return RuntimeType(klass);
End Check: 5
LINE TO PARSE FOR KEYWORD:          return runtimetype(klass);
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +      } else if (op == OpSelf) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      } else if (op == opself) {
The real line: +        return RuntimeType(curClass());
End Check: 4
LINE TO PARSE FOR KEYWORD:        return runtimetype(curclass());
The real line: +      } else if (op == OpParent) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      } else if (op == opparent) {
The real line: +        Class* clss = curClass();
End Check: 4
LINE TO PARSE FOR KEYWORD:        class* clss = curclass();
The real line: +        if (clss != nullptr)
End Check: 4
LINE TO PARSE FOR KEYWORD:        if (clss != nullptr)
The real line: +          return RuntimeType(clss->parent());
End Check: 4
LINE TO PARSE FOR KEYWORD:          return runtimetype(clss->parent());
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      return RuntimeType(KindOfClass);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(kindofclass);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutCns: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outcns: {
The real line: +      // If it's a system constant, burn in its type. Otherwise we have
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      // to accept prediction; use the translation-time value, or fall back
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      // to the targetcache if none exists.
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      StringData *sd = curUnit()->lookupLitstrId(ni->imm[0].u_SA);
End Check: 3
LINE TO PARSE FOR KEYWORD:      stringdata *sd = curunit()->lookuplitstrid(ni->imm[0].u_sa);
The real line: +      assert(sd);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(sd);
The real line: +      const TypedValue* tv = Unit::lookupPersistentCns(sd);
End Check: 3
LINE TO PARSE FOR KEYWORD:      const typedvalue* tv = unit::lookuppersistentcns(sd);
The real line: +      if (tv) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (tv) {
The real line: +        return RuntimeType(tv->m_type);
End Check: 4
LINE TO PARSE FOR KEYWORD:        return runtimetype(tv->m_type);
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      tv = Unit::lookupCns(sd);
End Check: 3
LINE TO PARSE FOR KEYWORD:      tv = unit::lookupcns(sd);
The real line: +      if (tv) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (tv) {
The real line: +        ni->outputPredicted = true;
End Check: 4
LINE TO PARSE FOR KEYWORD:        ni->outputpredicted = true;
The real line: +        TRACE(1, "CNS %s: guessing runtime type %d\n", sd->data(), tv->m_type);
End Check: 4
LINE TO PARSE FOR KEYWORD:        trace(1, , sd->data(), tv->m_type);
The real line: +        return RuntimeType(tv->m_type);
End Check: 4
LINE TO PARSE FOR KEYWORD:        return runtimetype(tv->m_type);
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      return RuntimeType(KindOfInvalid);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(kindofinvalid);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutNullUninit: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outnulluninit: {
The real line: +      assert(ni->op() == OpNullUninit);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(ni->op() == opnulluninit);
The real line: +      return RuntimeType(KindOfUninit);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(kindofuninit);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutStringImm: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outstringimm: {
The real line: +      assert(ni->op() == OpString);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(ni->op() == opstring);
The real line: +      StringData *sd = curUnit()->lookupLitstrId(ni->imm[0].u_SA);
End Check: 3
LINE TO PARSE FOR KEYWORD:      stringdata *sd = curunit()->lookuplitstrid(ni->imm[0].u_sa);
The real line: +      assert(sd);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(sd);
The real line: +      return RuntimeType(sd);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(sd);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutArrayImm: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outarrayimm: {
The real line: +      assert(ni->op() == OpArray);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(ni->op() == oparray);
The real line: +      ArrayData *ad = curUnit()->lookupArrayId(ni->imm[0].u_AA);
End Check: 3
LINE TO PARSE FOR KEYWORD:      arraydata *ad = curunit()->lookuparrayid(ni->imm[0].u_aa);
The real line: +      assert(ad);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(ad);
The real line: +      return RuntimeType(ad);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(ad);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutBooleanImm: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outbooleanimm: {
The real line: +      assert(ni->op() == OpTrue || ni->op() == OpFalse);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(ni->op() == optrue || ni->op() == opfalse);
The real line: +      return RuntimeType(ni->op() == OpTrue);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(ni->op() == optrue);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutThisObject: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outthisobject: {
The real line: +      return Translator::outThisObjectType();
End Check: 3
LINE TO PARSE FOR KEYWORD:      return translator::outthisobjecttype();
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutVUnknown: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outvunknown: {
The real line: +      return RuntimeType(KindOfRef, KindOfInvalid);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(kindofref, kindofinvalid);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutArith: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outarith: {
The real line: +      return RuntimeType(inferType(ArithRules, inputs));
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(infertype(arithrules, inputs));
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutSameAsInput: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outsameasinput: {
The real line: +      /*
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +       * Relies closely on the order that inputs are pushed in
The real line: +       * getInputs().  (Pushing top of stack first for multi-stack
The real line: +       * consumers, stack elements before M-vectors and locals, etc.)
The real line: +       */
The real line: +      assert(inputs.size() >= 1);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(inputs.size() >= 1);
The real line: +      Opcode op = ni->op();
End Check: 3
LINE TO PARSE FOR KEYWORD:      opcode op = ni->op();
The real line: +      ASSERT_NOT_IMPLEMENTED(
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert_not_implemented(
The real line: +        // Sets and binds that take multiple arguments have the rhs
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        // pushed first.  In the case of the M-vector versions, the
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        // rhs comes before the M-vector elements.
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        op == OpSetL  || op == OpSetN  || op == OpSetG  || op == OpSetS  ||
End Check: 3
LINE TO PARSE FOR KEYWORD:        op == opsetl  || op == opsetn  || op == opsetg  || op == opsets  ||
The real line: +        op == OpBindL || op == OpBindG || op == OpBindS || op == OpBindN ||
End Check: 3
LINE TO PARSE FOR KEYWORD:        op == opbindl || op == opbindg || op == opbinds || op == opbindn ||
The real line: +        op == OpSetM  || op == OpBindM ||
End Check: 3
LINE TO PARSE FOR KEYWORD:        op == opsetm  || op == opbindm ||
The real line: +        // Dup takes a single element.
End Check: 3
LINE TO PARSE FOR KEYWORD:        
The real line: +        op == OpDup
End Check: 3
LINE TO PARSE FOR KEYWORD:        op == opdup
The real line: +      );
End Check: 3
LINE TO PARSE FOR KEYWORD:      );
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      if (op == OpSetM) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (op == opsetm) {
The real line: +        /*
End Check: 4
LINE TO PARSE FOR KEYWORD:        
The real line: +         * SetM returns null for "invalid" inputs, or a string if the
The real line: +         * base was a string. VectorTranslator ensures that invalid
The real line: +         * inputs or a string output when we weren't expecting it will
The real line: +         * cause a side exit, so we can keep this fairly simple.
The real line: +         */
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +        if (ni->immVecM.size() > 1) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (ni->immvecm.size() > 1) {
The real line: +          // We don't know the type of the base for the final
End Check: 5
LINE TO PARSE FOR KEYWORD:          
The real line: +          // operation so we can't assume anything about the output
End Check: 5
LINE TO PARSE FOR KEYWORD:          
The real line: +          // type.
End Check: 5
LINE TO PARSE FOR KEYWORD:          
The real line: +          return RuntimeType(KindOfAny);
End Check: 5
LINE TO PARSE FOR KEYWORD:          return runtimetype(kindofany);
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +        // For single-element vectors, we can determine the output
End Check: 4
LINE TO PARSE FOR KEYWORD:        
The real line: +        // type from the base.
End Check: 4
LINE TO PARSE FOR KEYWORD:        
The real line: +        Type baseType;
End Check: 4
LINE TO PARSE FOR KEYWORD:        type basetype;
The real line: +        switch (ni->immVec.locationCode()) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        switch (ni->immvec.locationcode()) {
The real line: +          case LGL: case LGC:
End Check: 5
LINE TO PARSE FOR KEYWORD:          case lgl: case lgc:
The real line: +          case LNL: case LNC:
End Check: 5
LINE TO PARSE FOR KEYWORD:          case lnl: case lnc:
The real line: +          case LSL: case LSC:
End Check: 5
LINE TO PARSE FOR KEYWORD:          case lsl: case lsc:
The real line: +            baseType = Type::Gen;
End Check: 5
LINE TO PARSE FOR KEYWORD:            basetype = type::gen;
The real line: +            break;
End Check: 5
LINE TO PARSE FOR KEYWORD:            break;
The real line: +
End Check: 5
LINE TO PARSE FOR KEYWORD:
The real line: +          default:
End Check: 5
LINE TO PARSE FOR KEYWORD:          default:
The real line: +            baseType = Type::fromRuntimeType(inputs[1]->rtt);
End Check: 5
LINE TO PARSE FOR KEYWORD:            basetype = type::fromruntimetype(inputs[1]->rtt);
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +        const bool setElem = mcodeMaybeArrayKey(ni->immVecM[0]);
End Check: 4
LINE TO PARSE FOR KEYWORD:        const bool setelem = mcodemaybearraykey(ni->immvecm[0]);
The real line: +        const bool setNewElem = ni->immVecM[0] == MW;
End Check: 4
LINE TO PARSE FOR KEYWORD:        const bool setnewelem = ni->immvecm[0] == mw;
The real line: +        const Type keyType =
End Check: 4
LINE TO PARSE FOR KEYWORD:        const type keytype =
The real line: +          setNewElem ? Type::None
End Check: 4
LINE TO PARSE FOR KEYWORD:          setnewelem ? type::none
The real line: +                     : Type::fromRuntimeType(inputs[2]->rtt);
End Check: 4
LINE TO PARSE FOR KEYWORD:                     : type::fromruntimetype(inputs[2]->rtt);
The real line: +        const Type valType = Type::fromRuntimeType(inputs[0]->rtt);
End Check: 4
LINE TO PARSE FOR KEYWORD:        const type valtype = type::fromruntimetype(inputs[0]->rtt);
The real line: +        if (setElem && baseType.maybe(Type::Str)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (setelem && basetype.maybe(type::str)) {
The real line: +          if (baseType.isString()) {
End Check: 6
LINE TO PARSE FOR KEYWORD:          if (basetype.isstring()) {
The real line: +            // The base is a string so our output is a string.
End Check: 6
LINE TO PARSE FOR KEYWORD:            
The real line: +            return RuntimeType(KindOfString);
End Check: 6
LINE TO PARSE FOR KEYWORD:            return runtimetype(kindofstring);
The real line: +          } else if (!valType.isString()) {
End Check: 6
LINE TO PARSE FOR KEYWORD:          } else if (!valtype.isstring()) {
The real line: +            // The base might be a string and our value isn't known to
End Check: 6
LINE TO PARSE FOR KEYWORD:            
The real line: +            // be a string. The output type could be Str or valType.
End Check: 6
LINE TO PARSE FOR KEYWORD:            
The real line: +            return RuntimeType(KindOfAny);
End Check: 6
LINE TO PARSE FOR KEYWORD:            return runtimetype(kindofany);
The real line: +          }
End Check: 5
LINE TO PARSE FOR KEYWORD:          }
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      const int idx = 0; // all currently supported cases.
End Check: 3
LINE TO PARSE FOR KEYWORD:      const int idx = 0; 
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      if (debug) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (debug) {
The real line: +        if (!inputs[idx]->rtt.isVagueValue()) {
End Check: 5
LINE TO PARSE FOR KEYWORD:        if (!inputs[idx]->rtt.isvaguevalue()) {
The real line: +          if (op == OpBindG || op == OpBindN || op == OpBindS ||
End Check: 5
LINE TO PARSE FOR KEYWORD:          if (op == opbindg || op == opbindn || op == opbinds ||
The real line: +              op == OpBindM || op == OpBindL) {
End Check: 6
LINE TO PARSE FOR KEYWORD:              op == opbindm || op == opbindl) {
The real line: +            assert(inputs[idx]->rtt.isRef() && !inputs[idx]->isLocal());
End Check: 6
LINE TO PARSE FOR KEYWORD:            assert(inputs[idx]->rtt.isref() && !inputs[idx]->islocal());
The real line: +          } else {
End Check: 6
LINE TO PARSE FOR KEYWORD:          } else {
The real line: +            assert(inputs[idx]->rtt.valueType() ==
End Check: 6
LINE TO PARSE FOR KEYWORD:            assert(inputs[idx]->rtt.valuetype() ==
The real line: +                   inputs[idx]->rtt.outerType());
End Check: 6
LINE TO PARSE FOR KEYWORD:                   inputs[idx]->rtt.outertype());
The real line: +          }
End Check: 5
LINE TO PARSE FOR KEYWORD:          }
The real line: +        }
End Check: 4
LINE TO PARSE FOR KEYWORD:        }
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      return inputs[idx]->rtt;
End Check: 3
LINE TO PARSE FOR KEYWORD:      return inputs[idx]->rtt;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutCInputL: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outcinputl: {
The real line: +      assert(inputs.size() >= 1);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(inputs.size() >= 1);
The real line: +      const DynLocation* in = inputs[inputs.size() - 1];
End Check: 3
LINE TO PARSE FOR KEYWORD:      const dynlocation* in = inputs[inputs.size() - 1];
The real line: +      RuntimeType retval;
End Check: 3
LINE TO PARSE FOR KEYWORD:      runtimetype retval;
The real line: +      if (in->rtt.outerType() == KindOfUninit) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (in->rtt.outertype() == kindofuninit) {
The real line: +        // Locals can be KindOfUninit, so we need to convert
End Check: 4
LINE TO PARSE FOR KEYWORD:        
The real line: +        // this to KindOfNull
End Check: 4
LINE TO PARSE FOR KEYWORD:        
The real line: +        retval = RuntimeType(KindOfNull);
End Check: 4
LINE TO PARSE FOR KEYWORD:        retval = runtimetype(kindofnull);
The real line: +      } else {
End Check: 4
LINE TO PARSE FOR KEYWORD:      } else {
The real line: +        retval = in->rtt.unbox();
End Check: 4
LINE TO PARSE FOR KEYWORD:        retval = in->rtt.unbox();
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      TRACE(2, "Input (%d, %d) -> (%d, %d)\n",
End Check: 3
LINE TO PARSE FOR KEYWORD:      trace(2, ,
The real line: +            in->rtt.outerType(), in->rtt.innerType(),
End Check: 3
LINE TO PARSE FOR KEYWORD:            in->rtt.outertype(), in->rtt.innertype(),
The real line: +            retval.outerType(), retval.innerType());
End Check: 3
LINE TO PARSE FOR KEYWORD:            retval.outertype(), retval.innertype());
The real line: +      return retval;
End Check: 3
LINE TO PARSE FOR KEYWORD:      return retval;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutIncDec: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outincdec: {
The real line: +      const RuntimeType &inRtt = ni->inputs[0]->rtt;
End Check: 3
LINE TO PARSE FOR KEYWORD:      const runtimetype &inrtt = ni->inputs[0]->rtt;
The real line: +      // TODO: instead of KindOfInvalid this should track the actual
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      // type we will get from interping a non-int IncDec.
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      return RuntimeType(IS_INT_TYPE(inRtt.valueType()) ?
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(is_int_type(inrtt.valuetype()) ?
The real line: +                         KindOfInt64 : KindOfInvalid);
End Check: 3
LINE TO PARSE FOR KEYWORD:                         kindofint64 : kindofinvalid);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutStrlen: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outstrlen: {
The real line: +      auto const& rtt = ni->inputs[0]->rtt;
End Check: 3
LINE TO PARSE FOR KEYWORD:      auto const& rtt = ni->inputs[0]->rtt;
The real line: +      return RuntimeType(rtt.isString() ? KindOfInt64 : KindOfInvalid);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return runtimetype(rtt.isstring() ? kindofint64 : kindofinvalid);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutCInput: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outcinput: {
The real line: +      assert(inputs.size() >= 1);
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(inputs.size() >= 1);
The real line: +      const DynLocation* in = inputs[inputs.size() - 1];
End Check: 3
LINE TO PARSE FOR KEYWORD:      const dynlocation* in = inputs[inputs.size() - 1];
The real line: +      if (in->rtt.outerType() == KindOfRef) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (in->rtt.outertype() == kindofref) {
The real line: +        return in->rtt.unbox();
End Check: 4
LINE TO PARSE FOR KEYWORD:        return in->rtt.unbox();
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      return in->rtt;
End Check: 3
LINE TO PARSE FOR KEYWORD:      return in->rtt;
The r..eal line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutBitOp: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outbitop: {
The real line: +      assert(inputs.size() == 2 ||
End Check: 3
LINE TO PARSE FOR KEYWORD:      assert(inputs.size() == 2 ||
The real line: +             (inputs.size() == 1 && opcode == OpBitNot));
End Check: 3
LINE TO PARSE FOR KEYWORD:             (inputs.size() == 1 && opcode == opbitnot));
The real line: +      if (inputs.size() == 2) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      if (inputs.size() == 2) {
The real line: +        return bitOpType(inputs[0], inputs[1]);
End Check: 4
LINE TO PARSE FOR KEYWORD:        return bitoptype(inputs[0], inputs[1]);
The real line: +      } else {
End Check: 4
LINE TO PARSE FOR KEYWORD:      } else {
The real line: +        return bitOpType(inputs[0], nullptr);
End Check: 4
LINE TO PARSE FOR KEYWORD:        return bitoptype(inputs[0], nullptr);
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutSetOp: {
End Check: 3
LINE TO PARSE FOR KEYWORD:    case outsetop: {
The real line: +      return setOpOutputType(ni, inputs);
End Check: 3
LINE TO PARSE FOR KEYWORD:      return setopoutputtype(ni, inputs);
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    case OutNone:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case outnone:
The real line: +    default:
End Check: 2
LINE TO PARSE FOR KEYWORD:    default:
The real line: +      return RuntimeType(KindOfInvalid);
End Check: 2
LINE TO PARSE FOR KEYWORD:      return runtimetype(kindofinvalid);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
8 : 241
Next: (const vector<DynLocation*>& inputs,              Tracelet& t,               Opcode opcode,               NormalizedInstruction* ni,               Operands op,               OutTypeConstraints constraint,               DynLocation* outDynLoc)
Chunk End.
The real line: +// PR c++/57682
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// { dg-do compile { target c++11 } }
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +struct Class
Current Name Search:    
LINE TO PARSE FOR KEYWORD:struct class
Depths: 0:0
[]
The real line: +{
Current Name Search:    struct Class 
Checking if function:    struct Class {
Other type of bracket:    struct Class {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
[]
The real line: +  Class (int func)
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  class (int func)
Depths: 1:1
[]
The real line: +  try
Current Name Search:   Class (int func) 
LINE TO PARSE FOR KEYWORD:  try
Depths: 1:1
[]
The real line: +  : f { func }  { }
Current Name Search:   Class (int func)   try 
Checking if function:   Class (int func)   try   : f {
Other type of bracket:   Class (int func)   try   : f {
LINE TO PARSE FOR KEYWORD:  : f { func }  { }
Depths: 1:2
[]
Adjusting depth.
The real line: +  catch ( ... ) { }
Current Name Search: 
Checking if function:   catch ( ... ) {
Other type of bracket:   catch ( ... ) {
LINE TO PARSE FOR KEYWORD:  catch ( ... ) { }
Depths: 1:2
[]
Adjusting depth.
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +private:
Current Name Search:  
LINE TO PARSE FOR KEYWORD:private:
Depths: 1:1
[]
The real line: +  int f;
Current Name Search:  private: 
LINE TO PARSE FOR KEYWORD:  int f;
Depths: 1:1
[]
The real line: +};
Current Name Search:   int f; 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
[]
Adjusting depth.
Chunk End.
The real line: -/******************************************************************
Current Name Search: 
LINE TO PARSE FOR KEYWORD:/******************************************************************
Depths: 0:0
[]
The real line: -If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY,
Current Name Search: /****************************************************************** 
LINE TO PARSE FOR KEYWORD:if the latch mode of the cursor is btr_leaf_search or btr_leaf_modify,
Depths: 0:0
[]
The real line: -releases the page latch and bufferfix reserved by the cursor.
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, 
LINE TO PARSE FOR KEYWORD:releases the page latch and bufferfix reserved by the cursor.
Depths: 0:0
[]
The real line: -NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. 
LINE TO PARSE FOR KEYWORD:note! in the case of btr_leaf_modify, there should not exist changes
Depths: 0:0
[]
The real line: -made by the current mini-transaction to the data protected by the
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes 
LINE TO PARSE FOR KEYWORD:made by the current mini-transaction to the data protected by the
Depths: 0:0
[]
The real line: -cursor latch, as then the latch must not be released until mtr_commit. */
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the 
LINE TO PARSE FOR KEYWORD:cursor latch, as then the latch must not be released until mtr_commit. */
Depths: 0:0
[]
The real line: -
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -void
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: -btr_pcur_release_leaf(
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  void 
LINE TO PARSE FOR KEYWORD:btr_pcur_release_leaf(
Depths: 0:0
[]
The real line: -/*==================*/
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  void btr_pcur_release_leaf( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -       btr_pcur_t*     cursor, /* in: persistent cursor */
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  void btr_pcur_release_leaf(  
LINE TO PARSE FOR KEYWORD:       btr_pcur_t*     cursor, 
Depths: 0:0
[]
The real line: -       mtr_t*          mtr)    /* in: mtr */
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  void btr_pcur_release_leaf(         btr_pcur_t*     cursor,  
LINE TO PARSE FOR KEYWORD:       mtr_t*          mtr)    
Depths: 0:0
[]
The real line: -{
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  void btr_pcur_release_leaf(         btr_pcur_t*     cursor,         mtr_t*          mtr)     
LINE TO PARSE FOR KEYWORD:{
Depths: 0:0
[]
The real line: -       page_t* page;
Current Name Search: /****************************************************************** If the latch mode of the cursor is BTR_LEAF_SEARCH or BTR_LEAF_MODIFY, releases the page latch and bufferfix reserved by the cursor. NOTE! In the case of BTR_LEAF_MODIFY, there should not exist changes made by the current mini-transaction to the data protected by the cursor latch, as then the latch must not be released until mtr_commit. */  void btr_pcur_release_leaf(         btr_pcur_t*     cursor,         mtr_t*          mtr)     { 
LINE TO PARSE FOR KEYWORD:       page_t* page;
Depths: 0:0
[]
The real line: -
Current Name Search:        page_t* page; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -       //These should be called asserts too
Current Name Search:        page_t* page;  
LINE TO PARSE FOR KEYWORD:       
Depths: 0:0
[]
The real line: -       ut_a(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
Current Name Search:        page_t* page;          
LINE TO PARSE FOR KEYWORD:       ut_a(cursor->pos_state == btr_pcur_is_positioned);
Depths: 0:0
[]
The real line: -       ut_ad(cursor->latch_mode != BTR_NO_LATCHES);
Current Name Search:        ut_a(cursor->pos_state == BTR_PCUR_IS_POSITIONED); 
LINE TO PARSE FOR KEYWORD:       ut_ad(cursor->latch_mode != btr_no_latches);
Depths: 0:0
[]
The real line: -
Current Name Search:        ut_ad(cursor->latch_mode != BTR_NO_LATCHES); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -       page = btr_cur_get_page(btr_pcur_get_btr_cur(cursor));
Current Name Search:        ut_ad(cursor->latch_mode != BTR_NO_LATCHES);  
LINE TO PARSE FOR KEYWORD:       page = btr_cur_get_page(btr_pcur_get_btr_cur(cursor));
Depths: 0:0
[]
The real line: -
Current Name Search:        page = btr_cur_get_page(btr_pcur_get_btr_cur(cursor)); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -       btr_leaf_page_release(page, cursor->latch_mode, mtr);
Current Name Search:        page = btr_cur_get_page(btr_pcur_get_btr_cur(cursor));  
LINE TO PARSE FOR KEYWORD:       btr_leaf_page_release(page, Fcursor->latch_mode, mtr);
Depths: 0:0
[]
The real line: -
Current Name Search:        btr_leaf_page_release(page, cursor->latch_mode, mtr); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -       cursor->latch_mode = BTR_NO_LATCHES;
Current Name Search:        btr_leaf_page_release(page, cursor->latch_mode, mtr);  
LINE TO PARSE FOR KEYWORD:       cursor->latch_mode = btr_no_latches;
Depths: 0:0
[]
The real line: -
Current Name Search:        cursor->latch_mode = BTR_NO_LATCHES; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -       cursor->pos_state = BTR_PCUR_WAS_POSITIONED;
Current Name Search:        cursor->latch_mode = BTR_NO_LATCHES;  
LINE TO PARSE FOR KEYWORD:       cursor->pos_state = btr_pcur_was_positioned;
Depths: 0:0
[]
The real line: -}
Current Name Search:        cursor->pos_state = BTR_PCUR_WAS_POSITIONED; 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:0
[]
The real line: -
Current Name Search:        cursor->pos_state = BTR_PCUR_WAS_POSITIONED; } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
Chunk End.
The real line: -static MDL_global_lock global_lock;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:static mdl_global_lock global_lock;
Depths: 0:0
[]
The real line: +/**
Current Name Search: static MDL_global_lock global_lock; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  An implementation of a per-object lock. Supports SHARED, SHARED_UPGRADABLE,
The real line: +  SHARED HIGH PRIORITY and EXCLUSIVE locks.
The real line: +*/
The real line: +
Current Name Search: static MDL_global_lock global_lock;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +class MDL_object_lock : public MDL_lock
Current Name Search: static MDL_global_lock global_lock;   
LINE TO PARSE FOR KEYWORD:class mdl_object_lock : public mdl_lock
Depths: 0:0
[]
The real line: +{
Current Name Search: static MDL_global_lock global_lock;   class MDL_object_lock : public MDL_lock 
Checking if function: static MDL_global_lock global_lock;   class MDL_object_lock : public MDL_lock {
Class: class mdl_object_lock : public mdl_lock {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
['mdl_object_lock']
The real line: +public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD:public:
Depths: 1:1
['mdl_object_lock']
The real line: +  MDL_object_lock(const MDL_key *key_arg)
Current Name Search: public: 
LINE TO PARSE FOR KEYWORD:  mdl_object_lock(const mdl_key *key_arg)
Depths: 1:1
['mdl_object_lock']
The real line: +    : MDL_lock(key_arg)
Current Name Search: public:   MDL_object_lock(const MDL_key *key_arg) 
LINE TO PARSE FOR KEYWORD:    : mdl_lock(key_arg)
Depths: 1:1
['mdl_object_lock']
The real line: +  { }
Current Name Search: public:   MDL_object_lock(const MDL_key *key_arg)     : MDL_lock(key_arg) 
Checking if function: public:   MDL_object_lock(const MDL_key *key_arg)     : MDL_lock(key_arg)   {
Class context: mdl_object_lock
Checking if a constructor/destructor: public:   MDL_object_lock(const MDL_key *key_arg)     : MDL_lock(key_arg)   {
Function: public:   MDL_object_lock(const MDL_key *key_arg)     : MDL_lock(key_arg)   {
LINE TO PARSE FOR KEYWORD:  { }
Next: (const MDL_key *key_arg)
Next: (key_arg)
Depths: 1:1
['mdl_object_lock']
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['mdl_object_lock']
The real line: +  virtual bool can_grant_lock(const MDL_context *requestor_ctx,
Current Name Search:  
LINE TO PARSE FOR KEYWORD:  virtual bool can_grant_lock(const mdl_context *requestor_ctx,
Depths: 1:1
['mdl_object_lock']
The real line: +                              enum_mdl_type type, bool is_upgrade);
Current Name Search:    virtual bool can_grant_lock(const MDL_context *requestor_ctx, 
LINE TO PARSE FOR KEYWORD:                              enum_mdl_type type, bool is_upgrade);
Depths: 1:1
['mdl_object_lock']
The real line: +  virtual void wake_up_waiters();
Current Name Search:                               enum_mdl_type type, bool is_upgrade); 
LINE TO PARSE FOR KEYWORD:  virtual void wake_up_waiters();
Depths: 1:1
['mdl_object_lock']
The real line: +};
Current Name Search:   virtual vo.id wake_up_waiters(); 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
['mdl_object_lock']
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['mdl_object_lock']
Chunk End.
The real line: +/** Initialize the global hash containing all MDL locks. */
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void MDL_map::init()
Current Name Search:   
LINE TO PARSE FOR KEYWORD:void mdl_map::init()
Depths: 0:0
[]
The real line: +{
Current Name Search:   void MDL_map::init() 
Checking if function:   void MDL_map::init() {
PATTERN 4
Function: void MDL_map::init() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  pthread_mutex_init(&m_mutex, NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_init(&m_mutex, null);
The real line: +  my_hash_init(&m_locks, &my_charset_bin, 16 /* FIXME */, 0, 0,
End Check: 1
LINE TO PARSE FOR KEYWORD:  my_hash_init(&m_locks, &my_charset_bin, 16 , 0, 0,
The real line: +               mdl_locks_key, 0, 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:               mdl_locks_key, 0, 0);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
5 : 9
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line:  /**
Current Name Search:   
Depths: 0:0
[]
The real line: -  Initialize a metadata locking context.
Current Name Search:     
LINE TO PARSE FOR KEYWORD:  initialize a metadata locking context.
Depths: 0:0
[]
The real line: +  Destroy the global hash containing all MDL locks.
The real line: +  @pre It must be empty.
The real line: +*/
The real line: -  This is to be called when a new server connection is created.
Current Name Search:       Initialize a metadata locking context. 
LINE TO PARSE FOR KEYWORD:  this is to be called when a new server connection is created.
Depths: 0:0
[]
The real line: +void MDL_map::destroy()
Current Name Search:       Initialize a metadata locking context.   This is to be called when a new server connection is created. 
LINE TO PARSE FOR KEYWORD:void mdl_map::destroy()
Depths: 0:0
[]
The real line: +{
Current Name Search:       Initialize a metadata locking context.   This is to be called when a new server connection is created. void MDL_map::destroy() 
Checking if function:       Initialize a metadata locking context.   This is to be called when a new server connection is created. void MDL_map::destroy() {
PATTERN 1
Function:  void MDL_map::destroy() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  DBUG_ASSERT(!m_locks.records);
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_assert(!m_locks.records);
The real line: +  pthread_mutex_destroy(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_destroy(&m_mutex);
The real line: +  my_hash_free(&m_locks);
End Check: 1
LINE TO PARSE FOR KEYWORD:  my_hash_free(&m_locks);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
20 : 24
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Find MDL_lock object corresponding to the key, create it
The real line: +  if it does not exist.
The real line: +
The real line: +  @retval non-NULL - Success. MDL_lock instance for the key with
The real line: +                     locked MDL_lock::m_mutex.
The real line: +  @retval NULL     - Failure (OOM).
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +MDL_lock* MDL_map::find_or_insert(const MDL_key *mdl_key)
Current Name Search:     
LINE TO PARSE FOR KEYWORD:mdl_lock* mdl_map::find_or_insert(const mdl_key *mdl_key)
Depths: 0:0
[]
The real line: +{
Current Name Search:     MDL_lock* MDL_map::find_or_insert(const MDL_key *mdl_key) 
Checking if function:     MDL_lock* MDL_map::find_or_insert(const MDL_key *mdl_key) {
PATTERN 4
Function: MDL_lock* MDL_map::find_or_insert(const MDL_key *mdl_key) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  MDL_lock *lock;
End Check: 1
LINE TO PARSE FOR KEYWORD:  mdl_lock *lock;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +retry:
End Check: 1
LINE TO PARSE FOR KEYWORD:retry:
The real line: +  pthread_mutex_lock(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_lock(&m_mutex);
The real line: +  if (!(lock= (MDL_lock*) my_hash_search(&m_locks,
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(lock= (mdl_lock*) my_hash_search(&m_locks,
The real line: +                                         mdl_key->ptr(),
End Check: 1
LINE TO PARSE FOR KEYWORD:                                         mdl_key->ptr(),
The real line: +                                         mdl_key->length())))
End Check: 1
LINE TO PARSE FOR KEYWORD:                                         mdl_key->length())))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    lock= MDL_lock::create(mdl_key);
End Check: 2
LINE TO PARSE FOR KEYWORD:    lock= mdl_lock::create(mdl_key);
The real line: +    if (!lock || my_hash_insert(&m_locks, (uchar*)lock))
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (!lock || my_hash_insert(&m_locks, (uchar*)lock))
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      pthread_mutex_unlock(&m_mutex);
End Check: 3
LINE TO PARSE FOR KEYWORD:      pthread_mutex_unlock(&m_mutex);
The real line: +      MDL_lock::destroy(lock);
End Check: 3
LINE TO PARSE FOR KEYWORD:      mdl_lock::destroy(lock);
The real line: +      return NULL;
End Check: 3
LINE TO PARSE FOR KEYWORD:      return null;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (move_from_hash_to_lock_mutex(lock))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (move_from_hash_to_lock_mutex(lock))
The real line: +    goto retry;
End Check: 1
LINE TO PARSE FOR KEYWORD:    goto retry;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  return lock;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return lock;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
37 : 59
Next: (const MDL_key *mdl_key)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Find MDL_lock object corresponding to the key.
The real line: +
The real line: +  @retval non-NULL - MDL_lock instance for the key with locked
The real line: +                     MDL_lock::m_mutex.
The real line: +  @retval NULL     - There was no MDL_lock for the key.
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +MDL_lock* MDL_map::find(const MDL_key *mdl_key)
Current Name Search:     
LINE TO PARSE FOR KEYWORD:mdl_lock* mdl_map::find(const mdl_key *mdl_key)
Depths: 0:0
[]
The real line: +{
Current Name Search:     MDL_lock* MDL_map::find(const MDL_key *mdl_key) 
Checking if function:     MDL_lock* MDL_map::find(const MDL_key *mdl_key) {
PATTERN 4
Function: MDL_lock* MDL_map::find(const MDL_key *mdl_key) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  MDL_lock *lock;
End Check: 1
LINE TO PARSE FOR KEYWORD:  mdl_lock *lock;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +retry:
End Check: 1
LINE TO PARSE FOR KEYWORD:retry:
The real line: +  pthread_mutex_lock(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_lock(&m_mutex);
The real line: +  if (!(lock= (MDL_lock*) my_hash_search(&m_locks,
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(lock= (mdl_lock*) my_hash_search(&m_locks,
The real line: +                                         mdl_key->ptr(),
End Check: 1
LINE TO PARSE FOR KEYWORD:                                         mdl_key->ptr(),
The real line: +                                         mdl_key->length())))
End Check: 1
LINE TO PARSE FOR KEYWORD:                                         mdl_key->length())))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    pthread_mutex_unlock(&m_mutex);
End Check: 2
LINE TO PARSE FOR KEYWORD:    pthread_mutex_unlock(&m_mutex);
The real line: +    return NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return null;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (move_from_hash_to_lock_mutex(lock))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (move_from_hash_to_lock_mutex(lock))
The real line: +    goto retry;
End Check: 1
LINE TO PARSE FOR KEYWORD:    goto retry;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  return lock;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return lock;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
71 : 88
Next: (const MDL_key *mdl_key)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Release mdl_locks.m_mutex mutex and lock MDL_lock::m_mutex for lock
The real line: +  object from the hash. Handle situation when object was released
The real line: +  while the held no mutex.
The real line: +
The real line: +  @retval FALSE - Success.
The real line: +  @retval TRUE  - Object was released while we held no mutex, caller
The real line: +                  should re-try looking up MDL_lock object in the hash.
The real line:  */
The real line: -void MDL_context::init(THD *thd_arg)
Current Name Search:    
LINE TO PARSE FOR KEYWORD:void mdl_context::init(thd *thd_arg)
Depths: 0:0
[]
The real line: +bool MDL_map::move_from_hash_to_lock_mutex(MDL_lock *lock)
Current Name Search:    void MDL_context::init(THD *thd_arg) 
LINE TO PARSE FOR KEYWORD:bool mdl_map::move_from_hash_to_lock_mutex(mdl_lock *lock)
Depths: 0:0
[]
The real line:  {
Current Name Search:    void MDL_context::init(THD *thd_arg) bool MDL_map::move_from_hash_to_lock_mutex(MDL_lock *lock) 
Checking if function:    void MDL_context::init(THD *thd_arg) bool MDL_map::move_from_hash_to_lock_mutex(MDL_lock *lock)  {
PATTERN 1
Function:  bool MDL_map::move_from_hash_to_lock_mutex(MDL_lock *lock)  {
Depths: 1:0
[]
The real line: -  m_has_global_shared_lock= FALSE;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_has_global_shared_lock= false;
The real line: -  m_thd= thd_arg;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_thd= thd_arg;
The real line: -  m_lt_or_ha_sentinel= NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_lt_or_ha_sentinel= null;
The real line: +  DBUG_ASSERT(! lock->m_is_destroyed);
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_assert(! lock->m_is_destroyed);
The real line: +  safe_mutex_assert_owner(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  safe_mutex_assert_owner(&m_mutex);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line:    /*
End Check: 1
The real line: -    FIXME: In reset_n_backup_open_tables_state,
End Check: 1
LINE TO PARSE FOR KEYWORD:    fixme: in reset_n_backup_open_tables_state,
The real line: -    we abuse "init" as a reset, i.e. call it on an already
End Check: 1
LINE TO PARSE FOR KEYWORD:    we abuse  as a reset, i.e. call it on an already
The real line: -    constructed non-empty object. This is why we can't
End Check: 1
LINE TO PARSE FOR KEYWORD:    constructed non-empty object. this is why we can't
The real line: -    rely here on the default constructors of I_P_List
End Check: 1
LINE TO PARSE FOR KEYWORD:    rely here on the default constructors of i_p_list
The real line: -    to empty the list.
End Check: 1
LINE TO PARSE FOR KEYWORD:    to empty the list.
The real line: +    We increment m_ref_usage which is a reference counter protected by
The real line: +    mdl_locks.m_mutex under the condition it is present in the hash and
The real line: +    m_is_destroyed is FALSE.
The real line:    */
The real line: -  m_tickets.empty();
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_tickets.empty();
The real line: -  m_is_waiting_in_mdl= FALSE;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_is_waiting_in_mdl= false;
The real line: +  lock->m_ref_usage++;
End Check: 1
LINE TO PARSE FOR KEYWORD:  lock->m_ref_usage++;
The real line: +  pthread_mutex_unlock(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_unlock(&m_mutex);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  pthread_mutex_lock(&lock->m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_lock(&lock->m_mutex);
The real line: +  lock->m_ref_release++;
End Check: 1
LINE TO PARSE FOR KEYWORD:  lock->m_ref_release++;
The real line: +  if (unlikely(lock->m_is_destroyed))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (unlikely(lock->m_is_destroyed))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    /*
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +      Object was released while we held no mutex, we need to
The real line: +      release it if no others hold references to it, while our own
The real line: +      reference count ensured that the object as such haven't got
The real line: +      its memory released yet. We can also safely compare
The real line: +      m_ref_usage and m_ref_release since the object is no longer
The real line: +      present in the hash so no one will be able to find it and
The real line: +      increment m_ref_usage anymore.
The real line: +    */
The real line: +    uint ref_usage= lock->m_ref_usage;
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint ref_usage= lock->m_ref_usage;
The real line: +    uint ref_release= lock->m_ref_release;
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint ref_release= lock->m_ref_release;
The real line: +    pthread_mutex_unlock(&lock->m_mutex);
End Check: 2
LINE TO PARSE FOR KEYWORD:    pthread_mutex_unlock(&lock->m_mutex);
The real line: +    if (ref_usage == ref_release)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (ref_usage == ref_release)
The real line: +      MDL_lock::destroy(lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:      mdl_lock::destroy(lock);
The real line: +    return TRUE;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return true;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return FALSE;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return false;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
103 : 146
Next: (MDL_lock *lock)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Destroy MDL_lock object or delegate this responsibility to
The real line: +  whatever thread that holds the last outstanding reference to
The real line: +  it.
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void MDL_map::remove(MDL_lock *lock)
Current Name Search:     
LINE TO PARSE FOR KEYWORD:void mdl_map::remove(mdl_lock *lock)
Depths: 0:0
[]
The real line: +{
Current Name Search:     void MDL_map::remove(MDL_lock *lock) 
Checking if function:     void MDL_map::remove(MDL_lock *lock) {
PATTERN 4
Function: void MDL_map::remove(MDL_lock *lock) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint ref_usage, ref_release;
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint ref_usage, ref_release;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  safe_mutex_assert_owner(&lock->m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  safe_mutex_assert_owner(&lock->m_mutex);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (lock->cached_object)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (lock->cached_object)
The real line: +    (*lock->cached_object_release_hook)(lock->cached_object);
End Check: 1
LINE TO PARSE FOR KEYWORD:    (*lock->cached_object_release_hook)(lock->cached_object);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /*
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +    Destroy the MDL_lock object, but ensure that anyone that is
The real line: +    holding a reference to the object is not remaining, if so he
The real line: +    has the responsibility to release it.
The real line: +
The real line: +    Setting of m_is_destroyed to TRUE while holding _both_
The real line: +    mdl_locks.m_mutex and MDL_lock::m_mutex mutexes transfers the
The real line: +    protection of m_ref_usage from mdl_locks.m_mutex to
The real line: +    MDL_lock::m_mutex while removal of object from the hash makes
The real line: +    it read-only.  Therefore whoever acquires MDL_lock::m_mutex next
The real line: +    will see most up to date version of m_ref_usage.
The real line: +
The real line: +    This means that when m_is_destroyed is TRUE and we hold the
The real line: +    MDL_lock::m_mutex we can safely read the m_ref_usage
The real line: +    member.
The real line: +  */
The real line: +  pthread_mutex_lock(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_lock(&m_mutex);
The real line: +  my_hash_delete(&m_locks, (uchar*) lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:  my_hash_delete(&m_locks, (uchar*) lock);
The real line: +  lock->m_is_destroyed= TRUE;
End Check: 1
LINE TO PARSE FOR KEYWORD:  lock->m_is_destroyed= true;
The real line: +  ref_usage= lock->m_ref_usage;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ref_usage= lock->m_ref_usage;
The real line: +  ref_release= lock->m_ref_release;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ref_release= lock->m_ref_release;
The real line: +  pthread_mutex_unlock(&lock->m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_unlock(&lock->m_mutex);
The real line: +  pthread_mutex_unlock(&m_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_unlock(&m_mutex);
The real line: +  if (ref_usage == ref_release)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (ref_usage == ref_release)
The real line: +    MDL_lock::destroy(lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:    mdl_lock::destroy(lock);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
156 : 189
Next: (MDL_lock *lock)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Initialize a metadata locking context.
The real line: +
The real line: +  This is to be called when a new server connection is created.
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +MDL_context::MDL_context()
Current Name Search:     
LINE TO PARSE FOR KEYWORD:mdl_context::mdl_context()
Depths: 0:0
[]
The real line: +  :m_lt_or_ha_sentinel(NULL),
Current Name Search:     MDL_context::MDL_context() 
LINE TO PARSE FOR KEYWORD:  :m_lt_or_ha_sentinel(null),
Depths: 0:0
[]
The real line: +  m_thd(NULL)
Current Name Search:     MDL_context::MDL_context()   :m_lt_or_ha_sentinel(NULL), 
LINE TO PARSE FOR KEYWORD:  m_thd(null)
Depths: 0:0
[]
The real line: +{
Current Name Search:     MDL_context::MDL_context()   :m_lt_or_ha_sentinel(NULL),   m_thd(NULL) 
Checking if function:     MDL_context::MDL_context()   :m_lt_or_ha_sentinel(NULL),   m_thd(NULL) {
Other type of bracket:     MDL_context::MDL_context()   :m_lt_or_ha_sentinel(NULL),   m_thd(NULL) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
[]
The real line: +  pthread_cond_init(&m_ctx_wakeup_cond, NULL);
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  pthread_cond_init(&m_ctx_wakeup_cond, null);
Depths: 1:1
[]
The real line:  }
Current Name Search:   pthread_cond_init(&m_ctx_wakeup_cond, NULL); 
Depths: .0:1
[]
Adjusting depth.
Chunk End.
The real line: -bool MDL_ticket::has_pending_conflicting_lock_impl() const
Current Name Search: 
LINE TO PARSE FOR KEYWORD:bool mdl_ticket::has_pending_conflicting_lock_impl() const
Depths: 0:0
[]
The real line: -{
Current Name Search: bool MDL_ticket::has_pending_conflicting_lock_impl() const 
LINE TO PARSE FOR KEYWORD:{
Depths: 0:0
[]
The real line: -  DBUG_ASSERT(is_shared());
Current Name Search: bool MDL_ticket::has_pending_conflicting_lock_impl() const { 
LINE TO PARSE FOR KEYWORD:  dbug_assert(is_shared());
Depths: 0:0
[]
The real line: -  safe_mutex_assert_owner(&LOCK_mdl);
Current Name Search:   DBUG_ASSERT(is_shared()); 
LINE TO PARSE FOR KEYWORD:  safe_mutex_assert_owner(&lock_mdl);
Depths: 0:0
[]
The real line: -
Current Name Search:   safe_mutex_assert_owner(&LOCK_mdl); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -  return !m_lock->waiting.is_empty();
Current Name Search:   safe_mutex_assert_owner(&LOCK_mdl);  
LINE TO PARSE FOR KEYWORD:  return !m_lock->waiting.is_empty();
Depths: 0:0
[]
The real line: -}
Current Name Search:   return !m_lock->waiting.is_empty(); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:0
[]
The real line: -
Current Name Search:   return !m_lock->waiting.is_empty(); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -
Current Name Search:   return !m_lock->waiting.is_empty(); }  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -/**
Current Name Search:   return !m_lock->waiting.is_empty(); }   
LINE TO PARSE FOR KEYWORD:/**
Depths: 0:0
[]
The real line: -  Check if we have any pending exclusive locks which conflict with
Current Name Search:   return !m_lock->waiting.is_empty(); }   /** 
LINE TO PARSE FOR KEYWORD:  check if we have any pending exclusive locks which conflict with
Depths: 0:0
[]
The real line: -  existing shared lock.
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with 
LINE TO PARSE FOR KEYWORD:  existing shared lock.
Depths: 0:0
[]
The real line: -
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock. 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -  @pre The ticket must match an acquired lock.
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.  
LINE TO PARSE FOR KEYWORD:  @pre the ticket must match an acquired lock.
Depths: 0:0
[]
The real line: -
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock. 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -  @return TRUE if there is a pending conflicting lock request,
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.  
LINE TO PARSE FOR KEYWORD:  @return true if there is a pending conflicting lock request,
Depths: 0:0
[]
The real line: -          FALSE otherwise.
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.    @return TRUE if there is a pending conflicting lock request, 
LINE TO PARSE FOR KEYWORD:          false otherwise.
Depths: 0:0
[]
The real line: -*/
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.    @return TRUE if there is a pending conflicting lock request,           FALSE otherwise. 
LINE TO PARSE FOR KEYWORD:*/
Depths: 0:0
[]
The real line: -
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any peFnding exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.    @return TRUE if there is a pending conflicting lock request,           FALSE otherwise. */ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line:  bool MDL_ticket::has_pending_conflicting_lock() const
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.    @return TRUE if there is a pending conflicting lock request,           FALSE otherwise. */  
Depths: 0:0
[]
The real line:  {
Current Name Search:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.    @return TRUE if there is a pending conflicting lock request,           FALSE otherwise. */   bool MDL_ticket::has_pending_conflicting_lock() const 
Checking if function:   return !m_lock->waiting.is_empty(); }   /**   Check if we have any pending exclusive locks which conflict with   existing shared lock.    @pre The ticket must match an acquired lock.    @return TRUE if there is a pending conflicting lock request,           FALSE otherwise. */   bool MDL_ticket::has_pending_conflicting_lock() const  {
PATTERN 1
Function:  bool MDL_ticket::has_pending_conflicting_lock() {
Depths: 1:0
[]
The real line: -  bool result;
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool result;
The real line: -
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line:    safe_mutex_assert_not_owner(&LOCK_open);
End Check: 1
The real line: +  DBUG_ASSERT(is_shared());
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_assert(is_shared());
The real line: -  pthread_mutex_lock(&LOCK_mdl);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_lock(&lock_mdl);
The real line: -  result= has_pending_conflicting_lock_impl();
End Check: 1
LINE TO PARSE FOR KEYWORD:  result= has_pending_conflicting_lock_impl();
The real line: -  pthread_mutex_unlock(&LOCK_mdl);
End Check: 1
LINE TO PARSE FOR KEYWORD:  pthread_mutex_unlock(&lock_mdl);
The real line: -  return result;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return result;
The real line: +  return m_lock->has_pending_exclusive_lock();
End Check: 1
LINE TO PARSE FOR KEYWORD:  return m_lock->has_pending_exclusive_lock();
The real line:  }
End Check: 0
21 : 32
Next: ()
Chunk End.
The real line: +/* Copyright (C) 2000-2006 MySQL AB
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
The real line: +   This program is free software; you can redistribute it and/or modify
The real line: +   it under the terms of the GNU General Public License as published by
The real line: +   the Free Software Foundation; version 2 of the License.
The real line: +
The real line: +   This program is distributed in the hope that it will be useful,
The real line: +   but WITHOUT ANY WARRANTY; without even the implied warranty of
The real line: +   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
The real line: +   GNU General Public License for more details.
The real line: +
The real line: +   You should have received a copy of the GNU General Public License
The real line: +   along with this program; if not, write to the Free Software
The real line: +   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Functions to handle date and time */
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "sql_priv.h"
Current Name Search:      
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "unireg.h"                      // REQUIRED by other includes
Current Name Search:      #include  
LINE TO PARSE FOR KEYWORD:#include                       
Depths: 0:0
[]
The real line: +#include "sql_time.h"
Current Name Search:      #include  #include                        
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "tztime.h"                             // struct Time_zone
Current Name Search:      #include  #include                        #include  
LINE TO PARSE FOR KEYWORD:#include                              
Depths: 0:0
[]
The real line: +#include "sql_class.h"   // THD, MODE_INVALID_DATES, MODE_NO_ZERO_DATE
Current Name Search:      #include  #include                        #include  #include                               
LINE TO PARSE FOR KEYWORD:#include    
Depths: 0:0
[]
The real line: +#include <m_ctype.h>
Current Name Search:      #include  #include                        #include  #include                               #include     
LINE TO PARSE FOR KEYWORD:#include <m_ctype.h>
Depths: 0:0
[]
The real line: +
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	/* Some functions to calculate dates */
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   
LINE TO PARSE FOR KEYWORD:	
Depths: 0:0
[]
The real line: +
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifndef TESTTIME
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  
LINE TO PARSE FOR KEYWORD:#ifndef testtime
Depths: 0:0
[]
The real line: +
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  #ifndef TESTTIME 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  #ifndef TESTTIME  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Name description of interval names used in statements.
The real line: +
The real line: +  'interval_type_to_name' is ordered and sorted on interval size and
The real line: +  interval complexity.
The real line: +  Order of elements in 'interval_type_to_name' should correspond to 
The real line: +  the order of elements in 'interval_type' enum
The real line: +  
The real line: +  See also interval_type, interval_names
The real line: +*/
The real line: +
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  #ifndef TESTTIME   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +LEX_STRING interval_type_to_name[INTERVAL_LAST] = {
Current Name Search:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  #ifndef TESTTIME    
Checking if function:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  #ifndef TESTTIME    LEX_STRING interval_type_to_name[INTERVAL_LAST] = {
Other type of bracket:      #include  #include                        #include  #include                               #include     #include <m_ctype.h>   	  #ifndef TESTTIME    LEX_STRING interval_type_to_name[INTERVAL_LAST] = {
LINE TO PARSE FOR KEYWORD:lex_string interval_type_to_name[interval_last] = {
Depths: 1:1
[]
The real line: +  { C_STRING_WITH_LEN("YEAR")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("QUARTER")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("MONTH")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("WEEK")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("DAY")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("HOUR")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("MINUTE")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("SECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("MICROSECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("YEAR_MONTH")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("DAY_HOUR")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("DAY_MINUTE")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("DAY_SECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("HOUR_MINUTE")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("HOUR_SECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("MINUTE_SECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("DAY_MICROSECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("HOUR_MICROSECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("MINUTE_MICROSECOND")},
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()},
Depths: 1:2
[]
Adjusting depth.
The real line: +  { C_STRING_WITH_LEN("SECOND_MICROSECOND")}
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { c_string_with_len()}
Depths: 1:2
[]
Adjusting depth.
The real line: +}; 
Current Name Search: 
LINE TO PARSE FOR KEYWORD:}; 
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	/* Calc weekday from daynr */
Current Name Search: };   
LINE TO PARSE FOR KEYWORD:	
Depths: 0:0
[]
The real line: +	/* Returns 0 for monday, 1 for tuesday .... */
Current Name Search: };   	 
LINE TO PARSE FOR KEYWORD:	
Depths: 0:0
[]
The real line: +
Current Name Search: };   	 	 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +int calc_weekday(long daynr,bool sunday_first_day_of_week)
Current Name Search: };   	 	  
LINE TO PARSE FOR KEYWORD:int calc_weekday(long daynr,bool sunday_first_day_of_week)
Depths: 0:0
[]
The real line: +{
Current Name Search: };   	 	  int calc_weekday(long daynr,bool sunday_first_day_of_week) 
Checking if function: };   	 	  int calc_weekday(long daynr,bool sunday_first_day_of_week) {
PATTERN 1
Function:  int calc_weekday(long daynr,bool sunday_first_day_of_week) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  DBUG_ENTER("calc_weekday");
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_enter();
The real line: +  DBUG_RETURN ((int) ((daynr + 5L + (sunday_first_day_of_week ? 1L : 0L)) % 7));
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_return ((int) ((daynr + 5l + (sunday_first_day_of_week ? 1l : 0l)) % 7));
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
69 : 72
Next: (long daynr,bool sunday_first_day_of_week)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  The bits in week_format has the following meaning:
The real line: +   WEEK_MONDAY_FIRST (0)  If not set	Sunday is first day of week
The real line: +      		   	  If set	Monday is first day of week
The real line: +   WEEK_YEAR (1)	  If not set	Week is in range 0-53
The real line: +
The real line: +   	Week 0 is returned for the the last week of the previous year (for
The real line: +	a date at start of january) In this case one can get 53 for the
The real line: +	first week of next year.  This flag ensures that the week is
The real line: +	relevant for the given year. Note that this flag is only
The real line: +	releveant if WEEK_JANUARY is not set.
The real line: +
The real line: +			  If set	 Week is in range 1-53.
The real line: +
The real line: +	In this case one may get week 53 for a date in January (when
The real line: +	the week is that last week of previous year) and week 1 for a
The real line: +	date in December.
The real line: +
The real line: +  WEEK_FIRST_WEEKDAY (2)  If not set	Weeks are numbered according
The real line: +			   		to ISO 8601:1988
The real line: +			  If set	The week that contains the first
The real line: +					'first-day-of-week' is week 1.
The real line: +	
The real line: +	ISO 8601:1988 means that if the week containing January 1 has
The real line: +	four or more days in the new year, then it is week 1;
The real line: +	Otherwise it is the last week of the previous year, and the
The real line: +	next week is week 1.
The real line: +*/
The real line: +
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +uint calc_week(MYSQL_TIME *l_time, uint week_behaviour, uint *year)
Current Name Search:    
LINE TO PARSE FOR KEYWORD:uint calc_week(mysql_time *l_time, uint week_behaviour, uint *year)
Depths: 0:0
[]
The real line: +{
Current Name Search:    uint calc_week(MYSQL_TIME *l_time, uint week_behaviour, uint *year) 
Checking if function:    uint calc_week(MYSQL_TIME *l_time, uint week_behaviour, uint *year) {
PATTERN 4
Function: uint calc_week(MYSQL_TIME *l_time, uint week_behaviour, uint *year) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint days;
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint days;
The real line: +  ulong daynr=calc_daynr(l_time->year,l_time->month,l_time->day);
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulong daynr=calc_daynr(l_time->year,l_time->month,l_time->day);
The real line: +  ulong first_daynr=calc_daynr(l_time->year,1,1);
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulong first_daynr=calc_daynr(l_time->year,1,1);
The real line: +  bool monday_first= test(week_behaviour & WEEK_MONDAY_FIRST);
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool monday_first= test(week_behaviour & week_monday_first);
The real line: +  bool week_year= test(week_behaviour & WEEK_YEAR);
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool week_year= test(week_behaviour & week_year);
The real line: +  bool first_weekday= test(week_behaviour & WEEK_FIRST_WEEKDAY);
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool first_weekday= test(week_behaviour & week_first_weekday);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  uint weekday=calc_weekday(first_daynr, !monday_first);
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint weekday=calc_weekday(first_daynr, !monday_first);
The real line: +  *year=l_time->year;
End Check: 1
LINE TO PARSE FOR KEYWORD:  *year=l_time->year;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (l_time->month == 1 && l_time->day <= 7-weekday)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (l_time->month == 1 && l_time->day <= 7-weekday)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (!week_year && 
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (!week_year && 
The real line: +	((first_weekday && weekday != 0) ||
End Check: 2
LINE TO PARSE FOR KEYWORD:	((first_weekday && weekday != 0) ||
The real line: +	 (!first_weekday && weekday >= 4)))
End Check: 2
LINE TO PARSE FOR KEYWORD:	 (!first_weekday && weekday >= 4)))
The real line: +      return 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:      return 0;
The real line: +    week_year= 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    week_year= 1;
The real line: +    (*year)--;
End Check: 2
LINE TO PARSE FOR KEYWORD:    (*year)--;
The real line: +    first_daynr-= (days=calc_days_in_year(*year));
End Check: 2
LINE TO PARSE FOR KEYWORD:    first_daynr-= (days=calc_days_in_year(*year));
The real line: +    weekday= (weekday + 53*7- days) % 7;
End Check: 2
LINE TO PARSE FOR KEYWORD:    weekday= (weekday + 53*7- days) % 7;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if ((first_weekday && weekday != 0) ||
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((first_weekday && weekday != 0) ||
The real line: +      (!first_weekday && weekday >= 4))
End Check: 1
LINE TO PARSE FOR KEYWORD:      (!first_weekday && weekday >= 4))
The real line: +    days= daynr - (first_daynr+ (7-weekday));
End Check: 1
LINE TO PARSE FOR KEYWORD:    days= daynr - (first_daynr+ (7-weekday));
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +    days= daynr - (first_daynr - weekday);
End Check: 1
LINE TO PARSE FOR KEYWORD:    days= daynr - (first_daynr - weekday);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (week_year && days >= 52*7)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (week_year && days >= 52*7)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    weekday= (weekday + calc_days_in_year(*year)) % 7;
End Check: 2
LINE TO PARSE FOR KEYWORD:    weekday= (weekday + calc_days_in_year(*year)) % 7;
The real line: +    if ((!first_weekday && weekday < 4) ||
End Check: 2
LINE TO PARSE FOR KEYWORD:    if ((!first_weekday && weekday < 4) ||
The real line: +	(first_weekday && weekday == 0))
End Check: 2
LINE TO PARSE FOR KEYWORD:	(first_weekday && weekday == 0))
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      (*year)++;
End Check: 3
LINE TO PARSE FOR KEYWORD:      (*year)++;
The real line: +      return 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:      return 1;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return days/7+1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return days/7+1;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
104 : 144
Next: (MYSQL_TIME *l_time, uint week_behaviour, uint *year)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	/* Change a daynr to year, month and day */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:	
Depths: 0:0
[]
The real line: +	/* Daynr 0 is returned as date 00.00.00 */
Current Name Search:  	 
LINE TO PARSE FOR KEYWORD:	
Depths: 0:0
[]
The real line: +
Current Name Search:  	 	 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void get_date_from_daynr(long daynr,uint *ret_year,uint *ret_month,
Current Name Search:  	 	  
LINE TO PARSE FOR KEYWORD:void get_date_from_daynr(long daynr,uint *ret_year,uint *ret_month,
Depths: 0:0
[]
The real line: +			 uint *ret_day)
Current Name Search:  	 	  void get_date_from_daynr(long daynr,uint *ret_year,uint *ret_month, 
LINE TO PARSE FOR KEYWORD:			 uint *ret_day)
Depths: 0:0
[]
The real line: +{
Current Name Search:  	 	  void get_date_from_daynr(long daynr,uint *ret_year,uint *ret_month, 			 uint *ret_day) 
Checking if function:  	 	  void get_date_from_daynr(long daynr,uint *ret_year,uint *ret_month, 			 uint *ret_day) {
PATTERN 4
Function: void get_date_from_daynr(long daynr,uint *ret_year,uint *ret_month,  uint *ret_day) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint year,temp,leap_day,day_of_year,days_in_year;
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint year,temp,leap_day,day_of_year,days_in_year;
The real line: +  uchar *month_pos;
End Check: 1
LINE TO PARSE FOR KEYWORD:  uchar *month_pos;
The real line: +  DBUG_ENTER("get_date_from_daynr");
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_enter();
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (daynr <= 365L || daynr >= 3652500)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (daynr <= 365l || daynr >= 3652500)
The real line: +  {						/* Fix if wrong daynr */
End Check: 2
LINE TO PARSE FOR KEYWORD:  {						
The real line: +    *ret_year= *ret_month = *ret_day =0;
End Check: 2
LINE TO PARSE FOR KEYWORD:    *ret_year= *ret_month = *ret_day =0;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    year= (uint) (daynr*100 / 36525L);
End Check: 2
LINE TO PARSE FOR KEYWORD:    year= (uint) (daynr*100 / 36525l);
The real line: +    temp=(((year-1)/100+1)*3)/4;
End Check: 2
LINE TO PARSE FOR KEYWORD:    temp=(((year-1)/100+1)*3)/4;
The real line: +    day_of_year=(uint) (daynr - (long) year * 365L) - (year-1)/4 +temp;
End Check: 2
LINE TO PARSE FOR KEYWORD:    day_of_year=(uint) (daynr - (long) year * 365l) - (year-1)/4 +temp;
The real line: +    while (day_of_year > (days_in_year= calc_days_in_year(year)))
End Check: 2
LINE TO PARSE FOR KEYWORD:    while (day_of_year > (days_in_year= calc_days_in_year(year)))
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      day_of_year-=days_in_year;
End Check: 3
LINE TO PARSE FOR KEYWORD:      day_of_year-=days_in_year;
The real line: +      (year)++;
End Check: 3
LINE TO PARSE FOR KEYWORD:      (year)++;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    leap_day=0;
End Check: 2
LINE TO PARSE FOR KEYWORD:    leap_day=0;
The real line: +    if (days_in_year == 366)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (days_in_year == 366)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      if (day_of_year > 31+28)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (day_of_year > 31+28)
The real line: +      {
End Check: 4
LINE TO PARSE FOR KEYWORD:      {
The real line: +	day_of_year--;
End Check: 4
LINE TO PARSE FOR KEYWORD:	day_of_year--;
The real line: +	if (day_of_year == 31+28)
End Check: 4
LINE TO PARSE FOR KEYWORD:	if (day_of_year == 31+28)
The real line: +	  leap_day=1;		/* Handle leapyears leapday */
End Check: 4
LINE TO PARSE FOR KEYWORD:	  leap_day=1;		
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    *ret_month=1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    *ret_month=1;
The real line: +    for (month_pos= days_in_month ;
End Check: 2
LINE TO PARSE FOR KEYWORD:    for (month_pos= days_in_month ;
The real line: +	 day_of_year > (uint) *month_pos ;
End Check: 2
LINE TO PARSE FOR KEYWORD:	 day_of_year > (uint) *month_pos ;
The real line: +	 day_of_year-= *(month_pos++), (*ret_month)++)
End Check: 2
LINE TO PARSE FOR KEYWORD:	 day_of_year-= *(month_pos++), (*ret_month)++)
The real line: +      ;
End Check: 2
LINE TO PARSE FOR KEYWORD:      ;
The real line: +    *ret_year=year;
End Check: 2
LINE TO PARSE FOR KEYWORD:    *ret_year=year;
The real line: +    *ret_day=day_of_year+leap_day;
End Check: 2
LINE TO PARSE FOR KEYWORD:    *ret_day=day_of_year+leap_day;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  DBUG_VOID_RETURN;
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_void_return;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
151 : 189
Next: (long daynr,uint *ret_year,uint *ret_month,  uint *ret_day)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	/* Functions to handle periods */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:	
Depths: 0:0
[]
The real line: +
Current Name Search:  	 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +ulong convert_period_to_month(ulong period)
Current Name Search:  	  
LINE TO PARSE FOR KEYWORD:ulong convert_period_to_month(ulong period)
Depths: 0:0
[]
The real line: +{
Current Name Search:  	  ulong convert_period_to_month(ulong period) 
Checking if function:  	  ulong convert_period_to_month(ulong period) {
PATTERN 4
Function: ulong convert_period_to_month(ulong period) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  ulong a,b;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulong a,b;
The real line: +  if (period == 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (period == 0)
The real line: +    return 0L;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 0l;
The real line: +  if ((a=period/100) < YY_PART_YEAR)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((a=period/100) < yy_part_year)
The real line: +    a+=2000;
End Check: 1
LINE TO PARSE FOR KEYWORD:    a+=2000;
The real line: +  else if (a < 100)
End Check: 1
LINE TO PARSE FOR KEYWORD:  else if (a < 100)
The real line: +    a+=1900;
End Check: 1
LINE TO PARSE FOR KEYWORD:    a+=1900;
The real line: +  b=period%100;
End Check: 1
LINE TO PARSE FOR KEYWORD:  b=period%100;
The real line: +  return a*12+b-1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return a*12+b-1;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
194 : 204
Next: (ulong period)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +ulong convert_month_to_period(ulong month)
Current Name Search:   
LINE TO PARSE FOR KEYWORD:ulong convert_month_to_period(ulong month)
Depths: 0:0
[]
The real line: +{
Current Name Search:   ulong convert_month_to_period(ulong month) 
Checking if function:   ulong convert_month_to_period(ulong month) {
PATTERN 4
Function: ulong convert_month_to_period(ulong month) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  ulong year;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulong year;
The real line: +  if (month == 0L)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (month == 0l)
The real line: +    return 0L;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 0l;
The real line: +  if ((year=month/12) < 100)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((year=month/12) < 100)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    year+=(year < YY_PART_YEAR) ? 2000 : 1900;
End Check: 2
LINE TO PARSE FOR KEYWORD:    year+=(year < yy_part_year) ? 2000 : 1900;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return year*100+month%12+1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return year*100+month%12+1;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
208 : 217
Next: (ulong month)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Convert a string to 8-bit representation,
The real line: +  for use in str_to_time/str_to_date/str_to_date.
The real line: +  
The real line: +  In the future to_ascii() can be extended to convert
The real line: +  non-ASCII digits to ASCII digits
The real line: +  (for example, ARABIC-INDIC, DEVANAGARI, BENGALI, and so on)
The real line: +  so DATE/TIME/DATETIME values understand digits in the
The real line: +  respected scripts.
The real line: +*/
The real line: +static uint
Current Name Search:    
LINE TO PARSE FOR KEYWORD:static uint
Depths: 0:0
[]
The real line: +to_ascii(CHARSET_INFO *cs,
Current Name Search:    static uint 
LINE TO PARSE FOR KEYWORD:to_ascii(charset_info *cs,
Depths: 0:0
[]
The real line: +         const char *src, uint src_length,
Current Name Search:    static uint to_ascii(CHARSET_INFO *cs, 
LINE TO PARSE FOR KEYWORD:         const char *src, uint src_length,
Depths: 0:0
[]
The real line: +         char *dst, uint dst_length)
Current Name Search:    static uint to_ascii(CHARSET_INFO *cs,          const char *src, uint src_length, 
LINE TO PARSE FOR KEYWORD:         char *dst, uint dst_length)
Depths: 0:0
[]
The real line: +                     
Current Name Search:    static uint to_ascii(CHARSET_INFO *cs,          const char *src, uint src_length,          char *dst, uint dst_length) 
LINE TO PARSE FOR KEYWORD:                     
Depths: 0:0
[]
The real line: +{
Current Name Search:    static uint to_ascii(CHARSET_INFO *cs,          const char *src, uint src_length,          char *dst, uint dst_length)                       
Checking if function:    static uint to_ascii(CHARSET_INFO *cs,          const char *src, uint src_length,          char *dst, uint dst_length)                       {
PATTERN 1
Function:  uint to_ascii(CHARSET_INFO *cs,         char *src, uint src_length,          char *dst, uint dst_length)                       {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  int cnvres;
End Check: 1
LINE TO PARSE FOR KEYWORD:  int cnvres;
The real line: +  my_wc_t wc;
End Check: 1
LINE TO PARSE FOR KEYWORD:  my_wc_t wc;
The real line: +  const char *srcend= src + src_length;
End Check: 1
LINE TO PARSE FOR KEYWORD:  const char *srcend= src + src_length;
The real line: +  char *dst0= dst, *dstend= dst + dst_length - 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  char *dst0= dst, *dstend= dst + dst_length - 1;
The real line: +  while (dst < dstend &&
End Check: 1
LINE TO PARSE FOR KEYWORD:  while (dst < dstend &&
The real line: +         (cnvres= (cs->cset->mb_wc)(cs, &wc,
End Check: 1
LINE TO PARSE FOR KEYWORD:         (cnvres= (cs->cset->mb_wc)(cs, &wc,
The real line: +                                    (const uchar*) src,
End Check: 1
LINE TO PARSE FOR KEYWORD:                                    (const uchar*) src,
The real line: +                                    (const uchar*) srcend)) > 0 &&
End Check: 1
LINE TO PARSE FOR KEYWORD:                                    (const uchar*) srcend)) > 0 &&
The real line: +         wc < 128)
End Check: 1
LINE TO PARSE FOR KEYWORD:         wc < 128)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    src+= cnvres;
End Check: 2
LINE TO PARSE FOR KEYWORD:    src+= cnvres;
The real line: +    *dst++= wc;
End Check: 2
LINE TO PARSE FOR KEYWORD:    *dst++= wc;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  *dst= '\0';
End Check: 1
LINE TO PARSE FOR KEYWORD:  *dst= ;
The real line: +  return dst - dst0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return dst - dst0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
235 : 251
Next: (CHARSET_INFO *cs,         char *src, uint src_length,          char *dst, uint dst_length)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Character set-aware version of str_to_time() */
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool str_to_time(CHARSET_INFO *cs, const char *str,uint length,
Current Name Search:    
LINE TO PARSE FOR KEYWORD:bool str_to_time(charset_info *cs, const char *str,uint length,
Depths: 0:0
[]
The real line: +                 MYSQL_TIME *l_time, int *warning)
Current Name Search:    bool str_to_time(CHARSET_INFO *cs, const char *str,uint length, 
LINE TO PARSE FOR KEYWORD:                 mysql_time *l_time, int *warning)
Depths: 0:0
[]
The real line: +{
Current Name Search:    bool str_to_time(CHARSET_INFO *cs, const char *str,uint length,                  MYSQL_TIME *l_time, int *warning) 
Checking if function:    bool str_to_time(CHARSET_INFO *cs, const char *str,uint length,                  MYSQL_TIME *l_time, int *warning) {
PATTERN 4
Function: bool str_to_time(CHARSET_INFO *cs,char *str,uint length,                  MYSQL_TIME *l_time, int *warning) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  char cnv[32];
End Check: 1
LINE TO PARSE FOR KEYWORD:  char cnv[32];
The real line: +  if ((cs->state & MY_CS_NONASCII) != 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((cs->state & my_cs_nonascii) != 0)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    length= to_ascii(cs, str, length, cnv, sizeof(cnv));
End Check: 2
LINE TO PARSE FOR KEYWORD:    length= to_ascii(cs, str, length, cnv, sizeof(cnv));
The real line: +    str= cnv;
End Check: 2
LINE TO PARSE FOR KEYWORD:    str= cnv;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return str_to_time(str, length, l_time, warning);
End Check: 1
LINE TO PARSE FOR KEYWORD:  return str_to_time(str, length, l_time, warning);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
257 : 265
Next: (CHARSET_INFO *cs,char *str,uint length,                  MYSQL_TIME *l_time, int *warning)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Character set-aware version of str_to_datetime() */
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +timestamp_type str_to_datetime(CHARSET_INFO *cs,
Current Name Search:    
LINE TO PARSE FOR KEYWORD:timestamp_type str_to_datetime(charset_info *cs,
Depths: 0:0
[]
The real line: +                               const char *str, uint length,
Current Name Search:    timestamp_type str_to_datetime(CHARSET_INFO *cs, 
LINE TO PARSE FOR KEYWORD:                               const char *str, uint length,
Depths: 0:0
[]
The real line: +                               MYSQL_TIME *l_time, uint flags, int *was_cut)
Current Name Search:    timestamp_type str_to_datetime(CHARSET_INFO *cs,                                const char *str, uint length, 
LINE TO PARSE FOR KEYWORD:                               mysql_time *l_time, uint flags, int *was_cut)
Depths: 0:0
[]
The real line: +{
Current Name Search:    timestamp_type str_to_datetime(CHARSET_INFO *cs,                                const char *str, uint length,                                MYSQL_TIME *l_time, uint flags, int *was_cut) 
Checking if function:    timestamp_type str_to_datetime(CHARSET_INFO *cs,                                const char *str, uint length,                                MYSQL_TIME *l_time, uint flags, int *was_cut) {
PATTERN 4
Function: timestamp_type str_to_datetime(CHARSET_INFO *cs,                               char *str, uint length,                                MYSQL_TIME *l_time, uint flags, int *was_cut) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  char cnv[32];
End Check: 1
LINE TO PARSE FOR KEYWORD:  char cnv[32];
The real line: +  if ((cs->state & MY_CS_NONASCII) != 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((cs->state & my_cs_nonascii) != 0)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    length= to_ascii(cs, str, length, cnv, sizeof(cnv));
End Check: 2
LINE TO PARSE FOR KEYWORD:    length= to_ascii(cs, str, length, cnv, sizeof(cnv));
The real line: +    str= cnv;
End Check: 2
LINE TO PARSE FOR KEYWORD:    str= cnv;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return str_to_datetime(str, length, l_time, flags, was_cut);
End Check: 1
LINE TO PARSE FOR KEYWORD:  return str_to_datetime(str, length, l_time, flags, was_cut);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
272 : 280
Next: (CHARSET_INFO *cs,                               char *str, uint length,                                MYSQL_TIME *l_time, uint flags, int *was_cut)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Convert a timestamp string to a MYSQL_TIME value and produce a warning 
The real line: +  if string was truncated during conversion.
The real line: +
The real line: +  NOTE
The real line: +    See description of str_to_datetime() for more information.
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +timestamp_type
Current Name Search:     
LINE TO PARSE FOR KEYWORD:timestamp_type
Depths: 0:0
[]
The real line: +str_to_datetime_with_warn(CHARSET_INFO *cs,
Current Name Search:     timestamp_type 
LINE TO PARSE FOR KEYWORD:str_to_datetime_with_warn(charset_info *cs,
Depths: 0:0
[]
The real line: +                          const char *str, uint length, MYSQL_TIME *l_time,
Current Name Search:     timestamp_type str_to_datetime_with_warn(CHARSET_INFO *cs, 
LINE TO PARSE FOR KEYWORD:                          const char *str, uint length, mysql_time *l_time,
Depths: 0:0
[]
The real line: +                          uint flags)
Current Name Search:     timestamp_type str_to_datetime_with_warn(CHARSET_INFO *cs,                           const char *str, uint length, MYSQL_TIME *l_time, 
LINE TO PARSE FOR KEYWORD:                          uint flags)
Depths: 0:0
[]
The real line: +{
Current Name Search:     timestamp_type str_to_datetime_with_warn(CHARSET_INFO *cs,                           const char *str, uint length, MYSQL_TIME *l_time,                           uint flags) 
Checking if function:     timestamp_type str_to_datetime_with_warn(CHARSET_INFO *cs,                           const char *str, uint length, MYSQL_TIME *l_time,                           uint flags) {
PATTERN 4
Function: timestamp_type str_to_datetime_with_warn(CHARSET_INFO *cs,                          char *str, uint length, MYSQL_TIME *l_time,                           uint flags) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  int was_cut;
End Check: 1
LINE TO PARSE FOR KEYWORD:  int was_cut;
The real line: +  THD *thd= current_thd;
End Check: 1
LINE TO PARSE FOR KEYWORD:  thd *thd= current_thd;
The real line: +  timestamp_type ts_type;
End Check: 1
LINE TO PARSE FOR KEYWORD:  timestamp_type ts_type;
The real line: +  
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  ts_type= str_to_datetime(cs, str, length, l_time,
End Check: 1
LINE TO PARSE FOR KEYWORD:  ts_type= str_to_datetime(cs, str, length, l_time,
The real line: +                           (flags | (thd->variables.sql_mode &
End Check: 1
LINE TO PARSE FOR KEYWORD:                           (flags | (thd->variables.sql_mode &
The real line: +                                     (MODE_INVALID_DATES |
End Check: 1
LINE TO PARSE FOR KEYWORD:                                     (mode_invalid_dates |
The real line: +                                      MODE_NO_ZERO_DATE))),
End Check: 1
LINE TO PARSE FOR KEYWORD:                                      mode_no_zero_date))),
The real line: +                           &was_cut);
End Check: 1
LINE TO PARSE FOR KEYWORD:                           &was_cut);
The real line: +  if (was_cut || ts_type <= MYSQL_TIMESTAMP_ERROR)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (was_cut || ts_type <= mysql_timestamp_error)
The real line: +    make_truncated_value_warning(current_thd, MYSQL_ERROR::WARN_LEVEL_WARN,
End Check: 1
LINE TO PARSE FOR KEYWORD:    make_truncated_value_warning(current_thd, mysql_error::warn_level_warn,
The real line: +                                 str, length, ts_type,  NullS);
End Check: 1
LINE TO PARSE FOR KEYWORD:                                 str, length, ts_type,  nulls);
The real line: +  return ts_type;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return ts_type;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
295 : 309
Next: (CHARSET_INFO *cs,                          char *str, uint length, MYSQL_TIME *l_time,                           uint flags)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Convert a datetime from broken-down MYSQL_TIME representation to corresponding 
The real line: +  TIMESTAMP value.
The real line: +
The real line: +  SYNOPSIS
The real line: +    TIME_to_timestamp()
The real line: +      thd             - current thread
The real line: +      t               - datetime in broken-down representation, 
The real line: +      in_dst_time_gap - pointer to bool which is set to true if t represents
The real line: +                        value which doesn't exists (falls into the spring 
The real line: +                        time-gap) or to false otherwise.
The real line: +   
The real line: +  RETURN
The real line: +     Number seconds in UTC since start of Unix Epoch corresponding to t.
The real line: +     0 - t contains datetime value which is out of TIMESTAMP range.
The real line: +     
The real line: +*/
The real line: +my_time_t TIME_to_timestamp(THD *thd, const MYSQL_TIME *t, my_bool *in_dst_time_gap)
Current Name Search:    
LINE TO PARSE FOR KEYWORD:my_time_t time_to_timestamp(thd *thd, const mysql_time *t, my_bool *in_dst_time_gap)
Depths: 0:0
[]
The real line: +{
Current Name Search:    my_time_t TIME_to_timestamp(THD *thd, const MYSQL_TIME *t, my_bool *in_dst_time_gap) 
Checking if function:    my_time_t TIME_to_timestamp(THD *thd, const MYSQL_TIME *t, my_bool *in_dst_time_gap) {
PATTERN 4
Function: my_time_t TIME_to_timestamp(THD *thd,MYSQL_TIME *t, my_bool *in_dst_time_gap) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  my_time_t timestamp;
End Check: 1
LINE TO PARSE FOR KEYWORD:  my_time_t timestamp;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  *in_dst_time_gap= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  *in_dst_time_gap= 0;
The real line: +  thd->time_zone_used= 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  thd->time_zone_used= 1;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  timestamp= thd->variables.time_zone->TIME_to_gmt_sec(t, in_dst_time_gap);
End Check: 1
LINE TO PARSE FOR KEYWORD:  timestamp= thd->variables.time_zone->time_to_gmt_sec(t, in_dst_time_gap);
The real line: +  if (timestamp)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (timestamp)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    return timestamp;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return timestamp;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /* If we are here we have range error. */
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  return(0);
End Check: 1
LINE TO PARSE FOR KEYWORD:  return(0);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
330 : 344
Next: (THD *thd,MYSQL_TIME *t, my_bool *in_dst_time_gap)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Convert a time string to a MYSQL_TIME struct and produce a warning
The real line: +  if string was cut during conversion.
The real line: +
The real line: +  NOTE
The real line: +    See str_to_time() for more info.
The real line: +*/
The real line: +bool
Current Name Search:    
LINE TO PARSE FOR KEYWORD:bool
Depths: 0:0
[]
The real line: +str_to_time_with_warn(CHARSET_INFO *cs,
Current Name Search:    bool 
LINE TO PARSE FOR KEYWORD:str_to_time_with_warn(charset_info *cs,
Depths: 0:0
[]
The real line: +                      const char *str, uint length, MYSQL_TIME *l_time)
Current Name Search:    bool str_to_time_with_warn(CHARSET_INFO *cs, 
LINE TO PARSE FOR KEYWORD:                      const char *str, uint length, mysql_time *l_time)
Depths: 0:0
[]
The real line: +{
Current Name Search:    bool str_to_time_with_warn(CHARSET_INFO *cs,                       const char *str, uint length, MYSQL_TIME *l_time) 
Checking if function:    bool str_to_time_with_warn(CHARSET_INFO *cs,                       const char *str, uint length, MYSQL_TIME *l_time) {
PATTERN 4
Function: bool str_to_time_with_warn(CHARSET_INFO *cs,                      char *str, uint length, MYSQL_TIME *l_time) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  int warning;
End Check: 1
LINE TO PARSE FOR KEYWORD:  int warning;
The real line: +  bool ret_val= str_to_time(str, length, l_time, &warning);
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool ret_val= str_to_time(str, length, l_time, &warning);
The real line: +  if (ret_val || warning)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (ret_val || warning)
The real line: +    make_truncated_value_warning(current_thd, MYSQL_ERROR::WARN_LEVEL_WARN,
End Check: 1
LINE TO PARSE FOR KEYWORD:    make_truncated_value_warning(current_thd, mysql_error::warn_level_warn,
The real line: +                                 str, length, MYSQL_TIMESTAMP_TIME, NullS);
End Check: 1
LINE TO PARSE FOR KEYWORD:                                 str, length, mysql_timestamp_time, nulls);
The real line: +  return ret_val;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return ret_val;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
357 : 364
Next: (CHARSET_INFO *cs,                      char *str, uint length, MYSQL_TIME *l_time)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Convert a system time structure to TIME
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void localtime_to_TIME(MYSQL_TIME *to, struct tm *from)
Current Name Search:     
LINE TO PARSE FOR KEYWORD:void localtime_to_time(mysql_time *to, struct tm *from)
Depths: 0:0
[]
The real line: +{
Current Name Search:     void localtime_to_TIME(MYSQL_TIME *to, struct tm *from) 
Checking if function:     void localtime_to_TIME(MYSQL_TIME *to, struct tm *from) {
PATTERN 4
Function: void localtime_to_TIME(MYSQL_TIME *to, struct tm *from) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  to->neg=0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->neg=0;
The real line: +  to->second_part=0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->second_part=0;
The real line: +  to->year=	(int) ((from->tm_year+1900) % 10000);
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->year=	(int) ((from->tm_year+1900) % 10000);
The real line: +  to->month=	(int) from->tm_mon+1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->month=	(int) from->tm_mon+1;
The real line: +  to->day=	(int) from->tm_mday;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->day=	(int) from->tm_mday;
The real line: +  to->hour=	(int) from->tm_hour;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->hour=	(int) from->tm_hour;
The real line: +  to->minute=	(int) from->tm_min;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->minute=	(int) from->tm_min;
The real line: +  to->second=   (int) from->tm_sec;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->second=   (int) from->tm_sec;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
372 : 381
Next: (MYSQL_TIME *to, struct tm *from)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void calc_time_from_sec(MYSQL_TIME *to, long seconds, long microseconds)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void calc_time_from_sec(mysql_time *to, long seconds, long microseconds)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void calc_time_from_sec(MYSQL_TIME *to, long seconds, long microseconds) 
Checking if function:  void calc_time_from_sec(MYSQL_TIME *to, long seconds, long microseconds) {
PATTERN 4
Function: void calc_time_from_sec(MYSQL_TIME *to, long seconds, long microseconds) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  long t_seconds;
End Check: 1
LINE TO PARSE FOR KEYWORD:  long t_seconds;
The real line: +  // to->neg is not cleared, it may already be set to a useful value
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  to->time_type= MYSQL_TIMESTAMP_TIME;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->time_type= mysql_timestamp_time;
The real line: +  to->year= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->year= 0;
The real line: +  to->month= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->month= 0;
The real line: +  to->day= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->day= 0;
The real line: +  to->hour= seconds/3600L;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->hour= seconds/3600l;
The real line: +  t_seconds= seconds%3600L;
End Check: 1
LINE TO PARSE FOR KEYWORD:  t_seconds= seconds%3600l;
The real line: +  to->minute= t_seconds/60L;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->minute= t_seconds/60l;
The real line: +  to->second= t_seconds%60L;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->second= t_seconds%60l;
The real line: +  to->second_part= microseconds;
End Check: 1
LINE TO PARSE FOR KEYWORD:  to->second_part= microseconds;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
384 : 396
Next: (MYSQL_TIME *to, long seconds, long microseconds)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Parse a format string specification
The real line: +
The real line: +  SYNOPSIS
The real line: +    parse_date_time_format()
The real line: +    format_type		Format of string (time, date or datetime)
The real line: +    format_str		String to parse
The real line: +    format_length	Length of string
The real line: +    date_time_format	Format to fill in
The real line: +
The real line: +  NOTES
The real line: +    Fills in date_time_format->positions for all date time parts.
The real line: +
The real line: +    positions marks the position for a datetime element in the format string.
The real line: +    The position array elements are in the following order:
The real line: +    YYYY-DD-MM HH-MM-DD.FFFFFF AM
The real line: +    0    1  2  3  4  5  6      7
The real line: +
The real line: +    If positions[0]= 5, it means that year will be the forth element to
The real line: +    read from the parsed date string.
The real line: +
The real line: +  RETURN
The real line: +    0	ok
The real line: +    1	error
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool parse_date_time_format(timestamp_type format_type, 
Current Name Search:     
LINE TO PARSE FOR KEYWORD:bool parse_date_time_format(timestamp_type format_type, 
Depths: 0:0
[]
The real line: +			    const char *format, uint format_length,
Current Name Search:     bool parse_date_time_format(timestamp_type format_type,  
LINE TO PARSE FOR KEYWORD:			    const char *format, uint format_length,
Depths: 0:0
[]
The real line: +			    DATE_TIME_FORMAT *date_time_format)
Current Name Search:     bool parse_date_time_format(timestamp_type format_type,  			    const char *format, uint format_length, 
LINE TO PARSE FOR KEYWORD:			    date_time_format *date_time_format)
Depths: 0:0
[]
The real line: +{
Current Name Search:     bool parse_date_time_format(timestamp_type format_type,  			    const char *format, uint format_length, 			    DATE_TIME_FORMAT *date_time_format) 
Checking if function:     bool parse_date_time_format(timestamp_type format_type,  			    const char *format, uint format_length, 			    DATE_TIME_FORMAT *date_time_format) {
PATTERN 4
Function: bool parse_date_time_format(timestamp_type format_type,     char *format, uint format_length,     DATE_TIME_FORMAT *date_time_format) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint offset= 0, separators= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint offset= 0, separators= 0;
The real line: +  const char *ptr= format, *format_str;
End Check: 1
LINE TO PARSE FOR KEYWORD:  const char *ptr= format, *format_str;
The real line: +  const char *end= ptr+format_length;
End Check: 1
LINE TO PARSE FOR KEYWORD:  const char *end= ptr+format_length;
The real line: +  uchar *dt_pos= date_time_format->positions;
End Check: 1
LINE TO PARSE FOR KEYWORD:  uchar *dt_pos= date_time_format->positions;
The real line: +  /* need_p is set if we are using AM/PM format */
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  bool need_p= 0, allow_separator= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool need_p= 0, allow_separator= 0;
The real line: +  ulong part_map= 0, separator_map= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulong part_map= 0, separator_map= 0;
The real line: +  const char *parts[16];
End Check: 1
LINE TO PARSE FOR KEYWORD:  const char *parts[16];
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  date_time_format->time_separator= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  date_time_format->time_separator= 0;
The real line: +  date_time_format->flag= 0;			// For future
End Check: 1
LINE TO PARSE FOR KEYWORD:  date_time_format->flag= 0;			
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /*
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +    Fill position with 'dummy' arguments to found out if a format tag is
The real line: +    used twice (This limit's the format to 255 characters, but this is ok)
The real line: +  */
The real line: +  dt_pos[0]= dt_pos[1]= dt_pos[2]= dt_pos[3]=
End Check: 1
LINE TO PARSE FOR KEYWORD:  dt_pos[0]= dt_pos[1]= dt_pos[2]= dt_pos[3]=
The real line: +    dt_pos[4]= dt_pos[5]= dt_pos[6]= dt_pos[7]= 255;
End Check: 1
LINE TO PARSE FOR KEYWORD:    dt_pos[4]= dt_pos[5]= dt_pos[6]= dt_pos[7]= 255;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  for (; ptr != end; ptr++)
End Check: 1
LINE TO PARSE FOR KEYWORD:  for (; ptr != end; ptr++)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (*ptr == '%' && ptr+1 != end)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (*ptr ==  && ptr+1 != end)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      uint position;
End Check: 3
LINE TO PARSE FOR KEYWORD:      uint position;
The real line: +      LINT_INIT(position);
End Check: 3
LINE TO PARSE FOR KEYWORD:      lint_init(position);
The real line: +      switch (*++ptr) {
End Check: 4
LINE TO PARSE FOR KEYWORD:      switch (*++ptr) {
The real line: +      case 'y':					// Year
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :					
The real line: +      case 'Y':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 0;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 0;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 'c':					// Month
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :					
The real line: +      case 'm':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 1;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 1;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 'd':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +      case 'e':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 2;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 2;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 'h':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +      case 'I':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +      case 'l':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	need_p= 1;				// Need AM/PM
End Check: 4
LINE TO PARSE FOR KEYWORD:	need_p= 1;				
The real line: +	/* Fall through */
End Check: 4
LINE TO PARSE FOR KEYWORD:	
The real line: +      case 'k':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +      case 'H':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 3;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 3;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 'i':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 4;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 4;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 's':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +      case 'S':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 5;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 5;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 'f':
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :
The real line: +	position= 6;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 6;
The real line: +	if (dt_pos[5] != offset-1 || ptr[-2] != '.')
End Check: 4
LINE TO PARSE FOR KEYWORD:	if (dt_pos[5] != offset-1 || ptr[-2] != )
The real line: +	  return 1;				// Wrong usage of %f
End Check: 4
LINE TO PARSE FOR KEYWORD:	  return 1;				
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      case 'p':					// AM/PM
End Check: 4
LINE TO PARSE FOR KEYWORD:      case :					
The real line: +	if (offset == 0)			// Can't be first
End Check: 4
LINE TO PARSE FOR KEYWORD:	if (offset == 0)			
The real line: +	  return 0;
End Check: 4
LINE TO PARSE FOR KEYWORD:	  return 0;
The real line: +	position= 7;
End Check: 4
LINE TO PARSE FOR KEYWORD:	position= 7;
The real line: +	break;
End Check: 4
LINE TO PARSE FOR KEYWORD:	break;
The real line: +      default:
End Check: 4
LINE TO PARSE FOR KEYWORD:      default:
The real line: +	return 1;				// Unknown controll char
End Check: 4
LINE TO PARSE FOR KEYWORD:	return 1;				
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      if (dt_pos[position] != 255)		// Don't allow same tag twice
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (dt_pos[position] != 255)		
The real line: +	return 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:	return 1;
The real line: +      parts[position]= ptr-1;
End Check: 3
LINE TO PARSE FOR KEYWORD:      parts[position]= ptr-1;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      /*
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +	If switching from time to date, ensure that all time parts
The real line: +	are used
The real line: +      */
The real line: +      if (part_map && position <= 2 && !(part_map & (1 | 2 | 4)))
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (part_map && position <= 2 && !(part_map & (1 | 2 | 4)))
The real line: +	offset=5;
End Check: 3
LINE TO PARSE FOR KEYWORD:	offset=5;
The real line: +      part_map|= (ulong) 1 << position;
End Check: 3
LINE TO PARSE FOR KEYWORD:      part_map|= (ulong) 1 << position;
The real line: +      dt_pos[position]= offset++;
End Check: 3
LINE TO PARSE FOR KEYWORD:      dt_pos[position]= offset++;
The real line: +      allow_separator= 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:      allow_separator= 1;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else
End Check: 2
LINE TO PARSE FOR KEYWORD:    else
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      /*
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +	Don't allow any characters in format as this could easily confuse
The real line: +	the date reader
The real line: +      */
The real line: +      if (!allow_separator)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (!allow_separator)
The real line: +	return 1;				// No separator here
End Check: 3
LINE TO PARSE FOR KEYWORD:	return 1;				
The real line: +      allow_separator= 0;			// Don't allow two separators
End Check: 3
LINE TO PARSE FOR KEYWORD:      allow_separator= 0;			
The real line: +      separators++;
End Check: 3
LINE TO PARSE FOR KEYWORD:      separators++;
The real line: +      /* Store in separator_map which parts are punct characters */
End Check: 3
LINE TO PARSE FOR KEYWORD:      
The real line: +      if (my_ispunct(&my_charset_latin1, *ptr))
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (my_ispunct(&my_charset_latin1, *ptr))
The real line: +	separator_map|= (ulong) 1 << (offset-1);
End Check: 3
LINE TO PARSE FOR KEYWORD:	separator_map|= (ulong) 1 << (offset-1);
The real line: +      else if (!my_isspace(&my_charset_latin1, *ptr))
End Check: 3
LINE TO PARSE FOR KEYWORD:      else if (!my_isspace(&my_charset_latin1, *ptr))
The real line: +	return 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:	return 1;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /* If no %f, specify it after seconds.  Move %p up, if necessary */
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  if ((part_map & 32) && !(part_map & 64))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((part_map & 32) && !(part_map & 64))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    dt_pos[6]= dt_pos[5] +1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    dt_pos[6]= dt_pos[5] +1;
The real line: +    parts[6]= parts[5];				// For later test in (need_p)
End Check: 2
LINE TO PARSE FOR KEYWORD:    parts[6]= parts[5];				
The real line: +    if (dt_pos[6] == dt_pos[7])			// Move %p one step up if used
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (dt_pos[6] == dt_pos[7])			
The real line: +      dt_pos[7]++;
End Check: 2
LINE TO PARSE FOR KEYWORD:      dt_pos[7]++;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /*
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +    Check that we have not used a non legal format specifier and that all
The real line: +    format specifiers have been used
The real line: +
The real line: +    The last test is to ensure that %p is used if and only if
The real line: +    it's needed.
The real line: +  */
The real line: +  if ((format_type == MYSQL_TIMESTAMP_DATETIME &&
End Check: 1
LINE TO PARSE FOR KEYWORD:  if ((format_type == mysql_timestamp_datetime &&
The real line: +       !test_all_bits(part_map, (1 | 2 | 4 | 8 | 16 | 32))) ||
End Check: 1
LINE TO PARSE FOR KEYWORD:       !test_all_bits(part_map, (1 | 2 | 4 | 8 | 16 | 32))) ||
The real line: +      (format_type == MYSQL_TIMESTAMP_DATE && part_map != (1 | 2 | 4)) ||
End Check: 1
LINE TO PARSE FOR KEYWORD:      (format_type == mysql_timestamp_date && part_map != (1 | 2 | 4)) ||
The real line: +      (format_type == MYSQL_TIMESTAMP_TIME &&
End Check: 1
LINE TO PARSE FOR KEYWORD:      (format_type == mysql_timestamp_time &&
The real line: +       !test_all_bits(part_map, 8 | 16 | 32)) ||
End Check: 1
LINE TO PARSE FOR KEYWORD:       !test_all_bits(part_map, 8 | 16 | 32)) ||
The real line: +      !allow_separator ||			// %option should be last
End Check: 1
LINE TO PARSE FOR KEYWORD:      !allow_separator ||			
The real line: +      (need_p && dt_pos[6] +1 != dt_pos[7]) ||
End Check: 1
LINE TO PARSE FOR KEYWORD:      (need_p && dt_pos[6] +1 != dt_pos[7]) ||
The real line: +      (need_p ^ (dt_pos[7] != 255)))
End Check: 1
LINE TO PARSE FOR KEYWORD:      (need_p ^ (dt_pos[7] != 255)))
The real line: +    return 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 1;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (dt_pos[6] != 255)				// If fractional seconds
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (dt_pos[6] != 255)				
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    /* remove fractional seconds from later tests */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    uint pos= dt_pos[6] -1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint pos= dt_pos[6] -1;
The real line: +    /* Remove separator before %f from sep map */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    separator_map= ((separator_map & ((ulong) (1 << pos)-1)) |
End Check: 2
LINE TO PARSE FOR KEYWORD:    separator_map= ((separator_map & ((ulong) (1 << pos)-1)) |
The real line: +		    ((separator_map & ~((ulong) (1 << pos)-1)) >> 1));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    ((separator_map & ~((ulong) (1 << pos)-1)) >> 1));
The real line: +    if (part_map & 64)			      
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (part_map & 64)			      
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      separators--;				// There is always a separator
End Check: 3
LINE TO PARSE FOR KEYWORD:      separators--;				
The real line: +      need_p= 1;				// force use of separators
End Check: 3
LINE TO PARSE FOR KEYWORD:      need_p= 1;				
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /*
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +    Remove possible separator before %p from sep_map
The real line: +    (This can either be at position 3, 4, 6 or 7) h.m.d.%f %p
The real line: +  */
The real line: +  if (dt_pos[7] != 255)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (dt_pos[7] != 255)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (need_p && parts[7] != parts[6]+2)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (need_p && parts[7] != parts[6]+2)
The real line: +      separators--;
End Check: 2
LINE TO PARSE FOR KEYWORD:      separators--;
The real line: +  }     
End Check: 1
LINE TO PARSE FOR KEYWORD:  }     
The real line: +  /*
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +    Calculate if %p is in first or last part of the datetime field
The real line: +
The real line: +    At this point we have either %H-%i-%s %p 'year parts' or
The real line: +    'year parts' &H-%i-%s %p" as %f was removed above
The real line: +  */
The real line: +  offset= dt_pos[6] <= 3 ? 3 : 6;
End Check: 1
LINE TO PARSE FOR KEYWORD:  offset= dt_pos[6] <= 3 ? 3 : 6;
The real line: +  /* Remove separator before %p from sep map */
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +  separator_map= ((separator_map & ((ulong) (1 << offset)-1)) |
End Check: 1
LINE TO PARSE FOR KEYWORD:  separator_map= ((separator_map & ((ulong) (1 << offset)-1)) |
The real line: +		  ((separator_map & ~((ulong) (1 << offset)-1)) >> 1));
End Check: 1
LINE TO PARSE FOR KEYWORD:		  ((separator_map & ~((ulong) (1 << offset)-1)) >> 1));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  format_str= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  format_str= 0;
The real line: +  switch (format_type) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  switch (format_type) {
The real line: +  case MYSQL_TIMESTAMP_DATE:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case mysql_timestamp_date:
The real line: +    format_str= known_date_time_formats[INTERNAL_FORMAT].date_format;
End Check: 2
LINE TO PARSE FOR KEYWORD:    format_str= known_date_time_formats[internal_format].date_format;
The real line: +    /* fall through */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +  case MYSQL_TIMESTAMP_TIME:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case mysql_timestamp_time:
The real line: +    if (!format_str)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (!format_str)
The real line: +      format_str=known_date_time_formats[INTERNAL_FORMAT].time_format;
End Check: 2
LINE TO PARSE FOR KEYWORD:      format_str=known_date_time_formats[internal_format].time_format;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    /*
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +      If there is no separators, allow the internal format as we can read
The real line: +      this.  If separators are used, they must be between each part
The real line: +    */
The real line: +    if (format_length == 6 && !need_p &&
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (format_length == 6 && !need_p &&
The real line: +	!my_strnncoll(&my_charset_bin,
End Check: 2
LINE TO PARSE FOR KEYWORD:	!my_strnncoll(&my_charset_bin,
The real line: +		      (const uchar *) format, 6, 
End Check: 2
LINE TO PARSE FOR KEYWORD:		      (const uchar *) format, 6, 
The real line: +		      (const uchar *) format_str, 6))
End Check: 2
LINE TO PARSE FOR KEYWORD:		      (const uchar *) format_str, 6))
The real line: +      return 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:      return 0;
The real line: +    if (separator_map == (1 | 2))
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (separator_map == (1 | 2))
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      if (format_type == MYSQL_TIMESTAMP_TIME)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (format_type == mysql_timestamp_time)
The real line: +      {
End Check: 4
LINE TO PARSE FOR KEYWORD:      {
The real line: +	if (*(format+2) != *(format+5))
End Check: 4
LINE TO PARSE FOR KEYWORD:	if (*(format+2) != *(format+5))
The real line: +	  break;				// Error
End Check: 4
LINE TO PARSE FOR KEYWORD:	  break;				
The real line: +	/* Store the character used for time formats */
End Check: 4
LINE TO PARSE FOR KEYWORD:	
The real line: +	date_time_format->time_separator= *(format+2);
End Check: 4
LINE TO PARSE FOR KEYWORD:	date_time_format->time_separator= *(format+2);
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +      return 0;
End Check: 3
LINE TO PARSE FOR KEYWORD:      return 0;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    break;
End Check: 2
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  case MYSQL_TIMESTAMP_DATETIME:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case mysql_timestamp_datetime:
The real line: +    /*
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +      If there is no separators, allow the internal format as we can read
The real line: +      this.  If separators are used, they must be between each part.
The real line: +      Between DATE and TIME we also allow space as separator
The real line: +    */
The real line: +    if ((format_length == 12 && !need_p &&
End Check: 2
LINE TO PARSE FOR KEYWORD:    if ((format_length == 12 && !need_p &&
The real line: +	 !my_strnncoll(&my_charset_bin, 
End Check: 2
LINE TO PARSE FOR KEYWORD:	 !my_strnncoll(&my_charset_bin, 
The real line: +		       (const uchar *) format, 12,
End Check: 2
LINE TO PARSE FOR KEYWORD:		       (const uchar *) format, 12,
The real line: +		       (const uchar*) known_date_time_formats[INTERNAL_FORMAT].datetime_format,
End Check: 2
LINE TO PARSE FOR KEYWORD:		       (const uchar*) known_date_time_formats[internal_format].datetime_format,
The real line: +		       12)) ||
End Check: 2
LINE TO PARSE FOR KEYWORD:		       12)) ||
The real line: +	(separators == 5 && separator_map == (1 | 2 | 8 | 16)))
End Check: 2
LINE TO PARSE FOR KEYWORD:	(separators == 5 && separator_map == (1 | 2 | 8 | 16)))
The real line: +      return 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:      return 0;
The real line: +    break;
End Check: 2
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  default:
End Check: 2
LINE TO PARSE FOR KEYWORD:  default:
The real line: +    DBUG_ASSERT(1);
End Check: 2
LINE TO PARSE FOR KEYWORD:    dbug_assert(1);
The real line: +    break;
End Check: 2
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return 1;					// Error
End Check: 1
LINE TO PARSE FOR KEYWORD:  return 1;					
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
428 : 637
Next: (timestamp_type format_type,     char *format, uint format_length,     DATE_TIME_FORMAT *date_time_format)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Create a DATE_TIME_FORMAT object from a format string specification
The real line: +
The real line: +  SYNOPSIS
The real line: +    date_time_format_make()
The real line: +    format_type		Format to parse (time, date or datetime)
The real line: +    format_str		String to parse
The real line: +    format_length	Length of string
The real line: +
The real line: +  NOTES
The real line: +    The returned object should be freed with my_free()
The real line: +
The real line: +  RETURN
The real line: +    NULL ponter:	Error
The real line: +    new object
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +DATE_TIME_FORMAT
Current Name Search:     
LINE TO PARSE FOR KEYWORD:date_time_format
Depths: 0:0
[]
The real line: +*date_time_format_make(timestamp_type format_type,
Current Name Search:     DATE_TIME_FORMAT 
LINE TO PARSE FOR KEYWORD:*date_time_format_make(timestamp_type format_type,
Depths: 0:0
[]
The real line: +		       const char *format_str, uint format_length)
Current Name Search:     DATE_TIME_FORMAT *date_time_format_make(timestamp_type format_type, 
LINE TO PARSE FOR KEYWORD:		       const char *format_str, uint format_length)
Depths: 0:0
[]
The real line: +{
Current Name Search:     DATE_TIME_FORMAT *date_time_format_make(timestamp_type format_type, 		       const char *format_str, uint format_length) 
Checking if function:     DATE_TIME_FORMAT *date_time_format_make(timestamp_type format_type, 		       const char *format_str, uint format_length) {
PATTERN 5
Function: DATE_TIME_FORMAT *date_time_format_make(timestamp_type format_type,       char *format_str, uint format_length) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  DATE_TIME_FORMAT tmp;
End Check: 1
LINE TO PARSE FOR KEYWORD:  date_time_format tmp;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (format_length && format_length < 255 &&
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (format_length && format_length < 255 &&
The real line: +      !parse_date_time_format(format_type, format_str,
End Check: 1
LINE TO PARSE FOR KEYWORD:      !parse_date_time_format(format_type, format_str,
The real line: +			      format_length, &tmp))
End Check: 1
LINE TO PARSE FOR KEYWORD:			      format_length, &tmp))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    tmp.format.str=    (char*) format_str;
End Check: 2
LINE TO PARSE FOR KEYWORD:    tmp.format.str=    (char*) format_str;
The real line: +    tmp.format.length= format_length;
End Check: 2
LINE TO PARSE FOR KEYWORD:    tmp.format.length= format_length;
The real line: +    return date_time_format_copy((THD *)0, &tmp);
End Check: 2
LINE TO PARSE FOR KEYWORD:    return date_time_format_copy((thd *)0, &tmp);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return 0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
660 : 672
Next: (timestamp_type format_type,       char *format_str, uint format_length)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Create a copy of a DATE_TIME_FORMAT object
The real line: +
The real line: +  SYNOPSIS
The real line: +    date_and_time_format_copy()
The real line: +    thd			Set if variable should be allocated in thread mem
The real line: +    format		format to copy
The real line: +
The real line: +  NOTES
The real line: +    The returned object should be freed with my_free()
The real line: +
The real line: +  RETURN
The real line: +    NULL ponter:	Error
The real line: +    new object
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +DATE_TIME_FORMAT *date_time_format_copy(THD *thd, DATE_TIME_FORMAT *format)
Current Name Search:     
LINE TO PARSE FOR KEYWORD:date_time_format *date_time_format_copy(thd *thd, date_time_format *format)
Depths: 0:0
[]
The real line: +{
Current Name Search:     DATE_TIME_FORMAT *date_time_format_copy(THD *thd, DATE_TIME_FORMAT *format) 
Checking if function:     DATE_TIME_FORMAT *date_time_format_copy(THD *thd, DATE_TIME_FORMAT *format) {
PATTERN 5
Function: DATE_TIME_FORMAT *date_time_format_copy(THD *thd, DATE_TIME_FORMAT *format) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  DATE_TIME_FORMAT *new_format;
End Check: 1
LINE TO PARSE FOR KEYWORD:  date_time_format *new_format;
The real line: +  ulong length= sizeof(*format) + format->format.length + 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulong length= sizeof(*format) + format->format.length + 1;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (thd)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (thd)
The real line: +    new_format= (DATE_TIME_FORMAT *) thd->alloc(length);
End Check: 1
LINE TO PARSE FOR KEYWORD:    new_format= (date_time_format *) thd->alloc(length);
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +    new_format=  (DATE_TIME_FORMAT *) my_malloc(length, MYF(MY_WME));
End Check: 1
LINE TO PARSE FOR KEYWORD:    new_format=  (date_time_format *) my_malloc(length, myf(my_wme));
The real line: +  if (new_format)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (new_format)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    /* Put format string after current pos */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    new_format->format.str= (char*) (new_format+1);
End Check: 2
LINE TO PARSE FOR KEYWORD:    new_format->format.str= (char*) (new_format+1);
The real line: +    memcpy((char*) new_format->positions, (char*) format->positions,
End Check: 2
LINE TO PARSE FOR KEYWORD:    memcpy((char*) new_format->positions, (char*) format->positions,
The real line: +	   sizeof(format->positions));
End Check: 2
LINE TO PARSE FOR KEYWORD:	   sizeof(format->positions));
The real line: +    new_format->time_separator= format->time_separator;
End Check: 2
LINE TO PARSE FOR KEYWORD:    new_format->time_separator= format->time_separator;
The real line: +    /* We make the string null terminated for easy printf in SHOW VARIABLES */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    memcpy((char*) new_format->format.str, format->format.str,
End Check: 2
LINE TO PARSE FOR KEYWORD:    memcpy((char*) new_format->format.str, format->format.str,
The real line: +	   format->format.length);
End Check: 2
LINE TO PARSE FOR KEYWORD:	   format->format.length);
The real line: +    new_format->format.str[format->format.length]= 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:    new_format->format.str[format->format.length]= 0;
The real line: +    new_format->format.length= format->format.length;
End Check: 2
LINE TO PARSE FOR KEYWORD:    new_format->format.length= format->format.length;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  return new_format;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return new_format;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
692 : 714
Next: (THD *thd, DATE_TIME_FORMAT *format)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +KNOWN_DATE_TIME_FORMAT known_date_time_formats[6]=
Current Name Search:   
LINE TO PARSE FOR KEYWORD:known_date_time_format known_date_time_formats[6]=
Depths: 0:0
[]
The real line: +{
Current Name Search:   KNOWN_DATE_TIME_FORMAT known_date_time_formats[6]= 
Checking if function:   KNOWN_DATE_TIME_FORMAT known_date_time_formats[6]= {
Other type of bracket:   KNOWN_DATE_TIME_FORMAT known_date_time_formats[6]= {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
[]
The real line: +  {"USA", "%m.%d.%Y", "%Y-%m-%d %H.%i.%s", "%h:%i:%s %p" },
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  {, , ,  },
Depths: 1:2
[]
Adjusting depth.
The real line: +  {"JIS", "%Y-%m-%d", "%Y-%m-%d %H:%i:%s", "%H:%i:%s" },
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  {, , ,  },
Depths: 1:2
[]
Adjusting depth.
The real line: +  {"ISO", "%Y-%m-%d", "%Y-%m-%d %H:%i:%s", "%H:%i:%s" },
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  {, , ,  },
Depths: 1:2
[]
Adjusting depth.
The real line: +  {"EUR", "%d.%m.%Y", "%Y-%m-%d %H.%i.%s", "%H.%i.%s" },
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  {, , ,  },
Depths: 1:2
[]
Adjusting depth.
The real line: +  {"INTERNAL", "%Y%m%d",   "%Y%m%d%H%i%s", "%H%i%s" },
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  {, ,   ,  },
Depths: 1:2
[]
Adjusting depth.
The real line: +  { 0, 0, 0, 0 }
Current Name Search: 
Checking if function:   {
Other type of bracket:   {
LINE TO PARSE FOR KEYWORD:  { 0, 0, 0, 0 }
Depths: 1:2
[]
Adjusting depth.
The real line: +};
Current Name Search: 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search: };   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +   Return format string according format name.
The real line: +   If name is unknown, result is NULL
The real line: +*/
The real line: +
Current Name Search: };    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +const char *get_date_time_format_str(KNOWN_DATE_TIME_FORMAT *format,
Current Name Search: };     
LINE TO PARSE FOR KEYWORD:const char *get_date_time_format_str(known_date_time_format *format,
Depths: 0:0
[]
The real line: +				     timestamp_type type)
Current Name Search: };     const char *get_date_time_format_str(KNOWN_DATE_TIME_FORMAT *format, 
LINE TO PARSE FOR KEYWORD:				     timestamp_type type)
Depths: 0:0
[]
The real line: +{
Current Name Search: };     const char *get_date_time_format_str(KNOWN_DATE_TIME_FORMAT *format, 				     timestamp_type type) 
Checking if function: };     const char *get_date_time_format_str(KNOWN_DATE_TIME_FORMAT *format, 				     timestamp_type type) {
PATTERN 2
Function:  char *get_date_time_format_str(KNOWN_DATE_TIME_FORMAT *format,      timestamp_type type) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  switch (type) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  switch (type) {
The real line: +  case MYSQL_TIMESTAMP_DATE:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case mysql_timestamp_date:
The real line: +    return format->date_format;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return format->date_format;
The real line: +  case MYSQL_TIMESTAMP_DATETIME:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case mysql_timestamp_datetime:
The real line: +    return format->datetime_format;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return format->datetime_format;
The real line: +  case MYSQL_TIMESTAMP_TIME:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case mysql_timestamp_time:
The real line: +    return format->time_format;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return format->time_format;
The real line: +  default:
End Check: 2
LINE TO PARSE FOR KEYWORD:  default:
The real line: +    DBUG_ASSERT(0);				// Impossible
End Check: 2
LINE TO PARSE FOR KEYWORD:    dbug_assert(0);				
The real line: +    return 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return 0;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
735 : 747
Next: (KNOWN_DATE_TIME_FORMAT *format,      timestamp_type type)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/****************************************************************************
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Functions to create default time/date/datetime strings
The real line: + 
The real line: +  NOTE:
The real line: +    For the moment the DATE_TIME_FORMAT argument is ignored becasue
The real line: +    MySQL doesn't support comparing of date/time/datetime strings that
The real line: +    are not in arbutary order as dates are compared as strings in some
The real line: +    context)
The real line: +    This functions don't check that given MYSQL_TIME structure members are
The real line: +    in valid range. If they are not, return value won't reflect any 
The real line: +    valid date either. Additionally, make_time doesn't take into
The real line: +    account time->day member: it's assumed that days have been converted
The real line: +    to hours already.
The real line: +****************************************************************************/
The real line: +
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)),
Current Name Search:    
LINE TO PARSE FOR KEYWORD:void make_time(const date_time_format *format __attribute__((unused)),
Depths: 0:0
[]
The real line: +               const MYSQL_TIME *l_time, String *str)
Current Name Search:    void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)), 
LINE TO PARSE FOR KEYWORD:               const mysql_time *l_time, string *str)
Depths: 0:0
[]
The real line: +{
Current Name Search:    void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)),                const MYSQL_TIME *l_time, String *str) 
Checking if function:    void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)),                const MYSQL_TIME *l_time, String *str) {
PATTERN 4
Function: void make_time(const DATE_TIME_FORMAT *format __attribute__((unused)),               MYSQL_TIME *l_time, String *str) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint length= (uint) my_time_to_str(l_time, (char*) str->ptr());
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint length= (uint) my_time_to_str(l_time, (char*) str->ptr());
The real line: +  str->length(length);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str->length(length);
The real line: +  str->set_charset(&my_charset_numeric);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str->set_charset(&my_charset_numeric);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
766 : 770
Next: (const DATE_TIME_FORMAT *format __attribute__((unused)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)),
Current Name Search:   
LINE TO PARSE FOR KEYWORD:void make_date(const date_time_format *format __attribute__((unused)),
Depths: 0:0
[]
The real line: +               const MYSQL_TIME *l_time, String *str)
Current Name Search:   void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)), 
LINE TO PARSE FOR KEYWORD:               const mysql_time *l_time, string *str)
Depths: 0:0
[]
The real line: +{
Current Name Search:   void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)),                const MYSQL_TIME *l_time, String *str) 
Checking if function:   void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)),                const MYSQL_TIME *l_time, String *str) {
PATTERN 4
Function: void make_date(const DATE_TIME_FORMAT *format __attribute__((unused)),               MYSQL_TIME *l_time, String *str) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint length= (uint) my_date_to_str(l_time, (char*) str->ptr());
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint length= (uint) my_date_to_str(l_time, (char*) str->ptr());
The real line: +  str->length(length);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str->length(length);
The real line: +  str->set_charset(&my_charset_numeric);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str->set_charset(&my_charset_numeric);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
775 : 779
Next: (const DATE_TIME_FORMAT *format __attribute__((unused)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void make_datetime(const DATE_TIME_FORMAT *format __attribute__((unused)),
Current Name Search:   
LINE TO PARSE FOR KEYWORD:void make_datetime(const date_time_format *format __attribute__((unused)),
Depths: 0:0
[]
The real line: +                   const MYSQL_TIME *l_time, String *str)
Current Name Search:   void make_datetime(const DATE_TIME_FORMAT *format __attribute__((unused)), 
LINE TO PARSE FOR KEYWORD:                   const mysql_time *l_time, string *str)
Depths: 0:0
[]
The real line: +{
Current Name Search:   void make_datetime(const DATE_TIME_FORMAT *format __attribute__((unused)),                    const MYSQL_TIME *l_time, String *str) 
Checking if function:   void make_datetime(const DATE_TIME_FORMAT *format __attribute__((unused)),                    const MYSQL_TIME *l_time, String *str) {
PATTERN 4
Function: void make_datetime(const DATE_TIME_FORMAT *format __attribute__((unused)),                   MYSQL_TIME *l_time, String *str) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  uint length= (uint) my_datetime_to_str(l_time, (char*) str->ptr());
End Check: 1
LINE TO PARSE FOR KEYWORD:  uint length= (uint) my_datetime_to_str(l_time, (char*) str->ptr());
The real line: +  str->length(length);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str->length(length);
The real line: +  str->set_charset(&my_charset_numeric);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str->set_charset(&my_charset_numeric);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
784 : 788
Next: (const DATE_TIME_FORMAT *format __attribute__((unused)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level,
Current Name Search:   
LINE TO PARSE FOR KEYWORD:void make_truncated_value_warning(thd *thd, mysql_error::enum_warning_level level,
Depths: 0:0
[]
The real line: +                                  const char *str_val,
Current Name Search:   void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level, 
LINE TO PARSE FOR KEYWORD:                                  const char *str_val,
Depths: 0:0
[]
The real line: +				  uint str_length, timestamp_type time_type,
Current Name Search:   void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level,                                   const char *str_val, 
LINE TO PARSE FOR KEYWORD:				  uint str_length, timestamp_type time_type,
Depths: 0:0
[]
The real line: +                                  const char *field_name)
Current Name Search:   void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level,                                   const char *str_val, 				  uint str_length, timestamp_type time_type, 
LINE TO PARSE FOR KEYWORD:                                  const char *field_name)
Depths: 0:0
[]
The real line: +{
Current Name Search:   void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level,                                   const char *str_val, 				  uint str_length, timestamp_type time_type,                                   const char *field_name) 
Checking if function:   void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level,                                   const char *str_val, 				  uint str_length, timestamp_type time_type,                                   const char *field_name) {
PATTERN 4
Function: void make_truncated_value_warning(THD *thd, MYSQL_ERROR::enum_warning_level level,                                  char *str_val,   uint str_length, timestamp_type time_type,                                  char *field_name) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  char warn_buff[MYSQL_ERRMSG_SIZE];
End Check: 1
LINE TO PARSE FOR KEYWORD:  char warn_buff[mysql_errmsg_size];
The real line: +  const char *type_str;
End Check: 1
LINE TO PARSE FOR KEYWORD:  const char *type_str;
The real line: +  CHARSET_INFO *cs= &my_charset_latin1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  charset_info *cs= &my_charset_latin1;
The real line: +  char buff[128];
End Check: 1
LINE TO PARSE FOR KEYWORD:  char buff[128];
The real line: +  String str(buff,(uint32) sizeof(buff), system_charset_info);
End Check: 1
LINE TO PARSE FOR KEYWORD:  string str(buff,(uint32) sizeof(buff), system_charset_info);
The real line: +  str.copy(str_val, str_length, system_charset_info);
End Check: 1
LINE TO PARSE FOR KEYWORD:  str.copy(str_val, str_length, system_charset_info);
The real line: +  str[str_length]= 0;               // Ensure we have end 0 for snprintf
End Check: 1
LINE TO PARSE FOR KEYWORD:  str[str_length]= 0;               
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  switch (time_type) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  switch (time_type) {
The real line: +    case MYSQL_TIMESTAMP_DATE: 
End Check: 2
LINE TO PARSE FOR KEYWORD:    case mysql_timestamp_date: 
The real line: +      type_str= "date";
End Check: 2
LINE TO PARSE FOR KEYWORD:      type_str= ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case MYSQL_TIMESTAMP_TIME:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case mysql_timestamp_time:
The real line: +      type_str= "time";
End Check: 2
LINE TO PARSE FOR KEYWORD:      type_str= ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case MYSQL_TIMESTAMP_DATETIME:  // FALLTHROUGH
End Check: 2
LINE TO PARSE FOR KEYWORD:    case mysql_timestamp_datetime:  
The real line: +    default:
End Check: 2
LINE TO PARSE FOR KEYWORD:    default:
The real line: +      type_str= "datetime";
End Check: 2
LINE TO PARSE FOR KEYWORD:      type_str= ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  if (field_name)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (field_name)
The real line: +    cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
End Check: 1
LINE TO PARSE FOR KEYWORD:    cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
The real line: +                       ER(ER_TRUNCATED_WRONG_VALUE_FOR_FIELD),
End Check: 1
LINE TO PARSE FOR KEYWORD:                       er(er_truncated_wrong_value_for_field),
The real line: +                       type_str, str.c_ptr(), field_name,
End Check: 1
LINE TO PARSE FOR KEYWORD:                       type_str, str.c_ptr(), field_name,
The real line: +                       (ulong) thd->warning_info->current_row_for_warning());
End Check: 1
LINE TO PARSE FOR KEYWORD:                       (ulong) thd->warning_info->current_row_for_warning());
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (time_type > MYSQL_TIMESTAMP_ERROR)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (time_type > mysql_timestamp_error)
The real line: +      cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
End Check: 2
LINE TO PARSE FOR KEYWORD:      cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
The real line: +                         ER(ER_TRUNCATED_WRONG_VALUE),
End Check: 2
LINE TO PARSE FOR KEYWORD:                         er(er_truncated_wrong_value),
The real line: +                         type_str, str.c_ptr());
End Check: 2
LINE TO PARSE FOR KEYWORD:                         type_str, str.c_ptr());
The real line: +    else
End Check: 2
LINE TO PARSE FOR KEYWORD:    else
The real line: +      cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
End Check: 2
LINE TO PARSE FOR KEYWORD:      cs->cset->snprintf(cs, warn_buff, sizeof(warn_buff),
The real line: +                         ER(ER_WRONG_VALUE), type_str, str.c_ptr());
End Check: 2
LINE TO PARSE FOR KEYWORD:                         er(er_wrong_value), type_str, str.c_ptr());
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  push_warning(thd, level,
End Check: 1
LINE TO PARSE FOR KEYWORD:  push_warning(thd, level,
The real line: +               ER_TRUNCATED_WRONG_VALUE, warn_buff);
End Check: 1
LINE TO PARSE FOR KEYWORD:               er_truncated_wrong_value, warn_buff);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
795 : 833
Next: (THD *thd, MYSQL_ERROR::enum_warning_level level,                                  char *str_val,   uint str_length, timestamp_type time_type,                                  char *field_name)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Daynumber from year 0 to 9999-12-31 */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#define MAX_DAY_NUMBER 3652424L
Current Name Search:   
LINE TO PARSE FOR KEYWORD:#define max_day_number 3652424l
Depths: 0:0
[]
The real line: +
Current Name Search:   #define MAX_DAY_NUMBER 3652424L 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool date_add_interval(MYSQL_TIME *ltime, interval_type int_type, INTERVAL interval)
Current Name Search:   #define MAX_DAY_NUMBER 3652424L  
LINE TO PARSE FOR KEYWORD:bool date_add_interval(mysql_time *ltime, interval_type int_type, interval interval)
Depths: 0:0
[]
The real line: +{
Current Name Search:   #define MAX_DAY_NUMBER 3652424L  bool date_add_interval(MYSQL_TIME *ltime, interval_type int_type, INTERVAL interval) 
Checking if function:   #define MAX_DAY_NUMBER 3652424L  bool date_add_interval(MYSQL_TIME *ltime, interval_type int_type, INTERVAL interval) {
PATTERN 1
Function:  bool date_add_interval(MYSQL_TIME *ltime, interval_type int_type, INTERVAL interval) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  long period, sign;
End Check: 1
LINE TO PARSE FOR KEYWORD:  long period, sign;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  ltime->neg= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  ltime->neg= 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  sign= (interval.neg ? -1 : 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:  sign= (interval.neg ? -1 : 1);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  switch (int_type) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  switch (int_type) {
The real line: +  case INTERVAL_SECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_second:
The real line: +  case INTERVAL_SECOND_MICROSECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_second_microsecond:
The real line: +  case INTERVAL_MICROSECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_microsecond:
The real line: +  case INTERVAL_MINUTE:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_minute:
The real line: +  case INTERVAL_HOUR:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_hour:
The real line: +  case INTERVAL_MINUTE_MICROSECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_minute_microsecond:
The real line: +  case INTERVAL_MINUTE_SECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_minute_second:
The real line: +  case INTERVAL_HOUR_MICROSECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_hour_microsecond:
The real line: +  case INTERVAL_HOUR_SECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_hour_second:
The real line: +  case INTERVAL_HOUR_MINUTE:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_hour_minute:
The real line: +  case INTERVAL_DAY_MICROSECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_day_microsecond:
The real line: +  case INTERVAL_DAY_SECOND:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_day_second:
The real line: +  case INTERVAL_DAY_MINUTE:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_day_minute:
The real line: +  case INTERVAL_DAY_HOUR:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_day_hour:
The real line: +  {
End Check: 3
LINE TO PARSE FOR KEYWORD:  {
The real line: +    longlong sec, days, daynr, microseconds, extra_sec;
End Check: 3
LINE TO PARSE FOR KEYWORD:    longlong sec, days, daynr, microseconds, extra_sec;
The real line: +    ltime->time_type= MYSQL_TIMESTAMP_DATETIME; // Return full date
End Check: 3
LINE TO PARSE FOR KEYWORD:    ltime->time_type= mysql_timestamp_datetime; 
The real line: +    microseconds= ltime->second_part + sign*interval.second_part;
End Check: 3
LINE TO PARSE FOR KEYWORD:    microseconds= ltime->second_part + sign*interval.second_part;
The real line: +    extra_sec= microseconds/1000000L;
End Check: 3
LINE TO PARSE FOR KEYWORD:    extra_sec= microseconds/1000000l;
The real line: +    microseconds= microseconds%1000000L;
End Check: 3
LINE TO PARSE FOR KEYWORD:    microseconds= microseconds%1000000l;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    sec=((ltime->day-1)*3600*24L+ltime->hour*3600+ltime->minute*60+
End Check: 3
LINE TO PARSE FOR KEYWORD:    sec=((ltime->day-1)*3600*24l+ltime->hour*3600+ltime->minute*60+
The real line: +	 ltime->second +
End Check: 3
LINE TO PARSE FOR KEYWORD:	 ltime->second +
The real line: +	 sign* (longlong) (interval.day*3600*24L +
End Check: 3
LINE TO PARSE FOR KEYWORD:	 sign* (longlong) (interval.day*3600*24l +
The real line: +                           interval.hour*LL(3600)+interval.minute*LL(60)+
End Check: 3
LINE TO PARSE FOR KEYWORD:                           interval.hour*ll(3600)+interval.minute*ll(60)+
The real line: +                           interval.second))+ extra_sec;
End Check: 3
LINE TO PARSE FOR KEYWORD:                           interval.second))+ extra_sec;
The real line: +    if (microseconds < 0)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (microseconds < 0)
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +      microseconds+= LL(1000000);
End Check: 4
LINE TO PARSE FOR KEYWORD:      microseconds+= ll(1000000);
The real line: +      sec--;
End Check: 4
LINE TO PARSE FOR KEYWORD:      sec--;
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +    days= sec/(3600*LL(24));
End Check: 3
LINE TO PARSE FOR KEYWORD:    days= sec/(3600*ll(24));
The real line: +    sec-= days*3600*LL(24);
End Check: 3
LINE TO PARSE FOR KEYWORD:    sec-= days*3600*ll(24);
The real line: +    if (sec < 0)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (sec < 0)
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +      days--;
End Check: 4
LINE TO PARSE FOR KEYWORD:      days--;
The real line: +      sec+= 3600*LL(24);
End Check: 4
LINE TO PARSE FOR KEYWORD:      sec+= 3600*ll(24);
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +    ltime->second_part= (uint) microseconds;
End Check: 3
LINE TO PARSE FOR KEYWORD:    ltime->second_part= (uint) microseconds;
The real line: +    ltime->second= (uint) (sec % 60);
End Check: 3
LINE TO PARSE FOR KEYWORD:    ltime->second= (uint) (sec % 60);
The real line: +    ltime->minute= (uint) (sec/60 % 60);
End Check: 3
LINE TO PARSE FOR KEYWORD:    ltime->minute= (uint) (sec/60 % 60);
The real line: +    ltime->hour=   (uint) (sec/3600);
End Check: 3
LINE TO PARSE FOR KEYWORD:    ltime->hour=   (uint) (sec/3600);
The real line: +    daynr= calc_daynr(ltime->year,ltime->month,1) + days;
End Check: 3
LINE TO PARSE FOR KEYWORD:    daynr= calc_daynr(ltime->year,ltime->month,1) + days;
The real line: +    /* Day number from year 0 to 9999-12-31 */
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    if ((ulonglong) daynr > MAX_DAY_NUMBER)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if ((ulonglong) daynr > max_day_number)
The real line: +      goto invalid_date;
End Check: 3
LINE TO PARSE FOR KEYWORD:      goto invalid_date;
The real line: +    get_date_from_daynr((long) daynr, &ltime->year, &ltime->month,
End Check: 3
LINE TO PARSE FOR KEYWORD:    get_date_from_daynr((long) daynr, &ltime->year, &ltime->month,
The real line: +                        &ltime->day);
End Check: 3
LINE TO PARSE FOR KEYWORD:                        &ltime->day);
The real line: +    break;
End Check: 3
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  }
End Check: 2
LINE TO PARSE FOR KEYWORD:  }
The real line: +  case INTERVAL_DAY:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_day:
The real line: +  case INTERVAL_WEEK:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_week:
The real line: +    period= (calc_daynr(ltime->year,ltime->month,ltime->day) +
End Check: 2
LINE TO PARSE FOR KEYWORD:    period= (calc_daynr(ltime->year,ltime->month,ltime->day) +
The real line: +             sign * (long) interval.day);
End Check: 2
LINE TO PARSE FOR KEYWORD:             sign * (long) interval.day);
The real line: +    /* Daynumber from year 0 to 9999-12-31 */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    if ((ulong) period > MAX_DAY_NUMBER)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if ((ulong) period > max_day_number)
The real line: +      goto invalid_date;
End Check: 2
LINE TO PARSE FOR KEYWORD:      goto invalid_date;
The real line: +    get_date_from_daynr((long) period,&ltime->year,&ltime->month,&ltime->day);
End Check: 2
LINE TO PARSE FOR KEYWORD:    get_date_from_daynr((long) period,&ltime->year,&ltime->month,&ltime->day);
The real line: +    break;
End Check: 2
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  case INTERVAL_YEAR:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_year:
The real line: +    ltime->year+= sign * (long) interval.year;
End Check: 2
LINE TO PARSE FOR KEYWORD:    ltime->year+= sign * (long) interval.year;
The real line: +    if ((ulong) ltime->year >= 10000L)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if ((ulong) ltime->year >= 10000l)
The real line: +      goto invalid_date;
End Check: 2
LINE TO PARSE FOR KEYWORD:      goto invalid_date;
The real line: +    if (ltime->month == 2 && ltime->day == 29 &&
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (ltime->month == 2 && ltime->day == 29 &&
The real line: +	calc_days_in_year(ltime->year) != 366)
End Check: 2
LINE TO PARSE FOR KEYWORD:	calc_days_in_year(ltime->year) != 366)
The real line: +      ltime->day=28;				// Was leap-year
End Check: 2
LINE TO PARSE FOR KEYWORD:      ltime->day=28;				
The real line: +    break;
End Check: 2
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  case INTERVAL_YEAR_MONTH:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_year_month:
The real line: +  case INTERVAL_QUARTER:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_quarter:
The real line: +  case INTERVAL_MONTH:
End Check: 2
LINE TO PARSE FOR KEYWORD:  case interval_month:
The real line: +    period= (ltime->year*12 + sign * (long) interval.year*12 +
End Check: 2
LINE TO PARSE FOR KEYWORD:    period= (ltime->year*12 + sign * (long) interval.year*12 +
The real line: +	     ltime->month-1 + sign * (long) interval.month);
End Check: 2
LINE TO PARSE FOR KEYWORD:	     ltime->month-1 + sign * (long) interval.month);
The real line: +    if ((ulong) period >= 120000L)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if ((ulong) period >= 120000l)
The real line: +      goto invalid_date;
End Check: 2
LINE TO PARSE FOR KEYWORD:      goto invalid_date;
The real line: +    ltime->year= (uint) (period / 12);
End Check: 2
LINE TO PARSE FOR KEYWORD:    ltime->year= (uint) (period / 12);
The real line: +    ltime->month= (uint) (period % 12L)+1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    ltime->month= (uint) (period % 12l)+1;
The real line: +    /* Adjust day if the new month doesn't have enough days */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    if (ltime->day > days_in_month[ltime->month-1])
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (ltime->day > days_in_month[ltime->month-1])
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      ltime->day = days_in_month[ltime->month-1];
End Check: 3
LINE TO PARSE FOR KEYWORD:      ltime->day = days_in_month[ltime->month-1];
The real line: +      if (ltime->month == 2 && calc_days_in_year(ltime->year) == 366)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (ltime->month == 2 && calc_days_in_year(ltime->year) == 366)
The real line: +	ltime->day++;				// Leap-year
End Check: 3
LINE TO PARSE FOR KEYWORD:	ltime->day++;				
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    break;
End Check: 2
LINE TO PARSE FOR KEYWORD:    break;
The real line: +  default:
End Check: 2
LINE TO PARSE FOR KEYWORD:  default:
The real line: +    goto null_date;
End Check: 2
LINE TO PARSE FOR KEYWORD:    goto null_date;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  return 0;					// Ok
End Check: 1
LINE TO PARSE FOR KEYWORD:  return 0;					
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +invalid_date:
End Check: 1
LINE TO PARSE FOR KEYWORD:invalid_date:
The real line: +  push_warning_printf(current_thd, MYSQL_ERROR::WARN_LEVEL_WARN,
End Check: 1
LINE TO PARSE FOR KEYWORD:  push_warning_printf(current_thd, mysql_error::warn_level_warn,
The real line: +                      ER_DATETIME_FUNCTION_OVERFLOW,
End Check: 1
LINE TO PARSE FOR KEYWORD:                      er_datetime_function_overflow,
The real line: +                      ER(ER_DATETIME_FUNCTION_OVERFLOW),
End Check: 1
LINE TO PARSE FOR KEYWORD:                      er(er_datetime_function_overflow),
The real line: +                      "datetime");
End Check: 1
LINE TO PARSE FOR KEYWORD:                      );
The real line: +null_date:
End Check: 1
LINE TO PARSE FOR KEYWORD:null_date:
The real line: +  return 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return 1;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
839 : 944
Next: (MYSQL_TIME *ltime, interval_type int_type, INTERVAL interval)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Calculate difference between two datetime values as seconds + microseconds.
The real line: +
The real line: +  SYNOPSIS
The real line: +    calc_time_diff()
The real line: +      l_time1         - TIME/DATE/DATETIME value
The real line: +      l_time2         - TIME/DATE/DATETIME value
The real line: +      l_sign          - 1 absolute values are substracted,
The real line: +                        -1 absolute values are added.
The real line: +      seconds_out     - Out parameter where difference between
The real line: +                        l_time1 and l_time2 in seconds is stored.
The real line: +      microseconds_out- Out parameter where microsecond part of difference
The real line: +                        between l_time1 and l_time2 is stored.
The real line: +
The real line: +  NOTE
The real line: +    This function calculates difference between l_time1 and l_time2 absolute
The real line: +    values. So one should set l_sign and correct result if he want to take
The real line: +    signs into account (i.e. for MYSQL_TIME values).
The real line: +
The real line: +  RETURN VALUES
The real line: +    Returns sign of difference.
The real line: +    1 means negative result
The real line: +    0 means positive result
The real line: +
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool
Current Name Search:     
LINE TO PARSE FOR KEYWORD:bool
Depths: 0:0
[]
The real line: +calc_time_diff(MYSQL_TIME *l_time1, MYSQL_TIME *l_time2, int l_sign, longlong *seconds_out,
Current Name Search:     bool 
LINE TO PARSE FOR KEYWORD:calc_time_diff(mysql_time *l_time1, mysql_time *l_time2, int l_sign, longlong *seconds_out,
Depths: 0:0
[]
The real line: +               long *microseconds_out)
Current Name Search:     bool calc_time_diff(MYSQL_TIME *l_time1, MYSQL_TIME *l_time2, int l_sign, longlong *seconds_out, 
LINE TO PARSE FOR KEYWORD:               long *microseconds_out)
Depths: 0:0
[]
The real line: +{
Current Name Search:     bool calc_time_diff(MYSQL_TIME *l_time1, MYSQL_TIME *l_time2, int l_sign, longlong *seconds_out,                long *microseconds_out) 
Checking if function:     bool calc_time_diff(MYSQL_TIME *l_time1, MYSQL_TIME *l_time2, int l_sign, longlong *seconds_out,                long *microseconds_out) {
PATTERN 4
Function: bool calc_time_diff(MYSQL_TIME *l_time1, MYSQL_TIME *l_time2, int l_sign, longlong *seconds_out,                long *microseconds_out) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  long days;
End Check: 1
LINE TO PARSE FOR KEYWORD:  long days;
The real line: +  bool neg;
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool neg;
The real line: +  longlong microseconds;
End Check: 1
LINE TO PARSE FOR KEYWORD:  longlong microseconds;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  /*
End Check: 1
LINE TO PARSE FOR KEYWORD:  
The real line: +    We suppose that if first argument is MYSQL_TIMESTAMP_TIME
The real line: +    the second argument should be TIMESTAMP_TIME also.
The real line: +    We should check it before calc_time_diff call.
The real line: +  */
The real line: +  if (l_time1->time_type == MYSQL_TIMESTAMP_TIME)  // Time value
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (l_time1->time_type == mysql_timestamp_time)  
The real line: +    days= (long)l_time1->day - l_sign * (long)l_time2->day;
End Check: 1
LINE TO PARSE FOR KEYWORD:    days= (long)l_time1->day - l_sign * (long)l_time2->day;
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    days= calc_daynr((uint) l_time1->year,
End Check: 2
LINE TO PARSE FOR KEYWORD:    days= calc_daynr((uint) l_time1->year,
The real line: +		     (uint) l_time1->month,
End Check: 2
LINE TO PARSE FOR KEYWORD:		     (uint) l_time1->month,
The real line: +		     (uint) l_time1->day);
End Check: 2
LINE TO PARSE FOR KEYWORD:		     (uint) l_time1->day);
The real line: +    if (l_time2->time_type == MYSQL_TIMESTAMP_TIME)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (l_time2->time_type == mysql_timestamp_time)
The real line: +      days-= l_sign * (long)l_time2->day;
End Check: 2
LINE TO PARSE FOR KEYWORD:      days-= l_sign * (long)l_time2->day;
The real line: +    else
End Check: 2
LINE TO PARSE FOR KEYWORD:    else
The real line: +      days-= l_sign*calc_daynr((uint) l_time2->year,
End Check: 2
LINE TO PARSE FOR KEYWORD:      days-= l_sign*calc_daynr((uint) l_time2->year,
The real line: +			       (uint) l_time2->month,
End Check: 2
LINE TO PARSE FOR KEYWORD:			       (uint) l_time2->month,
The real line: +			       (uint) l_time2->day);
End Check: 2
LINE TO PARSE FOR KEYWORD:			       (uint) l_time2->day);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  microseconds= ((longlong)days*LL(86400) +
End Check: 1
LINE TO PARSE FOR KEYWORD:  microseconds= ((longlong)days*ll(86400) +
The real line: +                 (longlong)(l_time1->hour*3600L +
End Check: 1
LINE TO PARSE FOR KEYWORD:                 (longlong)(l_time1->hour*3600l +
The real line: +                            l_time1->minute*60L +
End Check: 1
LINE TO PARSE FOR KEYWORD:                            l_time1->minute*60l +
The real line: +                            l_time1->second) -
End Check: 1
LINE TO PARSE FOR KEYWORD:                            l_time1->second) -
The real line: +                 l_sign*(longlong)(l_time2->hour*3600L +
End Check: 1
LINE TO PARSE FOR KEYWORD:                 l_sign*(longlong)(l_time2->hour*3600l +
The real line: +                                   l_time2->minute*60L +
End Check: 1
LINE TO PARSE FOR KEYWORD:                                   l_time2->minute*60l +
The real line: +                                   l_time2->second)) * LL(1000000) +
End Check: 1
LINE TO PARSE FOR KEYWORD:                                   l_time2->second)) * ll(1000000) +
The real line: +                (longlong)l_time1->second_part -
End Check: 1
LINE TO PARSE FOR KEYWORD:                (longlong)l_time1->second_part -
The real line: +                l_sign*(longlong)l_time2->second_part;
End Check: 1
LINE TO PARSE FOR KEYWORD:                l_sign*(longlong)l_time2->second_part;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  neg= 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  neg= 0;
The real line: +  if (microseconds < 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (microseconds < 0)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    microseconds= -microseconds;
End Check: 2
LINE TO PARSE FOR KEYWORD:    microseconds= -microseconds;
The real line: +    neg= 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    neg= 1;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  *seconds_out= microseconds/1000000L;
End Check: 1
LINE TO PARSE FOR KEYWORD:  *seconds_out= microseconds/1000000l;
The real line: +  *microseconds_out= (long) (microseconds%1000000L);
End Check: 1
LINE TO PARSE FOR KEYWORD:  *microseconds_out= (long) (microseconds%1000000l);
The real line: +  return neg;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return neg;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
976 : 1020
Next: (MYSQL_TIME *l_time1, MYSQL_TIME *l_time2, int l_sign, longlong *seconds_out,                long *microseconds_out)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  Compares 2 MYSQL_TIME structures
The real line: +
The real line: +  SYNOPSIS
The real line: +    my_time_compare()
The real line: +
The real line: +      a - first time
The real line: +      b - second time
The real line: +
The real line: +  RETURN VALUE
The real line: +   -1   - a < b
The real line: +    0   - a == b
The real line: +    1   - a > b
The real line: +
The real line: +*/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +int my_time_compare(MYSQL_TIME *a, MYSQL_TIME *b)
Current Name Search:     
LINE TO PARSE FOR KEYWORD:int my_time_compare(mysql_time *a, mysql_time *b)
Depths: 0:0
[]
The real line: +{
Current Name Search:     int my_time_compare(MYSQL_TIME *a, MYSQL_TIME *b) 
Checking if function:     int my_time_compare(MYSQL_TIME *a, MYSQL_TIME *b) {
PATTERN 4
Function: int my_time_compare(MYSQL_TIME *a, MYSQL_TIME *b) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  ulonglong a_t= TIME_to_ulonglong_datetime(a);
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulonglong a_t= time_to_ulonglong_datetime(a);
The real line: +  ulonglong b_t= TIME_to_ulonglong_datetime(b);
End Check: 1
LINE TO PARSE FOR KEYWORD:  ulonglong b_t= time_to_ulonglong_datetime(b);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (a_t < b_t)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (a_t < b_t)
The real line: +    return -1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return -1;
The real line: +  if (a_t > b_t)
En.d Check: 1
LINE TO PARSE FOR KEYWORD:  if (a_t > b_t)
The real line: +    return 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 1;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (a->second_part < b->second_part)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (a->second_part < b->second_part)
The real line: +    return -1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return -1;
The real line: +  if (a->second_part > b->second_part)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (a->second_part > b->second_part)
The real line: +    return 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 1;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return 0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1040 : 1055
Next: (MYSQL_TIME *a, MYSQL_TIME *b)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#endif
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
Chunk End.
The real line: +/***********************************************************//**
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Fetch a prefix of an externally stored column.  This is similar
The real line: +to row_ext_lookup(), but the row_ext_t holds the old values
The real line: +of the column and must not be poisoned with the new values.
The real line: +@return	BLOB prefix */
The real line: +static
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +byte*
Current Name Search:  static 
LINE TO PARSE FOR KEYWORD:byte*
Depths: 0:0
[]
The real line: +row_upd_ext_fetch(
Current Name Search:  static byte* 
LINE TO PARSE FOR KEYWORD:row_upd_ext_fetch(
Depths: 0:0
[]
The real line: +/*==============*/
Current Name Search:  static byte* row_upd_ext_fetch( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	const byte*	data,		/*!< in: 'internally' stored part of the
Current Name Search:  static byte* row_upd_ext_fetch(  
LINE TO PARSE FOR KEYWORD:	const byte*	data,		
Depths: 0:0
[]
The real line: +					field containing also the reference to
The real line: +					the external part */
The real line: +	ulint		local_len,	/*!< in: length of data, in bytes */
Current Name Search:  static byte* row_upd_ext_fetch(  	const byte*	data,		 
LINE TO PARSE FOR KEYWORD:	ulint		local_len,	
Depths: 0:0
[]
The real line: +	ulint		zip_size,	/*!< in: nonzero=compressed BLOB
Current Name Search:  static byte* row_upd_ext_fetch(  	const byte*	data,		 	ulint		local_len,	 
LINE TO PARSE FOR KEYWORD:	ulint		zip_size,	
Depths: 0:0
[]
The real line: +					page size, zero for uncompressed
The real line: +					BLOBs */
The real line: +	ulint*		len,		/*!< in: length of prefix to fetch;
Current Name Search:  static byte* row_upd_ext_fetch(  	const byte*	data,		 	ulint		local_len,	 	ulint		zip_size,	 
LINE TO PARSE FOR KEYWORD:	ulint*		len,		
Depths: 0:0
[]
The real line: +					out: fetched length of the prefix */
The real line: +	mem_heap_t*	heap)		/*!< in: heap where to allocate */
Current Name Search:  static byte* row_upd_ext_fetch(  	const byte*	data,		 	ulint		local_len,	 	ulint		zip_size,	 	ulint*		len,		 
LINE TO PARSE FOR KEYWORD:	mem_heap_t*	heap)		
Depths: 0:0
[]
The real line: +{
Current Name Search:  static byte* row_upd_ext_fetch(  	const byte*	data,		 	ulint		local_len,	 	ulint		zip_size,	 	ulint*		len,		 	mem_heap_t*	heap)		 
Checking if function:  static byte* row_upd_ext_fetch(  	const byte*	data,		 	ulint		local_len,	 	ulint		zip_size,	 	ulint*		len,		 	mem_heap_t*	heap)		 {
PATTERN 1
Function:  byte* row_upd_ext_fetch( byte*data, ulintlocal_len, ulintzip_size, ulint*len, mem_heap_t*heap) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	byte*	buf = mem_heap_alloc(heap, *len);
End Check: 1
LINE TO PARSE FOR KEYWORD:	byte*	buf = mem_heap_alloc(heap, *len);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	*len = btr_copy_externally_stored_field_prefix(buf, *len,
End Check: 1
LINE TO PARSE FOR KEYWORD:	*len = btr_copy_externally_stored_field_prefix(buf, *len,
The real line: +						       zip_size,
End Check: 1
LINE TO PARSE FOR KEYWORD:						       zip_size,
The real line: +						       data, local_len);
End Check: 1
LINE TO PARSE FOR KEYWORD:						       data, local_len);
The real line: +	/* We should never update records containing a half-deleted BLOB. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	ut_a(*len);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(*len);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(buf);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(buf);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
20 : 30
Next: ( byte*data, ulintlocal_len, ulintzip_size, ulint*len, mem_heap_t*heap)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/***********************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Replaces the new column value stored in the update vector in
The real line: +the given index entry field. */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +void
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +row_upd_index_replace_new_col_val(
Current Name Search:   static void 
LINE TO PARSE FOR KEYWORD:row_upd_index_replace_new_col_val(
Depths: 0:0
[]
The real line: +/*==============================*/
Current Name Search:   static void row_upd_index_replace_new_col_val( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	dfield_t*		dfield,	/*!< in/out: data field
Current Name Search:   static void row_upd_index_replace_new_col_val(  
LINE TO PARSE FOR KEYWORD:	dfield_t*		dfield,	
Depths: 0:0
[]
The real line: +					of the index entry */
The real line: +	const dict_field_t*	field,	/*!< in: index field */
Current Name Search:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 
LINE TO PARSE FOR KEYWORD:	const dict_field_t*	field,	
Depths: 0:0
[]
The real line: +	const dict_col_t*	col,	/*!< in: field->col */
Current Name Search:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 	const dict_field_t*	field,	 
LINE TO PARSE FOR KEYWORD:	const dict_col_t*	col,	
Depths: 0:0
[]
The real line: +	const upd_field_t*	uf,	/*!< in: update field */
Current Name Search:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 	const dict_field_t*	field,	 	const dict_col_t*	col,	 
LINE TO PARSE FOR KEYWORD:	const upd_field_t*	uf,	
Depths: 0:0
[]
The real line: +	mem_heap_t*		heap,	/*!< in: memory heap for allocating
Current Name Search:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 	const dict_field_t*	field,	 	const dict_col_t*	col,	 	const upd_field_t*	uf,	 
LINE TO PARSE FOR KEYWORD:	mem_heap_t*		heap,	
Depths: 0:0
[]
The real line: +					and copying the new value */
The real line: +	ulint			zip_size)/*!< in: compressed page
Current Name Search:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 	const dict_field_t*	field,	 	const dict_col_t*	col,	 	const upd_field_t*	uf,	 	mem_heap_t*		heap,	 
LINE TO PARSE FOR KEYWORD:	ulint			zip_size)
Depths: 0:0
[]
The real line: +					 size of the table, or 0 */
The real line: +{
Current Name Search:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 	const dict_field_t*	field,	 	const dict_col_t*	col,	 	const upd_field_t*	uf,	 	mem_heap_t*		heap,	 	ulint			zip_size) 
Checking if function:   static void row_upd_index_replace_new_col_val(  	dfield_t*		dfield,	 	const dict_field_t*	field,	 	const dict_col_t*	col,	 	const upd_field_t*	uf,	 	mem_heap_t*		heap,	 	ulint			zip_size) {
PATTERN 1
Function:  void row_upd_index_replace_new_col_val(  dfield_t*dfield,dict_field_t*field,dict_col_t*col,upd_field_t*uf, mem_heap_t*heap, ulintzip_size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint		len;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint		len;
The real line: +	const byte*	data;
End Check: 1
LINE TO PARSE FOR KEYWORD:	const byte*	data;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	dfield_copy_data(dfield, &uf->new_val);
End Check: 1
LINE TO PARSE FOR KEYWORD:	dfield_copy_data(dfield, &uf->new_val);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (dfield_is_null(dfield)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (dfield_is_null(dfield)) {
The real line: +		return;
End Check: 2
LINE TO PARSE FOR KEYWORD:		return;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	len = dfield_get_len(dfield);
End Check: 1
LINE TO PARSE FOR KEYWORD:	len = dfield_get_len(dfield);
The real line: +	data = dfield_get_data(dfield);
End Check: 1
LINE TO PARSE FOR KEYWORD:	data = dfield_get_data(dfield);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (field->prefix_len > 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (field->prefix_len > 0) {
The real line: +		ibool		fetch_ext = dfield_is_ext(dfield)
End Check: 2
LINE TO PARSE FOR KEYWORD:		ibool		fetch_ext = dfield_is_ext(dfield)
The real line: +			&& len < (ulint) field->prefix_len
End Check: 2
LINE TO PARSE FOR KEYWORD:			&& len < (ulint) field->prefix_len
The real line: +			+ BTR_EXTERN_FIELD_REF_SIZE;
End Check: 2
LINE TO PARSE FOR KEYWORD:			+ btr_extern_field_ref_size;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (fetch_ext) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (fetch_ext) {
The real line: +			ulint	l = len;
End Check: 3
LINE TO PARSE FOR KEYWORD:			ulint	l = len;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			len = field->prefix_len;
End Check: 3
LINE TO PARSE FOR KEYWORD:			len = field->prefix_len;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			data = row_upd_ext_fetch(data, l, zip_size,
End Check: 3
LINE TO PARSE FOR KEYWORD:			data = row_upd_ext_fetch(data, l, zip_size,
The real line: +						 &len, heap);
End Check: 3
LINE TO PARSE FOR KEYWORD:						 &len, heap);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		len = dtype_get_at_most_n_mbchars(col->prtype,
End Check: 2
LINE TO PARSE FOR KEYWORD:		len = dtype_get_at_most_n_mbchars(col->prtype,
The real line: +						  col->mbminlen, col->mbmaxlen,
End Check: 2
LINE TO PARSE FOR KEYWORD:						  col->mbminlen, col->mbmaxlen,
The real line: +						  field->prefix_len, len,
End Check: 2
LINE TO PARSE FOR KEYWORD:						  field->prefix_len, len,
The real line: +						  (const char*) data);
End Check: 2
LINE TO PARSE FOR KEYWORD:						  (const char*) data);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		dfield_set_data(dfield, data, len);
End Check: 2
LINE TO PARSE FOR KEYWORD:		dfield_set_data(dfield, data, len);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (!fetch_ext) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (!fetch_ext) {
The real line: +			dfield_dup(dfield, heap);
End Check: 3
LINE TO PARSE FOR KEYWORD:			dfield_dup(dfield, heap);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return;
End Check: 2
LINE TO PARSE FOR KEYWORD:		return;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	switch (uf->orig_len) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	switch (uf->orig_len) {
The real line: +		byte*	buf;
End Check: 2
LINE TO PARSE FOR KEYWORD:		byte*	buf;
The real line: +	case BTR_EXTERN_FIELD_REF_SIZE:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case btr_extern_field_ref_size:
The real line: +		/* Restore the original locally stored
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		part of the column.  In the undo log,
The real line: +		InnoDB writes a longer prefix of externally
The real line: +		stored columns, so that column prefixes
The real line: +		in secondary indexes can be reconstructed. */
The real line: +		dfield_set_data(dfield,
End Check: 2
LINE TO PARSE FOR KEYWORD:		dfield_set_data(dfield,
The real line: +				data + len - BTR_EXTERN_FIELD_REF_SIZE,
End Check: 2
LINE TO PARSE FOR KEYWORD:				data + len - btr_extern_field_ref_size,
The real line: +				BTR_EXTERN_FIELD_REF_SIZE);
End Check: 2
LINE TO PARSE FOR KEYWORD:				btr_extern_field_ref_size);
The real line: +		dfield_set_ext(dfield);
End Check: 2
LINE TO PARSE FOR KEYWORD:		dfield_set_ext(dfield);
The real line: +		/* fall through */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +	case 0:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case 0:
The real line: +		dfield_dup(dfield, heap);
End Check: 2
LINE TO PARSE FOR KEYWORD:		dfield_dup(dfield, heap);
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	default:
End Check: 2
LINE TO PARSE FOR KEYWORD:	default:
The real line: +		/* Reconstruct the original locally
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		stored part of the column.  The data
The real line: +		will have to be copied. */
The real line: +		ut_a(uf->orig_len > BTR_EXTERN_FIELD_REF_SIZE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(uf->orig_len > btr_extern_field_ref_size);
The real line: +		buf = mem_heap_alloc(heap, uf->orig_len);
End Check: 2
LINE TO PARSE FOR KEYWORD:		buf = mem_heap_alloc(heap, uf->orig_len);
The real line: +		/* Copy the locally stored prefix. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		memcpy(buf, data,
End Check: 2
LINE TO PARSE FOR KEYWORD:		memcpy(buf, data,
The real line: +		       uf->orig_len - BTR_EXTERN_FIELD_REF_SIZE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		       uf->orig_len - btr_extern_field_ref_size);
The real line: +		/* Copy the BLOB pointer. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		memcpy(buf + uf->orig_len - BTR_EXTERN_FIELD_REF_SIZE,
End Check: 2
LINE TO PARSE FOR KEYWORD:		memcpy(buf + uf->orig_len - btr_extern_field_ref_size,
The real line: +		       data + len - BTR_EXTERN_FIELD_REF_SIZE,
End Check: 2
LINE TO PARSE FOR KEYWORD:		       data + len - btr_extern_field_ref_size,
The real line: +		       BTR_EXTERN_FIELD_REF_SIZE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		       btr_extern_field_ref_size);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		dfield_set_data(dfield, buf, uf->orig_len);
End Check: 2
LINE TO PARSE FOR KEYWORD:		dfield_set_data(dfield, buf, uf->orig_len);
The real line: +		dfield_set_ext(dfield);
End Check: 2
LINE TO PARSE FOR KEYWORD:		dfield_set_ext(dfield);
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
48 : 123
Next: (  dfield_t*dfield,dict_field_t*field,dict_col_t*col,upd_field_t*uf, mem_heap_t*heap, ulintzip_size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/***********************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Replaces the new column values stored in the update vector to the index entry
The real line: +given. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +row_upd_index_replace_new_col_vals_index_pos(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:row_upd_index_replace_new_col_vals_index_pos(
Depths: 0:0
[]
The real line: +/*=========================================*/
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	dtuple_t*	entry,	/*!< in/out: index entry where replaced;
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  
LINE TO PARSE FOR KEYWORD:	dtuple_t*	entry,	
Depths: 0:0
[]
The real line: +				the clustered index record must be
The real line: +				covered by a lock or a page latch to
The real line: +				prevent deletion (rollback or purge) */
The real line: +	dict_index_t*	index,	/*!< in: index; NOTE that this may also be a
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 
LINE TO PARSE FOR KEYWORD:	dict_index_t*	index,	
Depths: 0:0
[]
The real line: +				non-clustered index */
The real line: +	const upd_t*	update,	/*!< in: an update vector built for the index so
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 	dict_index_t*	index,	 
LINE TO PARSE FOR KEYWORD:	const upd_t*	update,	
Depths: 0:0
[]
The real line: +				that the field number in an upd_field is the
The real line: +				index position */
The real line: +	ibool		order_only,
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 
LINE TO PARSE FOR KEYWORD:	ibool		order_only,
Depths: 0:0
[]
The real line: +				/*!< in: if TRUE, limit the replacement to
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 	ibool		order_only, 
LINE TO PARSE FOR KEYWORD:				
Depths: 0:0
[]
The real line: +				ordering fields of index; note that this
The real line: +				does not work for non-clustered indexes. */
The real line: +	mem_heap_t*	heap)	/*!< in: memory heap for allocating and
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 	ibool		order_only, 				 
LINE TO PARSE FOR KEYWORD:	mem_heap_t*	heap)	
Depths: 0:0
[]
The real line: +				copying the new values */
The real line: +{
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 	ibool		order_only, 				 	mem_heap_t*	heap)	 
Checking if function:   UNIV_INTERN void row_upd_index_replace_new_col_vals_index_pos(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 	ibool		order_only, 				 	mem_heap_t*	heap)	 {
PATTERN 1
Function:  void row_upd_index_replace_new_col_vals_index_pos(  dtuple_t*entry, dict_index_t*index,upd_t*update, iboolorder_only,  mem_heap_t*heap) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint		i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint		i;
The real line: +	ulint		n_fields;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint		n_fields;
The real line: +	const ulint	zip_size	= dict_table_zip_size(index->table);
End Check: 1
LINE TO PARSE FOR KEYWORD:	const ulint	zip_size	= dict_table_zip_size(index->table);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_ad(index);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_ad(index);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	dtuple_set_info_bits(entry, update->info_bits);
End Check: 1
LINE TO PARSE FOR KEYWORD:	dtuple_set_info_bits(entry, update->info_bits);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (order_only) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (order_only) {
The real line: +		n_fields = dict_index_get_n_unique(index);
End Check: 2
LINE TO PARSE FOR KEYWORD:		n_fields = dict_index_get_n_unique(index);
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		n_fields = dict_index_get_n_fields(index);
End Check: 2
LINE TO PARSE FOR KEYWORD:		n_fields = dict_index_get_n_fields(index);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < n_fields; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < n_fields; i++) {
The real line: +		const dict_field_t*	field;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const dict_field_t*	field;
The real line: +		const dict_col_t*	col;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const dict_col_t*	col;
The real line: +		const upd_field_t*	uf;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const upd_field_t*	uf;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		field = dict_index_get_nth_field(index, i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		field = dict_index_get_nth_field(index, i);
The real line: +		col = dict_field_get_col(field);
End Check: 2
LINE TO PARSE FOR KEYWORD:		col = dict_field_get_col(field);
The real line: +		uf = upd_get_field_by_field_no(update, i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		uf = upd_get_field_by_field_no(update, i);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (uf) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (uf) {
The real line: +			row_upd_index_replace_new_col_val(
End Check: 3
LINE TO PARSE FOR KEYWORD:			row_upd_index_replace_new_col_val(
The real line: +				dtuple_get_nth_field(entry, i),
End Check: 3
LINE TO PARSE FOR KEYWORD:				dtuple_get_nth_field(entry, i),
The real line: +				field, col, uf, heap, zip_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:				field, col, uf, heap, zip_size);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
147 : 177
Next: (  dtuple_t*entry, dict_index_t*index,upd_t*update, iboolorder_only,  mem_heap_t*heap)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/***********************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Replaces the new column values stored in the update vector to the index entry
The real line: +given. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +row_upd_index_replace_new_col_vals(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:row_upd_index_replace_new_col_vals(
Depths: 0:0
[]
The real line: +/*===============================*/
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	dtuple_t*	entry,	/*!< in/out: index entry where replaced;
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals(  
LINE TO PARSE FOR KEYWORD:	dtuple_t*	entry,	
Depths: 0:0
[]
The real line: +				the clustered index record must be
The real line: +				covered by a lock or a page latch to
The real line: +				prevent deletion (rollback or purge) */
The real line: +	dict_index_t*	index,	/*!< in: index; NOTE that this may also be a
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals(  	dtuple_t*	entry,	 
LINE TO PARSE FOR KEYWORD:	dict_index_t*	index,	
Depths: 0:0
[]
The real line: +				non-clustered index */
The real line: +	const upd_t*	update,	/*!< in: an update vector built for the
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals(  	dtuple_t*	entry,	 	dict_index_t*	index,	 
LINE TO PARSE FOR KEYWORD:	const upd_t*	update,	
Depths: 0:0
[]
The real line: +				CLUSTERED index so that the field number in
The real line: +				an upd_field is the clustered index position */
The real line: +	mem_heap_t*	heap)	/*!< in: memory heap for allocating and
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 
LINE TO PARSE FOR KEYWORD:	mem_heap_t*	heap)	
Depths: 0:0
[]
The real line: +				copying the new values */
The real line: +{
Current Name Search:   UNIV_INTERN void row_upd_index_replace_new_col_vals(  	dtuple_t*	entry,	 	dict_index_t*	index,	 	const upd_t*	update,	 	mem_heap_t*	heap)	 
Checking if function:   UNIV_INTERN void row_upd_index_replace_new_col_vals(  	dtuple_t*	entry,	 	dict_index_t*.	index,	 	const upd_t*	update,	 	mem_heap_t*	heap)	 {
PATTERN 1
Function:  void row_upd_index_replace_new_col_vals(  dtuple_t*entry, dict_index_t*index,upd_t*update, mem_heap_t*heap) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint			i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint			i;
The real line: +	const dict_index_t*	clust_index
End Check: 1
LINE TO PARSE FOR KEYWORD:	const dict_index_t*	clust_index
The real line: +		= dict_table_get_first_index(index->table);
End Check: 1
LINE TO PARSE FOR KEYWORD:		= dict_table_get_first_index(index->table);
The real line: +	const ulint		zip_size
End Check: 1
LINE TO PARSE FOR KEYWORD:	const ulint		zip_size
The real line: +		= dict_table_zip_size(index->table);
End Check: 1
LINE TO PARSE FOR KEYWORD:		= dict_table_zip_size(index->table);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	dtuple_set_info_bits(entry, update->info_bits);
End Check: 1
LINE TO PARSE FOR KEYWORD:	dtuple_set_info_bits(entry, update->info_bits);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < dict_index_get_n_fields(index); i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < dict_index_get_n_fields(index); i++) {
The real line: +		const dict_field_t*	field;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const dict_field_t*	field;
The real line: +		const dict_col_t*	col;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const dict_col_t*	col;
The real line: +		const upd_field_t*	uf;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const upd_field_t*	uf;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		field = dict_index_get_nth_field(index, i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		field = dict_index_get_nth_field(index, i);
The real line: +		col = dict_field_get_col(field);
End Check: 2
LINE TO PARSE FOR KEYWORD:		col = dict_field_get_col(field);
The real line: +		uf = upd_get_field_by_field_no(
End Check: 2
LINE TO PARSE FOR KEYWORD:		uf = upd_get_field_by_field_no(
The real line: +			update, dict_col_get_clust_pos(col, clust_index));
End Check: 2
LINE TO PARSE FOR KEYWORD:			update, dict_col_get_clust_pos(col, clust_index));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (uf) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (uf) {
The real line: +			row_upd_index_replace_new_col_val(
End Check: 3
LINE TO PARSE FOR KEYWORD:			row_upd_index_replace_new_col_val(
The real line: +				dtuple_get_nth_field(entry, i),
End Check: 3
LINE TO PARSE FOR KEYWORD:				dtuple_get_nth_field(entry, i),
The real line: +				field, col, uf, heap, zip_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:				field, col, uf, heap, zip_size);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
197 : 222
Next: (  dtuple_t*entry, dict_index_t*index,upd_t*update, mem_heap_t*heap)
Chunk End.
The real line: +/*****************************************************************************
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
The real line: +Copyright (c) 2007, 2010, Innobase Oy. All Rights Reserved.
The real line: +
The real line: +This program is free software; you can redistribute it and/or modify it under
The real line: +the terms of the GNU General Public License as published by the Free Software
The real line: +Foundation; version 2 of the License.
The real line: +
The real line: +This program is distributed in the hope that it will be useful, but WITHOUT
The real line: +ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
The real line: +FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
The real line: +
The real line: +You should have received a copy of the GNU General Public License along with
The real line: +this program; if not, write to the Free Software Foundation, Inc., 59 Temple
The real line: +Place, Suite 330, Boston, MA 02111-1307 USA
The real line: +
The real line: +*****************************************************************************/
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**************************************************//**
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +@file trx/trx0i_s.c
The real line: +INFORMATION SCHEMA innodb_trx, innodb_locks and
The real line: +innodb_lock_waits tables fetch code.
The real line: +
The real line: +The code below fetches information needed to fill those
The real line: +3 dynamic tables and uploads it into a "transactions
The real line: +table cache" for later retrieval.
The real line: +
The real line: +Created July 17, 2007 Vasil Dimov
The real line: +*******************************************************/
The real line: +
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Found during the build of 5.5.3 on Linux 2.4 and early 2.6 kernels:
Current Name Search:     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +   The includes "univ.i" -> "my_global.h" cause a different path
The real line: +   to be taken further down with pthread functions and types,
The real line: +   so they must come first.
The real line: +   From the symptoms, this is related to bug#46587 in the MySQL bug DB.
The real line: +*/
The real line: +#include "univ.i"
Current Name Search:      
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:      #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include <mysql/plugin.h>
Current Name Search:      #include   
LINE TO PARSE FOR KEYWORD:#include <mysql/plugin.h>
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "mysql_addons.h"
Current Name Search:      #include   #include <mysql/plugin.h>  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "buf0buf.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "dict0dict.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "ha0storage.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "ha_prototypes.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "hash0hash.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "lock0iter.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "lock0lock.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "mem0mem.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "page0page.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "rem0rec.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "row0row.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "srv0srv.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "sync0rw.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "sync0sync.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "sync0types.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "trx0i_s.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "trx0sys.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "trx0trx.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "ut0mem.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "ut0ut.h"
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** Initial number of rows in the table cache */
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#define TABLE_CACHE_INITIAL_ROWSNUM	1024
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    
LINE TO PARSE FOR KEYWORD:#define table_cache_initial_rowsnum	1024
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** @brief The maximum number of chunks to allocate for a table cache.
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
The real line: +The rows of a table cache are stored in a set of chunks. When a new
The real line: +row is added a new chunk is allocated if necessary. Assuming that the
The real line: +first one is 1024 rows (TABLE_CACHE_INITIAL_ROWSNUM) and each
The real line: +subsequent is N/2 where N is the number of rows we have allocated till
The real line: +now, then 39th chunk would accommodate 1677416425 rows and all chunks
The real line: +would accommodate 3354832851 rows. */
The real line: +#define MEM_CHUNKS_IN_TABLE_CACHE	39
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   
LINE TO PARSE FOR KEYWORD:#define mem_chunks_in_table_cache	39
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** The following are some testing auxiliary macros. Do not enable them
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +in a production environment. */
The real line: +/* @{ */
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if 0
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     
LINE TO PARSE FOR KEYWORD:#if 0
Depths: 0:0
[]
The real line: +/** If this is enabled then lock folds will always be different
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +resulting in equal rows being put in a different cells of the hash
The real line: +table. Checking for duplicates will be flawed because different
The real line: +fold will be calculated when a row is searched in the hash table. */
The real line: +#define TEST_LOCK_FOLD_ALWAYS_DIFFERENT
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  
LINE TO PARSE FOR KEYWORD:#define test_lock_fold_always_different
Depths: 0:0
[]
The real line: +#endif
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if 0
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  
LINE TO PARSE FOR KEYWORD:#if 0
Depths: 0:0
[]
The real line: +/** This effectively kills the search-for-duplicate-before-adding-a-row
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +function, but searching in the hash is still performed. It will always
The real line: +be assumed that lock is not present and insertion will be performed in
The real line: +the hash table. */
The real line: +#define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  
LINE TO PARSE FOR KEYWORD:#define test_no_locks_row_is_ever_equal_to_lock_t
Depths: 0:0
[]
The real line: +#endif
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if 0
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  
LINE TO PARSE FOR KEYWORD:#if 0
Depths: 0:0
[]
The real line: +/** This aggressively repeats adding each row many times. Depending on
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +the above settings this may be noop or may result in lots of rows being
The real line: +added. */
The real line: +#define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  
LINE TO PARSE FOR KEYWORD:#define test_add_each_locks_row_many_times
Depths: 0:0
[]
The real line: +#endif
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if 0
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  
LINE TO PARSE FOR KEYWORD:#if 0
Depths: 0:0
[]
The real line: +/** Very similar to TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T but hash
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +table search is not performed at all. */
The real line: +#define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  
LINE TO PARSE FOR KEYWORD:#define test_do_not_check_for_duplicate_rows
Depths: 0:0
[]
The real line: +#endif
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if 0
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  
LINE TO PARSE FOR KEYWORD:#if 0
Depths: 0:0
[]
The real line: +/** Do not insert each row into the hash table, duplicates may appear
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +if this is enabled, also if this is enabled searching into the hash is
The real line: +noop because it will be empty. */
The real line: +#define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  
LINE TO PARSE FOR KEYWORD:#define test_do_not_insert_into_the_hash_table
Depths: 0:0
[]
The real line: +#endif
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +/* @} */
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** Memory limit passed to ha_storage_put_memlim().
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +@param cache	hash storage
The real line: +@return		maximum allowed allocation size */
The real line: +#define MAX_ALLOWED_FOR_STORAGE(cache)		\
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    
LINE TO PARSE FOR KEYWORD:#define max_allowed_for_storage(cache)		\
Depths: 0:0
[]
The real line: +	(TRX_I_S_MEM_LIMIT			\
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 
LINE TO PARSE FOR KEYWORD:	(trx_i_s_mem_limit			\
Depths: 0:0
[]
The real line: +	 - (cache)->mem_allocd)
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 
LINE TO PARSE FOR KEYWORD:	 - (cache)->mem_allocd)
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** Memory limit in table_cache_create_empty_row().
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +@param cache	hash storage
The real line: +@return		maximum allowed allocation size */
The real line: +#define MAX_ALLOWED_FOR_ALLOC(cache)		\
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   
LINE TO PARSE FOR KEYWORD:#define max_allowed_for_alloc(cache)		\
Depths: 0:0
[]
The real line: +	(TRX_I_S_MEM_LIMIT			\
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 
LINE TO PARSE FOR KEYWORD:	(trx_i_s_mem_limit			\
Depths: 0:0
[]
The real line: +	 - (cache)->mem_allocd			\
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 
LINE TO PARSE FOR KEYWORD:	 - (cache)->mem_allocd			\
Depths: 0:0
[]
The real line: +	 - ha_storage_get_size((cache)->storage))
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd			\ 
LINE TO PARSE FOR KEYWORD:	 - ha_storage_get_size((cache)->storage))
Depths: 0:0
[]
The real line: +
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd			\ 	 - ha_storage_get_size((cache)->storage)) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** Memory for each table in the intermediate buffer is allocated in
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd			\ 	 - ha_storage_get_size((cache)->storage))  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +separate chunks. These chunks are considered to be concatenated to
The real line: +represent one flat array of rows. */
The real line: +typedef struct i_s_mem_chunk_struct {
Current Name Search:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd			\ 	 - ha_storage_get_size((cache)->storage))   
Checking if function:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd			\ 	 - ha_storage_get_size((cache)->storage))   typedef struct i_s_mem_chunk_struct {
Other type of bracket:      #include   #include <mysql/plugin.h>  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include  #include    #define TABLE_CACHE_INITIAL_ROWSNUM	1024   #define MEM_CHUNKS_IN_TABLE_CACHE	39     #if 0  #define TEST_LOCK_FOLD_ALWAYS_DIFFERENT #endif  #if 0  #define TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T #endif  #if 0  #define TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES #endif  #if 0  #define TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS #endif  #if 0  #define TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE #endif    #define MAX_ALLOWED_FOR_STORAGE(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd)   #define MAX_ALLOWED_FOR_ALLOC(cache)		\ 	(TRX_I_S_MEM_LIMIT			\ 	 - (cache)->mem_allocd			\ 	 - ha_storage_get_size((cache)->storage))   typedef struct i_s_mem_chunk_struct {
LINE TO PARSE FOR KEYWORD:typedef struct i_s_mem_chunk_struct {
Depths: 1:1
[]
The real line: +	ulint	offset;		/*!< offset, in number of rows */
Current Name Search: 
LINE TO PARSE FOR KEYWORD:	ulint	offset;		
Depths: 1:1
[]
The real line: +	ulint	rows_allocd;	/*!< the size of this chunk, in number
Current Name Search: 	ulint	offset;		 
LINE TO PARSE FOR KEYWORD:	ulint	rows_allocd;	
Depths: 1:1
[]
The real line: +				of rows */
The real line: +	void*	base;		/*!< start of the chunk */
Current Name Search: 	ulint	rows_allocd;	 
LINE TO PARSE FOR KEYWORD:	void*	base;		
Depths: 1:1
[]
The real line: +} i_s_mem_chunk_t;
Current Name Search: 	void*	base;		 
LINE TO PARSE FOR KEYWORD:} i_s_mem_chunk_t;
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: } i_s_mem_chunk_t; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** This represents one table's cache. */
Current Name Search: } i_s_mem_chunk_t;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +typedef struct i_s_table_cache_struct {
Current Name Search: } i_s_mem_chunk_t;   
Checking if function: } i_s_mem_chunk_t;   typedef struct i_s_table_cache_struct {
Other type of bracket: } i_s_mem_chunk_t;   typedef struct i_s_table_cache_struct {
LINE TO PARSE FOR KEYWORD:typedef struct i_s_table_cache_struct {
Depths: 1:1
[]
The real line: +	ulint		rows_used;	/*!< number of used rows */
Current Name Search: 
LINE TO PARSE FOR KEYWORD:	ulint		rows_used;	
Depths: 1:1
[]
The real line: +	ulint		rows_allocd;	/*!< number of allocated rows */
Current Name Search: 	ulint		rows_used;	 
LINE TO PARSE FOR KEYWORD:	ulint		rows_allocd;	
Depths: 1:1
[]
The real line: +	ulint		row_size;	/*!< size of a single row */
Current Name Search: 	ulint		rows_allocd;	 
LINE TO PARSE FOR KEYWORD:	ulint		row_size;	
Depths: 1:1
[]
The real line: +	i_s_mem_chunk_t	chunks[MEM_CHUNKS_IN_TABLE_CACHE]; /*!< array of
Current Name Search: 	ulint		row_size;	 
LINE TO PARSE FOR KEYWORD:	i_s_mem_chunk_t	chunks[mem_chunks_in_table_cache]; 
Depths: 1:1
[]
The real line: +					memory chunks that stores the
The real line: +					rows */
The real line: +} i_s_table_cache_t;
Current Name Search: 	i_s_mem_chunk_t	chunks[MEM_CHUNKS_IN_TABLE_CACHE];  
LINE TO PARSE FOR KEYWORD:} i_s_table_cache_t;
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: } i_s_table_cache_t; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** This structure describes the intermediate buffer */
Current Name Search: } i_s_table_cache_t;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +struct trx_i_s_cache_struct {
Current Name Search: } i_s_table_cache_t;   
Checking if function: } i_s_table_cache_t;   struct trx_i_s_cache_struct {
Other type of bracket: } i_s_table_cache_t;   struct trx_i_s_cache_struct {
LINE TO PARSE FOR KEYWORD:struct trx_i_s_cache_struct {
Depths: 1:1
[]
The real line: +	rw_lock_t	rw_lock;	/*!< read-write lock protecting
Current Name Search: 
LINE TO PARSE FOR KEYWORD:	rw_lock_t	rw_lock;	
Depths: 1:1
[]
The real line: +					the rest of this structure */
The real line: +	ullint		last_read;	/*!< last time the cache was read;
Current Name Search: 	rw_lock_t	rw_lock;	 
LINE TO PARSE FOR KEYWORD:	ullint		last_read;	
Depths: 1:1
[]
The real line: +					measured in microseconds since
The real line: +					epoch */
The real line: +	mutex_t		last_read_mutex;/*!< mutex protecting the
Current Name Search: 	ullint		last_read;	 
LINE TO PARSE FOR KEYWORD:	mutex_t		last_read_mutex;
Depths: 1:1
[]
The real line: +					last_read member - it is updated
The real line: +					inside a shared lock of the
The real line: +					rw_lock member */
The real line: +	i_s_table_cache_t innodb_trx;	/*!< innodb_trx table */
Current Name Search: 	mutex_t		last_read_mutex; 
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t innodb_trx;	
Depths: 1:1
[]
The real line: +	i_s_table_cache_t innodb_locks;	/*!< innodb_locks table */
Current Name Search: 	i_s_table_cache_t innodb_trx;	 
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t innodb_locks;	
Depths: 1:1
[]
The real line: +	i_s_table_cache_t innodb_lock_waits;/*!< innodb_lock_waits table */
Current Name Search: 	i_s_table_cache_t innodb_locks;	 
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t innodb_lock_waits;
Depths: 1:1
[]
The real line: +/** the hash table size is LOCKS_HASH_CELLS_NUM * sizeof(void*) bytes */
Current Name Search: 	i_s_table_cache_t innodb_lock_waits; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#define LOCKS_HASH_CELLS_NUM		10000
Current Name Search: 	i_s_table_cache_t innodb_lock_waits;  
LINE TO PARSE FOR KEYWORD:#define locks_hash_cells_num		10000
Depths: 1:1
[]
The real line: +	hash_table_t*	locks_hash;	/*!< hash table used to eliminate
Current Name Search: 	i_s_table_cache_t innodb_lock_waits;  #define LOCKS_HASH_CELLS_NUM		10000 
LINE TO PARSE FOR KEYWORD:	hash_table_t*	locks_hash;	
Depths: 1:1
[]
The real line: +					duplicate entries in the
The real line: +					innodb_locks table */
The real line: +/** Initial size of the cache storage */
Current Name Search: 	hash_table_t*	locks_hash;	 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#define CACHE_STORAGE_INITIAL_SIZE	1024
Current Name Search: 	hash_table_t*	locks_hash;	  
LINE TO PARSE FOR KEYWORD:#define cache_storage_initial_size	1024
Depths: 1:1
[]
The real line: +/** Number of hash cells in the cache storage */
Current Name Search: 	hash_table_t*	locks_hash;	  #define CACHE_STORAGE_INITIAL_SIZE	1024 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#define CACHE_STORAGE_HASH_CELLS	2048
Current Name Search: 	hash_table_t*	locks_hash;	  #define CACHE_STORAGE_INITIAL_SIZE	1024  
LINE TO PARSE FOR KEYWORD:#define cache_storage_hash_cells	2048
Depths: 1:1
[]
The real line: +	ha_storage_t*	storage;	/*!< storage for external volatile
Current Name Search: 	hash_table_t*	locks_hash;	  #define CACHE_STORAGE_INITIAL_SIZE	1024  #define CACHE_STORAGE_HASH_CELLS	2048 
LINE TO PARSE FOR KEYWORD:	ha_storage_t*	storage;	
Depths: 1:1
[]
The real line: +					data that can possibly not be
The real line: +					available later, when we release
The real line: +					the kernel mutex */
The real line: +	ulint		mem_allocd;	/*!< the amount of memory
Current Name Search: 	ha_storage_t*	storage;	 
LINE TO PARSE FOR KEYWORD:	ulint		mem_allocd;	
Depths: 1:1
[]
The real line: +					allocated with mem_alloc*() */
The real line: +	ibool		is_truncated;	/*!< this is TRUE if the memory
Current Name Search: 	ulint		mem_allocd;	 
LINE TO PARSE FOR KEYWORD:	ibool		is_truncated;	
Depths: 1:1
[]
The real line: +					limit was hit and thus the data
The real line: +					in the cache is truncated */
The real line: +};
Current Name Search: 	ibool		is_truncated;	 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** This is the intermediate buffer where data needed to fill the
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +INFORMATION SCHEMA tables is fetched and later retrieved by the C++
The real line: +code in handler/i_s.cc. */
The real line: +static trx_i_s_cache_t	trx_i_s_cache_static;
Current Name Search: };   
LINE TO PARSE FOR KEYWORD:static trx_i_s_cache_t	trx_i_s_cache_static;
Depths: 0:0
[]
The real line: +/** This is the intermediate buffer where data needed to fill the
Current Name Search: static trx_i_s_cache_t	trx_i_s_cache_static; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +INFORMATION SCHEMA tables is fetched and later retrieved by the C++
The real line: +code in handler/i_s.cc. */
The real line: +UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;
Current Name Search: static trx_i_s_cache_t	trx_i_s_cache_static;  
LINE TO PARSE FOR KEYWORD:univ_intern trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;
Depths: 0:0
[]
The real line: +
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +For a record lock that is in waiting state retrieves the only bit that
The real line: +is set, for a table lock returns ULINT_UNDEFINED.
The real line: +@return	record number within the heap */
The real line: +static
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ulint
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   static 
LINE TO PARSE FOR KEYWORD:ulint
Depths: 0:0
[]
The real line: +wait_lock_get_heap_no(
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   static ulint 
LINE TO PARSE FOR KEYWORD:wait_lock_get_heap_no(
Depths: 0:0
[]
The real line: +/*==================*/
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   static ulint wait_lock_get_heap_no( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	const lock_t*	lock)	/*!< in: lock */
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   static ulint wait_lock_get_heap_no(  
LINE TO PARSE FOR KEYWORD:	const lock_t*	lock)	
Depths: 0:0
[]
The real line: +{
Current Name Search: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   static ulint wait_lock_get_heap_no(  	const lock_t*	lock)	 
Checking if function: UNIV_INTERN trx_i_s_cache_t*	trx_i_s_cache = &trx_i_s_cache_static;   static ulint wait_lock_get_heap_no(  	const lock_t*	lock)	 {
PATTERN 1
Function:  ulint wait_lock_get_heap_no( lock_t*lock) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint	ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint	ret;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	switch (lock_get_type(lock)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	switch (lock_get_type(lock)) {
The real line: +	case LOCK_REC:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_rec:
The real line: +		ret = lock_rec_find_set_bit(lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = lock_rec_find_set_bit(lock);
The real line: +		ut_a(ret != ULINT_UNDEFINED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(ret != ulint_undefined);
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	case LOCK_TABLE:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_table:
The real line: +		ret = ULINT_UNDEFINED;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = ulint_undefined;
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	default:
End Check: 2
LINE TO PARSE FOR KEYWORD:	default:
The real line: +		ut_error;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_error;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
205 : 221
Next: ( lock_t*lock)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Initializes the members of a table cache. */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +void
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +table_cache_init(
Current Name Search:   static void 
LINE TO PARSE FOR KEYWORD:table_cache_init(
Depths: 0:0
[]
The real line: +/*=============*/
Current Name Search:   static void table_cache_init( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	i_s_table_cache_t*	table_cache,	/*!< out: table cache */
Current Name Search:   static void table_cache_init(  
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t*	table_cache,	
Depths: 0:0
[]
The real line: +	size_t			row_size)	/*!< in: the size of a
Current Name Search:   static void table_cache_init(  	i_s_table_cache_t*	table_cache,	 
LINE TO PARSE FOR KEYWORD:	size_t			row_size)	
Depths: 0:0
[]
The real line: +						row */
The real line: +{
Current Name Search:   static void table_cache_init(  	i_s_table_cache_t*	table_cache,	 	size_t			row_size)	 
Checking if function:   static void table_cache_init(  	i_s_table_cache_t*	table_cache,	 	size_t			row_size)	 {
PATTERN 1
Function:  void table_cache_init(  i_s_table_cache_t*table_cache, size_trow_size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint	i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint	i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	table_cache->rows_used = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache->rows_used = 0;
The real line: +	table_cache->rows_allocd = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache->rows_allocd = 0;
The real line: +	table_cache->row_size = row_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache->row_size = row_size;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < MEM_CHUNKS_IN_TABLE_CACHE; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < mem_chunks_in_table_cache; i++) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* the memory is actually allocated in
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		table_cache_create_empty_row() */
The real line: +		table_cache->chunks[i].base = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		table_cache->chunks[i].base = null;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
232 : 245
Next: (  i_s_table_cache_t*table_cache, size_trow_size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Frees a table cache. */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +void
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +table_cache_free(
Current Name Search:   static void 
LINE TO PARSE FOR KEYWORD:table_cache_free(
Depths: 0:0
[]
The real line: +/*=============*/
Current Name Search:   static void table_cache_free( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	i_s_table_cache_t*	table_cache)	/*!< in/out: table cache */
Current Name Search:   static void table_cache_free(  
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t*	table_cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   static void table_cache_free(  	i_s_table_cache_t*	table_cache)	 
Checking if function:   static void table_cache_free(  	i_s_table_cache_t*	table_cache)	 {
PATTERN 1
Function:  void table_cache_free(  i_s_table_cache_t*table_cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint	i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint	i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < MEM_CHUNKS_IN_TABLE_CACHE; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < mem_chunks_in_table_cache; i++) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* the memory is actually allocated in
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		table_cache_create_empty_row() */
The real line: +		if (table_cache->chunks[i].base) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (table_cache->chunks[i].base) {
The real line: +			mem_free(table_cache->chunks[i].base);
End Check: 3
LINE TO PARSE FOR KEYWORD:			mem_free(table_cache->chunks[i].base);
The real line: +			table_cache->chunks[i].base = NULL;
End Check: 3
LINE TO PARSE FOR KEYWORD:			table_cache->chunks[i].base = null;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
254 : 266
Next: (  i_s_table_cache_t*table_cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Returns an empty row from a table cache. The row is allocated if no more
The real line: +empty rows are available. The number of used rows is incremented.
The real line: +If the memory limit is hit then NULL is returned and nothing is
The real line: +allocated.
The real line: +@return	empty row, or NULL if out of memory */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +void*
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:void*
Depths: 0:0
[]
The real line: +table_cache_create_empty_row(
Current Name Search:   static void* 
LINE TO PARSE FOR KEYWORD:table_cache_create_empty_row(
Depths: 0:0
[]
The real line: +/*=========================*/
Current Name Search:   static void* table_cache_create_empty_row( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	i_s_table_cache_t*	table_cache,	/*!< in/out: table cache */
Current Name Search:   static void* table_cache_create_empty_row(  
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t*	table_cache,	
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)		/*!< in/out: cache to record
Current Name Search:   static void* table_cache_create_empty_row(  	i_s_table_cache_t*	table_cache,	 
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)		
Depths: 0:0
[]
The real line: +						how many bytes are
The real line: +						allocated */
The real line: +{
Current Name Search:   static void* table_cache_create_empty_row(  	i_s_table_cache_t*	table_cache,	 	trx_i_s_cache_t*	cache)		 
Checking if function:   static void* table_cache_create_empty_row(  	i_s_table_cache_t*	table_cache,	 	trx_i_s_cache_t*	cache)		 {
PATTERN 1
Function:  void* table_cache_create_empty_row(  i_s_table_cache_t*table_cache, trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ulint	i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint	i;
The real line: +	void*	row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void*	row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_a(table_cache->rows_used <= table_cache->rows_allocd);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(table_cache->rows_used <= table_cache->rows_allocd);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (table_cache->rows_used == table_cache->rows_allocd) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (table_cache->rows_used == table_cache->rows_allocd) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* rows_used == rows_allocd means that new chunk needs
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		to be allocated: either no more empty rows in the
The real line: +		last allocated chunk or nothing has been allocated yet
The real line: +		(rows_num == rows_allocd == 0); */
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		i_s_mem_chunk_t*	chunk;
End Check: 2
LINE TO PARSE FOR KEYWORD:		i_s_mem_chunk_t*	chunk;
The real line: +		ulint			req_bytes;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			req_bytes;
The real line: +		ulint			got_bytes;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			got_bytes;
The real line: +		ulint			req_rows;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			req_rows;
The real line: +		ulint			got_rows;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			got_rows;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* find the first not allocated chunk */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		for (i = 0; i < MEM_CHUNKS_IN_TABLE_CACHE; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		for (i = 0; i < mem_chunks_in_table_cache; i++) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			if (table_cache->chunks[i].base == NULL) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (table_cache->chunks[i].base == null) {
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				break;
End Check: 4
LINE TO PARSE FOR KEYWORD:				break;
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* i == MEM_CHUNKS_IN_TABLE_CACHE means that all chunks
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		have been allocated :-X */
The real line: +		ut_a(i < MEM_CHUNKS_IN_TABLE_CACHE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(i < mem_chunks_in_table_cache);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* allocate the chunk we just found */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (i == 0) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (i == 0) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			/* first chunk, nothing is allocated yet */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			req_rows = TABLE_CACHE_INITIAL_ROWSNUM;
End Check: 3
LINE TO PARSE FOR KEYWORD:			req_rows = table_cache_initial_rowsnum;
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			/* Memory is increased by the formula
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			new = old + old / 2; We are trying not to be
The real line: +			aggressive here (= using the common new = old * 2)
The real line: +			because the allocated memory will not be freed
The real line: +			until InnoDB exit (it is reused). So it is better
The real line: +			to once allocate the memory in more steps, but
The real line: +			have less unused/wasted memory than to use less
The real line: +			steps in allocation (which is done once in a
The real line: +			lifetime) but end up with lots of unused/wasted
The real line: +			memory. */
The real line: +			req_rows = table_cache->rows_allocd / 2;
End Check: 3
LINE TO PARSE FOR KEYWORD:			req_rows = table_cache->rows_allocd / 2;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		req_bytes = req_rows * table_cache->row_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		req_bytes = req_rows * table_cache->row_size;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (req_bytes > MAX_ALLOWED_FOR_ALLOC(cache)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (req_bytes > max_allowed_for_alloc(cache)) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			return(NULL);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return(null);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk = &table_cache->chunks[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = &table_cache->chunks[i];
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk->base = mem_alloc2(req_bytes, &got_bytes);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->base = mem_alloc2(req_bytes, &got_bytes);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		got_rows = got_bytes / table_cache->row_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		got_rows = got_bytes / table_cache->row_size;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		cache->mem_allocd += got_bytes;
End Check: 2
LINE TO PARSE FOR KEYWORD:		cache->mem_allocd += got_bytes;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#if 0
End Check: 2
LINE TO PARSE FOR KEYWORD:#if 0
The real line: +		printf("allocating chunk %d req bytes=%lu, got bytes=%lu, "
End Check: 2
LINE TO PARSE FOR KEYWORD:		printf(
The real line: +		       "row size=%lu, "
End Check: 2
LINE TO PARSE FOR KEYWORD:		       
The real line: +		       "req rows=%lu, got rows=%lu\n",
End Check: 2
LINE TO PARSE FOR KEYWORD:		       ,
The real line: +		       i, req_bytes, got_bytes,
End Check: 2
LINE TO PARSE FOR KEYWORD:		       i, req_bytes, got_bytes,
The real line: +		       table_cache->row_size,
End Check: 2
LINE TO PARSE FOR KEYWORD:		       table_cache->row_size,
The real line: +		       req_rows, got_rows);
End Check: 2
LINE TO PARSE FOR KEYWORD:		       req_rows, got_rows);
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk->rows_allocd = got_rows;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->rows_allocd = got_rows;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		table_cache->rows_allocd += got_rows;
End Check: 2
LINE TO PARSE FOR KEYWORD:		table_cache->rows_allocd += got_rows;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* adjust the offset of the next chunk */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		if (i < MEM_CHUNKS_IN_TABLE_CACHE - 1) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (i < mem_chunks_in_table_cache - 1) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			table_cache->chunks[i + 1].offset
End Check: 3
LINE TO PARSE FOR KEYWORD:			table_cache->chunks[i + 1].offset
The real line: +				= chunk->offset + chunk->rows_allocd;
End Check: 3
LINE TO PARSE FOR KEYWORD:				= chunk->offset + chunk->rows_allocd;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* return the first empty row in the newly allocated
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		chunk */
The real line: +		row = chunk->base;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row = chunk->base;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		char*	chunk_start;
End Check: 2
LINE TO PARSE FOR KEYWORD:		char*	chunk_start;
The real line: +		ulint	offset;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint	offset;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* there is an empty row, no need to allocate new
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		chunks */
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* find the first chunk that contains allocated but
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		empty/unused rows */
The real line: +		for (i = 0; i < MEM_CHUNKS_IN_TABLE_CACHE; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		for (i = 0; i < mem_chunks_in_table_cache; i++) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			if (table_cache->chunks[i].offset
End Check: 3
LINE TO PARSE FOR KEYWORD:			if (table_cache->chunks[i].offset
The real line: +			    + table_cache->chunks[i].rows_allocd
End Check: 3
LINE TO PARSE FOR KEYWORD:			    + table_cache->chunks[i].rows_allocd
The real line: +			    > table_cache->rows_used) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			    > table_cache->rows_used) {
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				break;
End Check: 4
LINE TO PARSE FOR KEYWORD:				break;
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* i == MEM_CHUNKS_IN_TABLE_CACHE means that all chunks
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		are full, but
The real line: +		table_cache->rows_used != table_cache->rows_allocd means
The real line: +		exactly the opposite - there are allocated but
The real line: +		empty/unused rows :-X */
The real line: +		ut_a(i < MEM_CHUNKS_IN_TABLE_CACHE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(i < mem_chunks_in_table_cache);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk_start = (char*) table_cache->chunks[i].base;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk_start = (char*) table_cache->chunks[i].base;
The real line: +		offset = table_cache->rows_used
End Check: 2
LINE TO PARSE FOR KEYWORD:		offset = table_cache->rows_used
The real line: +			- table_cache->chunks[i].offset;
End Check: 2
LINE TO PARSE FOR KEYWORD:			- table_cache->chunks[i].offset;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row = chunk_start + offset * table_cache->row_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row = chunk_start + offset * table_cache->row_size;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	table_cache->rows_used++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache->rows_used++;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(row);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(row);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
282 : 409
Next: (  i_s_table_cache_t*table_cache, trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Fills i_s_trx_row_t object.
The real line: +If memory can not be allocated then FALSE is returned.
The real line: +@return	FALSE if allocation fails */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +fill_trx_row(
Current Name Search:   static ibool 
LINE TO PARSE FOR KEYWORD:fill_trx_row(
Depths: 0:0
[]
The real line: +/*=========*/
Current Name Search:   static ibool fill_trx_row( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	i_s_trx_row_t*		row,		/*!< out: result object
Current Name Search:   static ibool fill_trx_row(  
LINE TO PARSE FOR KEYWORD:	i_s_trx_row_t*		row,		
Depths: 0:0
[]
The real line: +						that's filled */
The real line: +	const trx_t*		trx,		/*!< in: transaction to
Current Name Search:   static ibool fill_trx_row(  	i_s_trx_row_t*		row,		 
LINE TO PARSE FOR KEYWORD:	const trx_t*		trx,		
Depths: 0:0
[]
The real line: +						get data from */
The real line: +	const i_s_locks_row_t*	requested_lock_row,/*!< in: pointer to the
Current Name Search:   static ibool fill_trx_row(  	i_s_trx_row_t*		row,		 	const trx_t*		trx,		 
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	requested_lock_row,
Depths: 0:0
[]
The real line: +						corresponding row in
The real line: +						innodb_locks if trx is
The real line: +						waiting or NULL if trx
The real line: +						is not waiting */
The real line: +	trx_i_s_cache_t*	cache)		/*!< in/out: cache into
Current Name Search:   static ibool fill_trx_row(  	i_s_trx_row_t*		row,		 	const trx_t*		trx,		 	const i_s_locks_row_t*	requested_lock_row, 
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)		
Depths: 0:0
[]
The real line: +						which to copy volatile
The real line: +						strings */
The real line: +{
Current Name Search:   static ibool fill_trx_row(  	i_s_trx_row_t*		row,		 	const trx_t*		trx,		 	const i_s_locks_row_t*	requested_lock_row, 	trx_i_s_cache_t*	cache)		 
Checking if function:   static ibool fill_trx_row(  	i_s_trx_row_t*		row,		 	const trx_t*		trx,		 	const i_s_locks_row_t*	requested_lock_row, 	trx_i_s_cache_t*	cache)		 {
PATTERN 1
Function:  ibool fill_trx_row(  i_s_trx_row_t*row,trx_t*trx,i_s_locks_row_t*requested_lock_row, trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	row->trx_id = trx_get_id(trx);
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->trx_id = trx_get_id(trx);
The real line: +	row->trx_started = (ib_time_t) trx->start_time;
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->trx_started = (ib_time_t) trx->start_time;
The real line: +	row->trx_state = trx_get_que_state_str(trx);
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->trx_state = trx_get_que_state_str(trx);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (trx->wait_lock != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (trx->wait_lock != null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ut_a(requested_lock_row != NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(requested_lock_row != null);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row->requested_lock_row = requested_lock_row;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->requested_lock_row = requested_lock_row;
The real line: +		row->trx_wait_started = (ib_time_t) trx->wait_started;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->trx_wait_started = (ib_time_t) trx->wait_started;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ut_a(requested_lock_row == NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(requested_lock_row == null);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row->requested_lock_row = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->requested_lock_row = null;
The real line: +		row->trx_wait_started = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->trx_wait_started = 0;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	row->trx_weight = (ullint) ut_conv_dulint_to_longlong(TRX_WEIGHT(trx));
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->trx_weight = (ullint) ut_conv_dulint_to_longlong(trx_weight(trx));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (trx->mysql_thd != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (trx->mysql_thd != null) {
The real line: +		row->trx_mysql_thread_id
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->trx_mysql_thread_id
The real line: +			= thd_get_thread_id(trx->mysql_thd);
End Check: 2
LINE TO PARSE FOR KEYWORD:			= thd_get_thread_id(trx->mysql_thd);
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		/* For internal transactions e.g., purge and transactions
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		being recovered at startup there is no associated MySQL
The real line: +		thread data structure. */
The real line: +		row->trx_mysql_thread_id = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->trx_mysql_thread_id = 0;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (trx->mysql_query_str != NULL && *trx->mysql_query_str != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (trx->mysql_query_str != null && *trx->mysql_query_str != null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (strlen(*trx->mysql_query_str)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (strlen(*trx->mysql_query_str)
The real line: +		    > TRX_I_S_TRX_QUERY_MAX_LEN) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		    > trx_i_s_trx_query_max_len) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			char	query[TRX_I_S_TRX_QUERY_MAX_LEN + 1];
End Check: 3
LINE TO PARSE FOR KEYWORD:			char	query[trx_i_s_trx_query_max_len + 1];
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			memcpy(query, *trx->mysql_query_str,
End Check: 3
LINE TO PARSE FOR KEYWORD:			memcpy(query, *trx->mysql_query_str,
The real line: +			       TRX_I_S_TRX_QUERY_MAX_LEN);
End Check: 3
LINE TO PARSE FOR KEYWORD:			       trx_i_s_trx_query_max_len);
The real line: +			query[TRX_I_S_TRX_QUERY_MAX_LEN] = '\0';
End Check: 3
LINE TO PARSE FOR KEYWORD:			query[trx_i_s_trx_query_max_len] = ;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			row->trx_query = ha_storage_put_memlim(
End Check: 3
LINE TO PARSE FOR KEYWORD:			row->trx_query = ha_storage_put_memlim(
The real line: +				cache->storage, query,
End Check: 3
LINE TO PARSE FOR KEYWORD:				cache->storage, query,
The real line: +				TRX_I_S_TRX_QUERY_MAX_LEN + 1,
End Check: 3
LINE TO PARSE FOR KEYWORD:				trx_i_s_trx_query_max_len + 1,
The real line: +				MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 3
LINE TO PARSE FOR KEYWORD:				max_allowed_for_storage(cache));
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			row->trx_query = ha_storage_put_str_memlim(
End Check: 3
LINE TO PARSE FOR KEYWORD:			row->trx_query = ha_storage_put_str_memlim(
The real line: +				cache->storage, *trx->mysql_query_str,
End Check: 3
LINE TO PARSE FOR KEYWORD:				cache->storage, *trx->mysql_query_str,
The real line: +				MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 3
LINE TO PARSE FOR KEYWORD:				max_allowed_for_storage(cache));
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (row->trx_query == NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (row->trx_query == null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			return(FALSE);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return(false);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row->trx_query = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->trx_query = null;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(TRUE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
431 : 494
Next: (  i_s_trx_row_t*row,trx_t*trx,i_s_locks_row_t*requested_lock_row, trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Format the nth field of "rec" and put it in "buf". The result is always
The real line: +NUL-terminated. Returns the number of bytes that were written to "buf"
The real line: +(including the terminating NUL).
The real line: +@return	end of the result */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ulint
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ulint
Depths: 0:0
[]
The real line: +put_nth_field(
Current Name Search:   static ulint 
LINE TO PARSE FOR KEYWORD:put_nth_field(
Depths: 0:0
[]
The real line: +/*==========*/
Current Name Search:   static ulint put_nth_field( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	char*			buf,	/*!< out: buffer */
Current Name Search:   static ulint put_nth_field(  
LINE TO PARSE FOR KEYWORD:	char*			buf,	
Depths: 0:0
[]
The real line: +	ulint			buf_size,/*!< in: buffer size in bytes */
Current Name Search:   static ulint put_nth_field(  	char*			buf,	 
LINE TO PARSE FOR KEYWORD:	ulint			buf_size,
Depths: 0:0
[]
The real line: +	ulint			n,	/*!< in: number of field */
Current Name Search:   static ulint put_nth_field(  	char*			buf,	 	ulint			buf_size, 
LINE TO PARSE FOR KEYWORD:	ulint			n,	
Depths: 0:0
[]
The real line: +	const dict_index_t*	index,	/*!< in: index */
Current Name Search:   static ulint put_nth_field(  	char*			buf,	 	ulint			buf_size, 	ulint			n,	 
LINE TO PARSE FOR KEYWORD:	const dict_index_t*	index,	
Depths: 0:0
[]
The real line: +	const rec_t*		rec,	/*!< in: record */
Current Name Search:   static ulint put_nth_field(  	char*			buf,	 	ulint			buf_size, 	ulint			n,	 	const dict_index_t*	index,	 
LINE TO PARSE FOR KEYWORD:	const rec_t*		rec,	
Depths: 0:0
[]
The real line: +	const ulint*		offsets)/*!< in: record offsets, returned
Current Name Search:   static ulint put_nth_field(  	char*			buf,	 	ulint			buf_size, 	ulint			n,	 	const dict_index_t*	index,	 	const rec_t*		rec,	 
LINE TO PARSE FOR KEYWORD:	const ulint*		offsets)
Depths: 0:0
[]
The real line: +					by rec_get_offsets() */
The real line: +{
Current Name Search:   static ulint put_nth_field(  	char*			buf,	 	ulint			buf_size, 	ulint			n,	 	const dict_index_t*	index,	 	const rec_t*		rec,	 	const ulint*		offsets) 
Checking if function:   static ulint put_nth_field(  	char*			buf,	 	ulint			buf_size, 	ulint			n,	 	const dict_index_t*	index,	 	const rec_t*		rec,	 	const ulint*		offsets) {
PATTERN 1
Function:  ulint put_nth_field(  char*buf, ulintbuf_size, ulintn,dict_index_t*index,rec_t*rec,ulint*offsets) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	const byte*	data;
End Check: 1
LINE TO PARSE FOR KEYWORD:	const byte*	data;
The real line: +	ulint		data_len;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint		data_len;
The real line: +	dict_field_t*	dict_field;
End Check: 1
LINE TO PARSE FOR KEYWORD:	dict_field_t*	dict_field;
The real line: +	ulint		ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint		ret;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_ad(rec_offs_validate(rec, NULL, offsets));
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_ad(rec_offs_validate(rec, null, offsets));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (buf_size == 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (buf_size == 0) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(0);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ret = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (n > 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (n > 0) {
The real line: +		/* we must append ", " before the actual data */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (buf_size < 3) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (buf_size < 3) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			buf[0] = '\0';
End Check: 3
LINE TO PARSE FOR KEYWORD:			buf[0] = ;
The real line: +			return(1);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return(1);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		memcpy(buf, ", ", 3);
End Check: 2
LINE TO PARSE FOR KEYWORD:		memcpy(buf, , 3);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		buf += 2;
End Check: 2
LINE TO PARSE FOR KEYWORD:		buf += 2;
The real line: +		buf_size -= 2;
End Check: 2
LINE TO PARSE FOR KEYWORD:		buf_size -= 2;
The real line: +		ret += 2;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret += 2;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* now buf_size >= 1 */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	data = rec_get_nth_field(rec, offsets, n, &data_len);
End Check: 1
LINE TO PARSE FOR KEYWORD:	data = rec_get_nth_field(rec, offsets, n, &data_len);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	dict_field = dict_index_get_nth_field(index, n);
End Check: 1
LINE TO PARSE FOR KEYWORD:	dict_field = dict_index_get_nth_field(index, n);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ret += row_raw_format((const char*) data, data_len,
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret += row_raw_format((const char*) data, data_len,
The real line: +			      dict_field, buf, buf_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:			      dict_field, buf, buf_size);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
512 : 553
Next: (  char*buf, ulintbuf_size, ulintn,dict_index_t*index,rec_t*rec,ulint*offsets)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Fills the "lock_data" member of i_s_locks_row_t object.
The real line: +If memory can not be allocated then FALSE is returned.
The real line: +@return	FALSE if allocation fails */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +fill_lock_data(
Current Name Search:   static ibool 
LINE TO PARSE FOR KEYWORD:fill_lock_data(
Depths: 0:0
[]
The real line: +/*===========*/
Current Name Search:   static ibool fill_lock_data( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	const char**		lock_data,/*!< out: "lock_data" to fill */
Current Name Search:   static ibool fill_lock_data(  
LINE TO PARSE FOR KEYWORD:	const char**		lock_data,
Depths: 0:0
[]
The real line: +	const lock_t*		lock,	/*!< in: lock used to find the data */
Current Name Search:   static ibool fill_lock_data(  	const char**		lock_data, 
LINE TO PARSE FOR KEYWORD:	const lock_t*		lock,	
Depths: 0:0
[]
The real line: +	ulint			heap_no,/*!< in: rec num used to find the data */
Current Name Search:   static ibool fill_lock_data(  	const char**		lock_data, 	const lock_t*		lock,	 
LINE TO PARSE FOR KEYWORD:	ulint			heap_no,
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in/out: cache where to store
Current Name Search:   static ibool fill_lock_data(  	const char**		lock_data, 	const lock_t*		lock,	 	ulint			heap_no, 
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +					volatile data */
The real line: +{
Current Name Search:   static ibool fill_lock_data(  	const char**		lock_data, 	const lock_t*		lock,	 	ulint			heap_no, 	trx_i_s_cache_t*	cache)	 
Checking if function:   static ibool fill_lock_data(  	const char**		lock_data, 	const lock_t*		lock,	 	ulint			heap_no, 	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  ibool fill_lock_data( char**lock_data,lock_t*lock, ulintheap_no, trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	mtr_t			mtr;
End Check: 1
LINE TO PARSE FOR KEYWORD:	mtr_t			mtr;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	const buf_block_t*	block;
End Check: 1
LINE TO PARSE FOR KEYWORD:	const buf_block_t*	block;
The real line: +	const page_t*		page;
End Check: 1
LINE TO PARSE FOR KEYWORD:	const page_t*		page;
The real line: +	const rec_t*		rec;
End Check: 1
LINE TO PARSE FOR KEYWORD:	const rec_t*		rec;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_a(lock_get_type(lock) == LOCK_REC);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(lock_get_type(lock) == lock_rec);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	mtr_start(&mtr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mtr_start(&mtr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	block = buf_page_try_get(lock_rec_get_space_id(lock),
End Check: 1
LINE TO PARSE FOR KEYWORD:	block = buf_page_try_get(lock_rec_get_space_id(lock),
The real line: +				 lock_rec_get_page_no(lock),
End Check: 1
LINE TO PARSE FOR KEYWORD:				 lock_rec_get_page_no(lock),
The real line: +				 &mtr);
End Check: 1
LINE TO PARSE FOR KEYWORD:				 &mtr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (block == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (block == null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		*lock_data = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		*lock_data = null;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		mtr_commit(&mtr);
End Check: 2
LINE TO PARSE FOR KEYWORD:		mtr_commit(&mtr);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(TRUE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(true);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	page = (const page_t*) buf_block_get_frame(block);
End Check: 1
LINE TO PARSE FOR KEYWORD:	page = (const page_t*) buf_block_get_frame(block);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	rec = page_find_rec_with_heap_no(page, heap_no);
End Check: 1
LINE TO PARSE FOR KEYWORD:	rec = page_find_rec_with_heap_no(page, heap_no);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (page_rec_is_infimum(rec)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (page_rec_is_infimum(rec)) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		*lock_data = ha_storage_put_str_memlim(
End Check: 2
LINE TO PARSE FOR KEYWORD:		*lock_data = ha_storage_put_str_memlim(
The real line: +			cache->storage, "infimum pseudo-record",
End Check: 2
LINE TO PARSE FOR KEYWORD:			cache->storage, ,
The real line: +			MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 2
LINE TO PARSE FOR KEYWORD:			max_allowed_for_storage(cache));
The real line: +	} else if (page_rec_is_supremum(rec)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else if (page_rec_is_supremum(rec)) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		*lock_data = ha_storage_put_str_memlim(
End Check: 2
LINE TO PARSE FOR KEYWORD:		*lock_data = ha_storage_put_str_memlim(
The real line: +			cache->storage, "supremum pseudo-record",
End Check: 2
LINE TO PARSE FOR KEYWORD:			cache->storage, ,
The real line: +			MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 2
LINE TO PARSE FOR KEYWORD:			max_allowed_for_storage(cache));
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		const dict_index_t*	index;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const dict_index_t*	index;
The real line: +		ulint			n_fields;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			n_fields;
The real line: +		mem_heap_t*		heap;
End Check: 2
LINE TO PARSE FOR KEYWORD:		mem_heap_t*		heap;
The real line: +		ulint			offsets_onstack[REC_OFFS_NORMAL_SIZE];
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			offsets_onstack[rec_offs_normal_size];
The real line: +		ulint*			offsets;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint*			offsets;
The real line: +		char			buf[TRX_I_S_LOCK_DATA_MAX_LEN];
End Check: 2
LINE TO PARSE FOR KEYWORD:		char			buf[trx_i_s_lock_data_max_len];
The real line: +		ulint			buf_used;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			buf_used;
The real line: +		ulint			i;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			i;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		rec_offs_init(offsets_onstack);
End Check: 2
LINE TO PARSE FOR KEYWORD:		rec_offs_init(offsets_onstack);
The real line: +		offsets = offsets_onstack;
End Check: 2
LINE TO PARSE FOR KEYWORD:		offsets = offsets_onstack;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		index = lock_rec_get_index(lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		index = lock_rec_get_index(lock);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		n_fields = dict_index_get_n_unique(index);
End Check: 2
LINE TO PARSE FOR KEYWORD:		n_fields = dict_index_get_n_unique(index);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ut_a(n_fields > 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(n_fields > 0);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		heap = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		heap = null;
The real line: +		offsets = rec_get_offsets(rec, index, offsets, n_fields,
End Check: 2
LINE TO PARSE FOR KEYWORD:		offsets = rec_get_offsets(rec, index, offsets, n_fields,
The real line: +					  &heap);
End Check: 2
LINE TO PARSE FOR KEYWORD:					  &heap);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* format and store the data */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		buf_used = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:		buf_used = 0;
The real line: +		for (i = 0; i < n_fields; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		for (i = 0; i < n_fields; i++) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			buf_used += put_nth_field(
End Check: 3
LINE TO PARSE FOR KEYWORD:			buf_used += put_nth_field(
The real line: +				buf + buf_used, sizeof(buf) - buf_used,
End Check: 3
LINE TO PARSE FOR KEYWORD:				buf + buf_used, sizeof(buf) - buf_used,
The real line: +				i, index, rec, offsets) - 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:				i, index, rec, offsets) - 1;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		*lock_data = (const char*) ha_storage_put_memlim(
End Check: 2
LINE TO PARSE FOR KEYWORD:		*lock_data = (const char*) ha_storage_put_memlim(
The real line: +			cache->storage, buf, buf_used + 1,
End Check: 2
LINE TO PARSE FOR KEYWORD:			cache->storage, buf, buf_used + 1,
The real line: +			MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 2
LINE TO PARSE FOR KEYWORD:			max_allowed_for_storage(cache));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (UNIV_UNLIKELY(heap != NULL)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (univ_unlikely(heap != null)) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			/* this means that rec_get_offsets() has created a new
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			heap and has stored offsets in it; check that this is
The real line: +			really the case and free the heap */
The real line: +			ut_a(offsets != offsets_onstack);
End Check: 3
LINE TO PARSE FOR KEYWORD:			ut_a(offsets != offsets_onstack);
The real line: +			mem_heap_free(heap);
End Check: 3
LINE TO PARSE FOR KEYWORD:			mem_heap_free(heap);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	mtr_commit(&mtr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mtr_commit(&mtr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (*lock_data == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (*lock_data == null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(FALSE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(false);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(TRUE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
568 : 662
Next: ( char**lock_data,lock_t*lock, ulintheap_no, trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Fills i_s_locks_row_t object. Returns its first argument.
The real line: +If memory can not be allocated then FALSE is returned.
The real line: +@return	FALSE if allocation fails */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +fill_locks_row(
Current Name Search:   static ibool 
LINE TO PARSE FOR KEYWORD:fill_locks_row(
Depths: 0:0
[]
The real line: +/*===========*/
Current Name Search:   static ibool fill_locks_row( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	i_s_locks_row_t* row,	/*!< out: result object that's filled */
Current Name Search:   static ibool fill_locks_row(  
LINE TO PARSE FOR KEYWORD:	i_s_locks_row_t* row,	
Depths: 0:0
[]
The real line: +	const lock_t*	lock,	/*!< in: lock to get data from */
Current Name Search:   static ibool fill_locks_row(  	i_s_locks_row_t* row,	 
LINE TO PARSE FOR KEYWORD:	const lock_t*	lock,	
Depths: 0:0
[]
The real line: +	ulint		heap_no,/*!< in: lock's record number
Current Name Search:   static ibool fill_locks_row(  	i_s_locks_row_t* row,	 	const lock_t*	lock,	 
LINE TO PARSE FOR KEYWORD:	ulint		heap_no,
Depths: 0:0
[]
The real line: +				or ULINT_UNDEFINED if the lock
The real line: +				is a table lock */
The real line: +	trx_i_s_cache_t* cache)	/*!< in/out: cache into which to copy
Current Name Search:   static ibool fill_locks_row(  	i_s_locks_row_t* row,	 	const lock_t*	lock,	 	ulint		heap_no, 
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t* cache)	
Depths: 0:0
[]
The real line: +				volatile strings */
The real line: +{
Current Name Search:   static ibool fill_locks_row(  	i_s_locks_row_t* row,	 	const lock_t*	lock,	 	ulint		heap_no, 	trx_i_s_cache_t* cache)	 
Checking if function:   static ibool fill_locks_row(  	i_s_locks_row_t* row,	 	const lock_t*	lock,	 	ulint		heap_no, 	trx_i_s_cache_t* cache)	 {
PATTERN 1
Function:  ibool fill_locks_row(  i_s_locks_row_t* row,lock_t*lock, ulintheap_no, trx_i_s_cache_t* cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	row->lock_trx_id = lock_get_trx_id(lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->lock_trx_id = lock_get_trx_id(lock);
The real line: +	row->lock_mode = lock_get_mode_str(lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->lock_mode = lock_get_mode_str(lock);
The real line: +	row->lock_type = lock_get_type_str(lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->lock_type = lock_get_type_str(lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	row->lock_table = ha_storage_put_str_memlim(
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->lock_table = ha_storage_put_str_memlim(
The real line: +		cache->storage, lock_get_table_name(lock),
End Check: 1
LINE TO PARSE FOR KEYWORD:		cache->storage, lock_get_table_name(lock),
The real line: +		MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 1
LINE TO PARSE FOR KEYWORD:		max_allowed_for_storage(cache));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* memory could not be allocated */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (row->lock_table == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (row->lock_table == null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(FALSE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(false);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	switch (lock_get_type(lock)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	switch (lock_get_type(lock)) {
The real line: +	case LOCK_REC:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_rec:
The real line: +		row->lock_index = ha_storage_put_str_memlim(
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_index = ha_storage_put_str_memlim(
The real line: +			cache->storage, lock_rec_get_index_name(lock),
End Check: 2
LINE TO PARSE FOR KEYWORD:			cache->storage, lock_rec_get_index_name(lock),
The real line: +			MAX_ALLOWED_FOR_STORAGE(cache));
End Check: 2
LINE TO PARSE FOR KEYWORD:			max_allowed_for_storage(cache));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* memory could not be allocated */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		if (row->lock_index == NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (row->lock_index == null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			return(FALSE);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return(false);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row->lock_space = lock_rec_get_space_id(lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_space = lock_rec_get_space_id(lock);
The real line: +		row->lock_page = lock_rec_get_page_no(lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_page = lock_rec_get_page_no(lock);
The real line: +		row->lock_rec = heap_no;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_rec = heap_no;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (!fill_lock_data(&row->lock_data, lock, heap_no, cache)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (!fill_lock_data(&row->lock_data, lock, heap_no, cache)) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			/* memory could not be allocated */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			return(FALSE);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return(false);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	case LOCK_TABLE:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_table:
The real line: +		row->lock_index = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_index = null;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row->lock_space = ULINT_UNDEFINED;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_space = ulint_undefined;
The real line: +		row->lock_page = ULINT_UNDEFINED;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_page = ulint_undefined;
The real line: +		row->lock_rec = ULINT_UNDEFINED;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_rec = ulint_undefined;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		row->lock_data = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		row->lock_data = null;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	default:
End Check: 2
LINE TO PARSE FOR KEYWORD:	default:
The real line: +		ut_error;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_error;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	row->lock_table_id = lock_get_table_id(lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->lock_table_id = lock_get_table_id(lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	row->hash_chain.value = row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->hash_chain.value = row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(TRUE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
679 : 736
Next: (  i_s_locks_row_t* row,lock_t*lock, ulintheap_no, trx_i_s_cache_t* cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Fills i_s_lock_waits_row_t object. Returns its first argument.
The real line: +@return	result object that's filled */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +i_s_lock_waits_row_t*
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:i_s_lock_waits_row_t*
Depths: 0:0
[]
The real line: +fill_lock_waits_row(
Current Name Search:   static i_s_lock_waits_row_t* 
LINE TO PARSE FOR KEYWORD:fill_lock_waits_row(
Depths: 0:0
[]
The real line: +/*================*/
Current Name Search:   static i_s_lock_waits_row_t* fill_lock_waits_row( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	i_s_lock_waits_row_t*	row,		/*!< out: result object
Current Name Search:   static i_s_lock_waits_row_t* fill_lock_waits_row(  
LINE TO PARSE FOR KEYWORD:	i_s_lock_waits_row_t*	row,		
Depths: 0:0
[]
The real line: +						that's filled */
The real line: +	const i_s_locks_row_t*	requested_lock_row,/*!< in: pointer to the
Current Name Search:   static i_s_lock_waits_row_t* fill_lock_waits_row(  	i_s_lock_waits_row_t*	row,		 
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	requested_lock_row,
Depths: 0:0
[]
The real line: +						relevant requested lock
The real line: +						row in innodb_locks */
The real line: +	const i_s_locks_row_t*	blocking_lock_row)/*!< in: pointer to the
Current Name Search:   static i_s_lock_waits_row_t* fill_lock_waits_row(  	i_s_lock_waits_row_t*	row,		 	const i_s_locks_row_t*	requested_lock_row, 
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	blocking_lock_row)
Depths: 0:0
[]
The real line: +						relevant blocking lock
The real line: +						row in innodb_locks */
The real line: +{
Current Name Search:   static i_s_lock_waits_row_t* fill_lock_waits_row(  	i_s_lock_waits_row_t*	row,		 	const i_s_locks_row_t*	requested_lock_row, 	const i_s_locks_row_t*	blocking_lock_row) 
Checking if function:   static i_s_lock_waits_row_t* fill_lock_waits_row(  	i_s_lock_waits_row_t*	row,		 	const i_s_locks_row_t*	requested_lock_row, 	const i_s_locks_row_t*	blocking_lock_row) {
PATTERN 1
Function:  i_s_lock_waits_row_t* fill_lock_waits_row(  i_s_lock_waits_row_t*row,i_s_locks_row_t*requested_lock_row,i_s_locks_row_t*blocking_lock_row) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	row->requested_lock_row = requested_lock_row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->requested_lock_row = requested_lock_row;
The real line: +	row->blocking_lock_row = blocking_lock_row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	row->blocking_lock_row = blocking_lock_row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(row);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(row);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
753 : 758
Next: (  i_s_lock_waits_row_t*row,i_s_locks_row_t*requested_lock_row,i_s_locks_row_t*blocking_lock_row)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Calculates a hash fold for a lock. For a record lock the fold is
The real line: +calculated from 4 elements, which uniquely identify a lock at a given
The real line: +point in time: transaction id, space id, page number, record number.
The real line: +For a table lock the fold is table's id.
The real line: +@return	fold */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ulint
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ulint
Depths: 0:0
[]
The real line: +fold_lock(
Current Name Search:   static ulint 
LINE TO PARSE FOR KEYWORD:fold_lock(
Depths: 0:0
[]
The real line: +/*======*/
Current Name Search:   static ulint fold_lock( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	const lock_t*	lock,	/*!< in: lock object to fold */
Current Name Search:   static ulint fold_lock(  
LINE TO PARSE FOR KEYWORD:	const lock_t*	lock,	
Depths: 0:0
[]
The real line: +	ulint		heap_no)/*!< in: lock's record number
Current Name Search:   static ulint fold_lock(  	const lock_t*	lock,	 
LINE TO PARSE FOR KEYWORD:	ulint		heap_no)
Depths: 0:0
[]
The real line: +				or ULINT_UNDEFINED if the lock
The real line: +				is a table lock */
The real line: +{
Current Name Search:   static ulint fold_lock(  	const lock_t*	lock,	 	ulint		heap_no) 
Checking if function:   static ulint fold_lock(  	const lock_t*	lock,	 	ulint		heap_no) {
PATTERN 1
Function:  ulint fold_lock( lock_t*lock, ulintheap_no) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +#ifdef TEST_LOCK_FOLD_ALWAYS_DIFFERENT
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef test_lock_fold_always_different
The real line: +	static ulint	fold = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	static ulint	fold = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(fold++);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(fold++);
The real line: +#else
End Check: 1
LINE TO PARSE FOR KEYWORD:#else
The real line: +	ulint	ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint	ret;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	switch (lock_get_type(lock)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	switch (lock_get_type(lock)) {
The real line: +	case LOCK_REC:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_rec:
The real line: +		ut_a(heap_no != ULINT_UNDEFINED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(heap_no != ulint_undefined);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ret = ut_fold_ulint_pair((ulint) lock_get_trx_id(lock),
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = ut_fold_ulint_pair((ulint) lock_get_trx_id(lock),
The real line: +					 lock_rec_get_space_id(lock));
End Check: 2
LINE TO PARSE FOR KEYWORD:					 lock_rec_get_space_id(lock));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ret = ut_fold_ulint_pair(ret,
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = ut_fold_ulint_pair(ret,
The real line: +					 lock_rec_get_page_no(lock));
End Check: 2
LINE TO PARSE FOR KEYWORD:					 lock_rec_get_page_no(lock));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ret = ut_fold_ulint_pair(ret, heap_no);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = ut_fold_ulint_pair(ret, heap_no);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	case LOCK_TABLE:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_table:
The real line: +		/* this check is actually not necessary for continuing
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		correct operation, but something must have gone wrong if
The real line: +		it fails. */
The real line: +		ut_a(heap_no == ULINT_UNDEFINED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(heap_no == ulint_undefined);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ret = (ulint) lock_get_table_id(lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = (ulint) lock_get_table_id(lock);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	default:
End Check: 2
LINE TO PARSE FOR KEYWORD:	default:
The real line: +		ut_error;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_error;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(ret);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
774 : 810
Next: ( lock_t*lock, ulintheap_no)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Checks whether i_s_locks_row_t object represents a lock_t object.
The real line: +@return	TRUE if they match */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +locks_row_eq_lock(
Current Name Search:   static ibool 
LINE TO PARSE FOR KEYWORD:locks_row_eq_lock(
Depths: 0:0
[]
The real line: +/*==============*/
Current Name Search:   static ibool locks_row_eq_lock( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	const i_s_locks_row_t*	row,	/*!< in: innodb_locks row */
Current Name Search:   static ibool locks_row_eq_lock(  
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	row,	
Depths: 0:0
[]
The real line: +	const lock_t*		lock,	/*!< in: lock object */
Current Name Search:   static ibool locks_row_eq_lock(  	const i_s_locks_row_t*	row,	 
LINE TO PARSE FOR KEYWORD:	const lock_t*		lock,	
Depths: 0:0
[]
The real line: +	ulint			heap_no)/*!< in: lock's record number
Current Name Search:   static ibool locks_row_eq_lock(  	const i_s_locks_row_t*	row,	 	const lock_t*		lock,	 
LINE TO PARSE FOR KEYWORD:	ulint			heap_no)
Depths: 0:0
[]
The real line: +					or ULINT_UNDEFINED if the lock
The real line: +					is a table lock */
The real line: +{
Current Name Search:   static ibool locks_row_eq_lock(  	const i_s_locks_row_t*	row,	 	const lock_t*		lock,	 	ulint			heap_no) 
Checking if function:   static ibool locks_row_eq_lock(  	const i_s_locks_row_t*	row,	 	const lock_t*		lock,	 	ulint			heap_no) {
PATTERN 1
Function:  ibool locks_row_eq_lock( i_s_locks_row_t*row,lock_t*lock, ulintheap_no) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +#ifdef TEST_NO_LOCKS_ROW_IS_EVER_EQUAL_TO_LOCK_T
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef test_no_locks_row_is_ever_equal_to_lock_t
The real line: +	return(0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(0);
The real line: +#else
End Check: 1
LINE TO PARSE FOR KEYWORD:#else
The real line: +	switch (lock_get_type(lock)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	switch (lock_get_type(lock)) {
The real line: +	case LOCK_REC:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_rec:
The real line: +		ut_a(heap_no != ULINT_UNDEFINED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(heap_no != ulint_undefined);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(row->lock_trx_id == lock_get_trx_id(lock)
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(row->lock_trx_id == lock_get_trx_id(lock)
The real line: +		       && row->lock_space == lock_rec_get_space_id(lock)
End Check: 2
LINE TO PARSE FOR KEYWORD:		       && row->lock_space == lock_rec_get_space_id(lock)
The real line: +		       && row->lock_page == lock_rec_get_page_no(lock)
End Check: 2
LINE TO PARSE FOR KEYWORD:		       && row->lock_page == lock_rec_get_page_no(lock)
The real line: +		       && row->lock_rec == heap_no);
End Check: 2
LINE TO PARSE FOR KEYWORD:		       && row->lock_rec == heap_no);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +	case LOCK_TABLE:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case lock_table:
The real line: +		/* this check is actually not necessary for continuing
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		correct operation, but something must have gone wrong if
The real line: +		it fails. */
The real line: +		ut_a(heap_no == ULINT_UNDEFINED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(heap_no == ulint_undefined);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(row->lock_trx_id == lock_get_trx_id(lock)
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(row->lock_trx_id == lock_get_trx_id(lock)
The real line: +		       && row->lock_table_id == lock_get_table_id(lock));
End Check: 2
LINE TO PARSE FOR KEYWORD:		       && row->lock_table_id == lock_get_table_id(lock));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +	default:
End Check: 2
LINE TO PARSE FOR KEYWORD:	default:
The real line: +		ut_error;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_error;
The real line: +		return(FALSE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(false);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
824 : 851
Next: ( i_s_locks_row_t*row,lock_t*lock, ulintheap_no)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Searches for a row in the innodb_locks cache that has a specified id.
The real line: +This happens in O(1) time since a hash table is used. Returns pointer to
The real line: +the row or NULL if none is found.
The real line: +@return	row or NULL */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +i_s_locks_row_t*
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:i_s_locks_row_t*
Depths: 0:0
[]
The real line: +search_innodb_locks(
Current Name Search:   static i_s_locks_row_t* 
LINE TO PARSE FOR KEYWORD:search_innodb_locks(
Depths: 0:0
[]
The real line: +/*================*/
Current Name Search:   static i_s_locks_row_t* search_innodb_locks( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,	/*!< in: cache */
Current Name Search:   static i_s_locks_row_t* search_innodb_locks(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,	
Depths: 0:0
[]
The real line: +	const lock_t*		lock,	/*!< in: lock to search for */
Current Name Search:   static i_s_locks_row_t* search_innodb_locks(  	trx_i_s_cache_t*	cache,	 
LINE TO PARSE FOR KEYWORD:	const lock_t*		lock,	
Depths: 0:0
[]
The real line: +	ulint			heap_no)/*!< in: lock's record number
Current Name Search:   static i_s_locks_row_t* search_innodb_locks(  	trx_i_s_cache_t*	cache,	 	const lock_t*		lock,	 
LINE TO PARSE FOR KEYWORD:	ulint			heap_no)
Depths: 0:0
[]
The real line: +					or ULINT_UNDEFINED if the lock
The real line: +					is a table lock */
The real line: +{
Current Name Search:   static i_s_locks_row_t* search_innodb_locks(  	trx_i_s_cache_t*	cache,	 	const lock_t*		lock,	 	ulint			heap_no) 
Checking if function:   static i_s_locks_row_t* search_innodb_locks(  	trx_i_s_cache_t*	cache,	 	const lock_t*		lock,	 	ulint			heap_no) {
PATTERN 1
Function:  i_s_locks_row_t* search_innodb_locks(  trx_i_s_cache_t*cache,lock_t*lock, ulintheap_no) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	i_s_hash_chain_t*	hash_chain;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_hash_chain_t*	hash_chain;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	HASH_SEARCH(
End Check: 1
LINE TO PARSE FOR KEYWORD:	hash_search(
The real line: +		/* hash_chain->"next" */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		next,
End Check: 1
LINE TO PARSE FOR KEYWORD:		next,
The real line: +		/* the hash table */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		cache->locks_hash,
End Check: 1
LINE TO PARSE FOR KEYWORD:		cache->locks_hash,
The real line: +		/* fold */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		fold_lock(lock, heap_no),
End Check: 1
LINE TO PARSE FOR KEYWORD:		fold_lock(lock, heap_no),
The real line: +		/* the type of the next variable */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		i_s_hash_chain_t*,
End Check: 1
LINE TO PARSE FOR KEYWORD:		i_s_hash_chain_t*,
The real line: +		/* auxiliary variable */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		hash_chain,
End Check: 1
LINE TO PARSE FOR KEYWORD:		hash_chain,
The real line: +		/* assertion on every traversed item */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		,
End Check: 1
LINE TO PARSE FOR KEYWORD:		,
The real line: +		/* this determines if we have found the lock */
End Check: 1
LINE TO PARSE FOR KEYWORD:		
The real line: +		locks_row_eq_lock(hash_chain->value, lock, heap_no));
End Check: 1
LINE TO PARSE FOR KEYWORD:		locks_row_eq_lock(hash_chain->value, lock, heap_no));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (hash_chain == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (hash_chain == null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(null);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	/* else */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(hash_chain->value);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(hash_chain->value);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
867 : 893
Next: (  trx_i_s_cache_t*cache,lock_t*lock, ulintheap_no)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Adds new element to the locks cache, enlarging it if necessary.
The real line: +Returns a pointer to the added row. If the row is already present then
The real line: +no row is added and a pointer to the existing row is returned.
The real line: +If row can not be allocated then NULL is returned.
The real line: +@return	row */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +i_s_locks_row_t*
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:i_s_locks_row_t*
Depths: 0:0
[]
The real line: +add_lock_to_cache(
Current Name Search:   static i_s_locks_row_t* 
LINE TO PARSE FOR KEYWORD:add_lock_to_cache(
Depths: 0:0
[]
The real line: +/*==============*/
Current Name Search:   static i_s_locks_row_t* add_lock_to_cache( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,	/*!< in/out: cache */
Current Name Search:   static i_s_locks_row_t* add_lock_to_cache(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,	
Depths: 0:0
[]
The real line: +	const lock_t*		lock,	/*!< in: the element to add */
Current Name Search:   static i_s_locks_row_t* add_lock_to_cache(  	trx_i_s_cache_t*	cache,	 
LINE TO PARSE FOR KEYWORD:	const lock_t*		lock,	
Depths: 0:0
[]
The real line: +	ulint			heap_no)/*!< in: lock's record number
Current Name Search:   static i_s_locks_row_t* add_lock_to_cache(  	trx_i_s_cache_t*	cache,	 	const lock_t*		lock,	 
LINE TO PARSE FOR KEYWORD:	ulint			heap_no)
Depths: 0:0
[]
The real line: +					or ULINT_UNDEFINED if the lock
The real line: +					is a table lock */
The real line: +{
Current Name Search:   static i_s_locks_row_t* add_lock_to_cache(  	trx_i_s_cache_t*	cache,	 	const lock_t*		lock,	 	ulint			heap_no) 
Checking if function:   static i_s_locks_row_t* add_lock_to_cache(  	trx_i_s_cache_t*	cache,	 	const lock_t*		lock,	 	ulint			heap_no) {
PATTERN 1
Function:  i_s_locks_row_t* add_lock_to_cache(  trx_i_s_cache_t*cache,lock_t*lock, ulintheap_no) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	i_s_locks_row_t*	dst_row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_locks_row_t*	dst_row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef test_add_each_locks_row_many_times
The real line: +	ulint	i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint	i;
The real line: +	for (i = 0; i < 10000; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < 10000; i++) {
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +#ifndef TEST_DO_NOT_CHECK_FOR_DUPLICATE_ROWS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifndef test_do_not_check_for_duplicate_rows
The real line: +	/* quit if this lock is already present */
End Check: 2
LINE TO PARSE FOR KEYWORD:	
The real line: +	dst_row = search_innodb_locks(cache, lock, heap_no);
End Check: 2
LINE TO PARSE FOR KEYWORD:	dst_row = search_innodb_locks(cache, lock, heap_no);
The real line: +	if (dst_row != NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:	if (dst_row != null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +		return(dst_row);
End Check: 3
LINE TO PARSE FOR KEYWORD:		return(dst_row);
The real line: +	}
End Check: 2
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +	dst_row = (i_s_locks_row_t*)
End Check: 2
LINE TO PARSE FOR KEYWORD:	dst_row = (i_s_locks_row_t*)
The real line: +		table_cache_create_empty_row(&cache->innodb_locks, cache);
End Check: 2
LINE TO PARSE FOR KEYWORD:		table_cache_create_empty_row(&cache->innodb_locks, cache);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +	/* memory could not be allocated */
End Check: 2
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (dst_row == NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:	if (dst_row == null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +		return(NULL);
End Check: 3
LINE TO PARSE FOR KEYWORD:		return(null);
The real line: +	}
End Check: 2
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +	if (!fill_locks_row(dst_row, lock, heap_no, cache)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:	if (!fill_locks_row(dst_row, lock, heap_no, cache)) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +		/* memory could not be allocated */
End Check: 3
LINE TO PARSE FOR KEYWORD:		
The real line: +		cache->innodb_locks.rows_used--;
End Check: 3
LINE TO PARSE FOR KEYWORD:		cache->innodb_locks.rows_used--;
The real line: +		return(NULL);
End Check: 3
LINE TO PARSE FOR KEYWORD:		return(null);
The real line: +	}
End Check: 2
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifndef TEST_DO_NOT_INSERT_INTO_THE_HASH_TABLE
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifndef test_do_not_insert_into_the_hash_table
The real line: +	HASH_INSERT(
End Check: 2
LINE TO PARSE FOR KEYWORD:	hash_insert(
The real line: +		/* the type used in the hash chain */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		i_s_hash_chain_t,
End Check: 2
LINE TO PARSE FOR KEYWORD:		i_s_hash_chain_t,
The real line: +		/* hash_chain->"next" */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		next,
End Check: 2
LINE TO PARSE FOR KEYWORD:		next,
The real line: +		/* the hash table */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		cache->locks_hash,
End Check: 2
LINE TO PARSE FOR KEYWORD:		cache->locks_hash,
The real line: +		/* fold */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		fold_lock(lock, heap_no),
End Check: 2
LINE TO PARSE FOR KEYWORD:		fold_lock(lock, heap_no),
The real line: +		/* add this data to the hash */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		&dst_row->hash_chain);
End Check: 2
LINE TO PARSE FOR KEYWORD:		&dst_row->hash_chain);
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +#ifdef TEST_ADD_EACH_LOCKS_ROW_MANY_TIMES
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef test_add_each_locks_row_many_times
The real line: +	} /* for()-loop */
End Check: 1
LINE TO PARSE FOR KEYWORD:	} 
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(dst_row);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(dst_row);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
910 : 960
Next: (  trx_i_s_cache_t*cache,lock_t*lock, ulintheap_no)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Adds new pair of locks to the lock waits cache.
The real line: +If memory can not be allocated then FALSE is returned.
The real line: +@return	FALSE if allocation fails */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +add_lock_wait_to_cache(
Current Name Search:   static ibool 
LINE TO PARSE FOR KEYWORD:add_lock_wait_to_cache(
Depths: 0:0
[]
The real line: +/*===================*/
Current Name Search:   static ibool add_lock_wait_to_cache( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,		/*!< in/out: cache */
Current Name Search:   static ibool add_lock_wait_to_cache(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,		
Depths: 0:0
[]
The real line: +	const i_s_locks_row_t*	requested_lock_row,/*!< in: pointer to the
Current Name Search:   static ibool add_lock_wait_to_cache(  	trx_i_s_cache_t*	cache,		 
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	requested_lock_row,
Depths: 0:0
[]
The real line: +						relevant requested lock
The real line: +						row in innodb_locks */
The real line: +	const i_s_locks_row_t*	blocking_lock_row)/*!< in: pointer to the
Current Name Search:   static ibool add_lock_wait_to_cache(  	trx_i_s_cache_t*	cache,		 	const i_s_locks_row_t*	requested_lock_row, 
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	blocking_lock_row)
Depths: 0:0
[]
The real line: +						relevant blocking lock
The real line: +						row in innodb_locks */
The real line: +{
Current Name Search:   static ibool add_lock_wait_to_cache(  	trx_i_s_cache_t*	cache,		 	const i_s_locks_row_t*	requested_lock_row, 	const i_s_locks_row_t*	blocking_lock_row) 
Checking if function:   static ibool add_lock_wait_to_cache(  	trx_i_s_cache_t*	cache,		 	const i_s_locks_row_t*	requested_lock_row, 	const i_s_locks_row_t*	blocking_lock_row) {
PATTERN 1
Function:  ibool add_lock_wait_to_cache(  trx_i_s_cache_t*cache,i_s_locks_row_t*requested_lock_row,i_s_locks_row_t*blocking_lock_row) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	i_s_lock_waits_row_t*	dst_row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_lock_waits_row_t*	dst_row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	dst_row = (i_s_lock_waits_row_t*)
End Check: 1
LINE TO PARSE FOR KEYWORD:	dst_row = (i_s_lock_waits_row_t*)
The real line: +		table_cache_create_empty_row(&cache->innodb_lock_waits,
End Check: 1
LINE TO PARSE FOR KEYWORD:		table_cache_create_empty_row(&cache->innodb_lock_waits,
The real line: +					     cache);
End Check: 1
LINE TO PARSE FOR KEYWORD:					     cache);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* memory could not be allocated */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (dst_row == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (dst_row == null) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(FALSE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(false);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	fill_lock_waits_row(dst_row, requested_lock_row, blocking_lock_row);
End Check: 1
LINE TO PARSE FOR KEYWORD:	fill_lock_waits_row(dst_row, requested_lock_row, blocking_lock_row);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(TRUE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
977 : 993
Next: (  trx_i_s_cache_t*cache,i_s_locks_row_t*requested_lock_row,i_s_locks_row_t*blocking_lock_row)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Adds transaction's relevant (important) locks to cache.
The real line: +If the transaction is waiting, then the wait lock is added to
The real line: +innodb_locks and a pointer to the added row is returned in
The real line: +requested_lock_row, otherwise requested_lock_row is set to NULL.
The real line: +If rows can not be allocated then FALSE is returned and the value of
The real line: +requested_lock_row is undefined.
The real line: +@return	FALSE if allocation fails */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +add_trx_relevant_locks_to_cache(
Current Name Search:   static ibool 
LINE TO PARSE FOR KEYWORD:add_trx_relevant_locks_to_cache(
Depths: 0:0
[]
The real line: +/*============================*/
Current Name Search:   static ibool add_trx_relevant_locks_to_cache( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,	/*!< in/out: cache */
Current Name Search:   static ibool add_trx_relevant_locks_to_cache(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,	
Depths: 0:0
[]
The real line: +	const trx_t*		trx,	/*!< in: transaction */
Current Name Search:   static ibool add_trx_relevant_locks_to_cache(  	trx_i_s_cache_t*	cache,	 
LINE TO PARSE FOR KEYWORD:	const trx_t*		trx,	
Depths: 0:0
[]
The real line: +	i_s_locks_row_t**	requested_lock_row)/*!< out: pointer to the
Current Name Search:   static ibool add_trx_relevant_locks_to_cache(  	trx_i_s_cache_t*	cache,	 	const trx_t*		trx,	 
LINE TO PARSE FOR KEYWORD:	i_s_locks_row_t**	requested_lock_row)
Depths: 0:0
[]
The real line: +					requested lock row, or NULL or
The real line: +					undefined */
The real line: +{
Current Name Search:   static ibool add_trx_relevant_locks_to_cache(  	trx_i_s_cache_t*	cache,	 	const trx_t*		trx,	 	i_s_locks_row_t**	requested_lock_row) 
Checking if function:   static ibool add_trx_relevant_locks_to_cache(  	trx_i_s_cache_t*	cache,	 	const trx_t*		trx,	 	i_s_locks_row_t**	requested_lock_row) {
PATTERN 1
Function:  ibool add_trx_relevant_locks_to_cache(  trx_i_s_cache_t*cache,trx_t*trx, i_s_locks_row_t**requested_lock_row) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ut_ad(mutex_own(&kernel_mutex));
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_ad(mutex_own(&kernel_mutex));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* If transaction is waiting we add the wait lock and all locks
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	from another transactions that are blocking the wait lock. */
The real line: +	if (trx->que_state == TRX_QUE_LOCK_WAIT) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (trx->que_state == trx_que_lock_wait) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		const lock_t*		curr_lock;
End Check: 2
LINE TO PARSE FOR KEYWORD:		const lock_t*		curr_lock;
The real line: +		ulint			wait_lock_heap_no;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ulint			wait_lock_heap_no;
The real line: +		i_s_locks_row_t*	blocking_lock_row;
End Check: 2
LINE TO PARSE FOR KEYWORD:		i_s_locks_row_t*	blocking_lock_row;
The real line: +		lock_queue_iterator_t	iter;
End Check: 2
LINE TO PARSE FOR KEYWORD:		lock_queue_iterator_t	iter;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ut_a(trx->wait_lock != NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_a(trx->wait_lock != null);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		wait_lock_heap_no
End Check: 2
LINE TO PARSE FOR KEYWORD:		wait_lock_heap_no
The real line: +			= wait_lock_get_heap_no(trx->wait_lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:			= wait_lock_get_heap_no(trx->wait_lock);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* add the requested lock */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		*requested_lock_row
End Check: 2
LINE TO PARSE FOR KEYWORD:		*requested_lock_row
The real line: +			= add_lock_to_cache(cache, trx->wait_lock,
End Check: 2
LINE TO PARSE FOR KEYWORD:			= add_lock_to_cache(cache, trx->wait_lock,
The real line: +					    wait_lock_heap_no);
End Check: 2
LINE TO PARSE FOR KEYWORD:					    wait_lock_heap_no);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* memory could not be allocated */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		if (*requested_lock_row == NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (*requested_lock_row == null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			return(FALSE);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return(false);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* then iterate over the locks before the wait lock and
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		add the ones that are blocking it */
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		lock_queue_iterator_reset(&iter, trx->wait_lock,
End Check: 2
LINE TO PARSE FOR KEYWORD:		lock_queue_iterator_reset(&iter, trx->wait_lock,
The real line: +					  ULINT_UNDEFINED);
End Check: 2
LINE TO PARSE FOR KEYWORD:					  ulint_undefined);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		curr_lock = lock_queue_iterator_get_prev(&iter);
End Check: 2
LINE TO PARSE FOR KEYWORD:		curr_lock = lock_queue_iterator_get_prev(&iter);
The real line: +		while (curr_lock != NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		while (curr_lock != null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			if (lock_has_to_wait(trx->wait_lock,
End Check: 3
LINE TO PARSE FOR KEYWORD:			if (lock_has_to_wait(trx->wait_lock,
The real line: +					     curr_lock)) {
End Check: 4
LINE TO PARSE FOR KEYWORD:					     curr_lock)) {
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				/* add the lock that is
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				blocking trx->wait_lock */
The real line: +				blocking_lock_row
End Check: 4
LINE TO PARSE FOR KEYWORD:				blocking_lock_row
The real line: +					= add_lock_to_cache(
End Check: 4
LINE TO PARSE FOR KEYWORD:					= add_lock_to_cache(
The real line: +						cache, curr_lock,
End Check: 4
LINE TO PARSE FOR KEYWORD:						cache, curr_lock,
The real line: +						/* heap_no is the same
End Check: 4
LINE TO PARSE FOR KEYWORD:						
The real line: +						for the wait and waited
The real line: +						locks */
The real line: +						wait_lock_heap_no);
End Check: 4
LINE TO PARSE FOR KEYWORD:						wait_lock_heap_no);
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				/* memory could not be allocated */
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				if (blocking_lock_row == NULL) {
End Check: 5
LINE TO PARSE FOR KEYWORD:				if (blocking_lock_row == null) {
The real line: +
End Check: 5
LINE TO PARSE FOR KEYWORD:
The real line: +					return(FALSE);
End Check: 5
LINE TO PARSE FOR KEYWORD:					return(false);
The real line: +				}
End Check: 4
LINE TO PARSE FOR KEYWORD:				}
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				/* add the relation between both locks
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				to innodb_lock_waits */
The real line: +				if (!add_lock_wait_to_cache(
End Check: 4
LINE TO PARSE FOR KEYWORD:				if (!add_lock_wait_to_cache(
The real line: +						cache, *requested_lock_row,
End Check: 4
LINE TO PARSE FOR KEYWORD:						cache, *requested_lock_row,
The real line: +						blocking_lock_row)) {
End Check: 5
LINE TO PARSE FOR KEYWORD:						blocking_lock_row)) {
The real line: +
End Check: 5
LINE TO PARSE FOR KEYWORD:
The real line: +					/* memory could not be allocated */
End Check: 5
LINE TO PARSE FOR KEYWORD:					
The real line: +					return(FALSE);
End Check: 5
LINE TO PARSE FOR KEYWORD:					return(false);
The real line: +				}
End Check: 4
LINE TO PARSE FOR KEYWORD:				}
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			curr_lock = lock_queue_iterator_get_prev(&iter);
End Check: 3
LINE TO PARSE FOR KEYWORD:			curr_lock = lock_queue_iterator_get_prev(&iter);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		*requested_lock_row = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		*requested_lock_row = null;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(TRUE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1012 : 1087
Next: (  trx_i_s_cache_t*cache,trx_t*trx, i_s_locks_row_t**requested_lock_row)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/** The minimum time that a cache must not be updated after it has been
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +read for the last time; measured in microseconds. We use this technique
The real line: +to ensure that SELECTs which join several INFORMATION SCHEMA tables read
The real line: +the same version of the cache. */
The real line: +#define CACHE_MIN_IDLE_TIME_US	100000 /* 0.1 sec */
Current Name Search:   
LINE TO PARSE FOR KEYWORD:#define cache_min_idle_time_us	100000 
Depths: 0:0
[]
The real line: +
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Checks if the cache can safely be updated.
The real line: +@return	TRUE if can be updated */
The real line: +static
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000    
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000    static 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +can_cache_be_updated(
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000    static ibool 
LINE TO PARSE FOR KEYWORD:can_cache_be_updated(
Depths: 0:0
[]
The real line: +/*=================*/
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000    static ibool can_cache_be_updated( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in: cache */
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000    static ibool can_cache_be_updated(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   #define CACHE_MIN_IDLE_TIME_US	100000    static ibool can_cache_be_updated(  	trx_i_s_cache_t*	cache)	 
Checking if function:   #define CACHE_MIN_IDLE_TIME_US	100000    static ibool can_cache_be_updated(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  ibool can_cache_be_updated(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ullint	now;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ullint	now;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Here we read cache->last_read without acquiring its mutex
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	because last_read is only updated when a shared rw lock on the
The real line: +	whole cache is being held (see trx_i_s_cache_end_read()) and
The real line: +	we are currently holding an exclusive rw lock on the cache.
The real line: +	So it is not possible for last_read to be updated while we are
The real line: +	reading it. */
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef UNIV_SYNC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef univ_sync_debug
The real line: +	ut_a(rw_lock_own(&cache->rw_lock, RW_LOCK_EX));
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(rw_lock_own(&cache->rw_lock, rw_lock_ex));
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	now = ut_time_us(NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	now = ut_time_us(null);
The real line: +	if (now - cache->last_read > CACHE_MIN_IDLE_TIME_US) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (now - cache->last_read > cache_min_idle_time_us) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(TRUE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(true);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(FALSE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(false);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1103 : 1124
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Declare a cache empty, preparing it to be filled up. Not all resources
The real line: +are freed because they can be reused. */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +void
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_clear(
Current Name Search:   static void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_clear(
Depths: 0:0
[]
The real line: +/*================*/
Current Name Search:   static void trx_i_s_cache_clear( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< out: cache to clear */
Current Name Search:   static void trx_i_s_cache_clear(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   static void trx_i_s_cache_clear(  	trx_i_s_cache_t*	cache)	 
Checking if function:   static void trx_i_s_cache_clear(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_clear(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	cache->innodb_trx.rows_used = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->innodb_trx.rows_used = 0;
The real line: +	cache->innodb_locks.rows_used = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->innodb_locks.rows_used = 0;
The real line: +	cache->innodb_lock_waits.rows_used = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->innodb_lock_waits.rows_used = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	hash_table_clear(cache->locks_hash);
End Check: 1
LINE TO PARSE FOR KEYWORD:	hash_table_clear(cache->locks_hash);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ha_storage_empty(&cache->storage);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ha_storage_empty(&cache->storage);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1134 : 1142
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Fetches the data needed to fill the 3 INFORMATION SCHEMA tables into the
The real line: +table cache buffer. Cache must be locked for write. */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +void
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +fetch_data_into_cache(
Current Name Search:   static void 
LINE TO PARSE FOR KEYWORD:fetch_data_into_cache(
Depths: 0:0
[]
The real line: +/*==================*/
Current Name Search:   static void fetch_data_into_cache( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in/out: cache */
Current Name Search:   static void fetch_data_into_cache(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   static void fetch_data_into_cache(  	trx_i_s_cache_t*	cache)	 
Checking if function:   static void fetch_data_into_cache(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void fetch_data_into_cache(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	trx_t*			trx;
End Check: 1
LINE TO PARSE FOR KEYWORD:	trx_t*			trx;
The real line: +	i_s_trx_row_t*		trx_row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_trx_row_t*		trx_row;
The real line: +	i_s_locks_row_t*	requested_lock_row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_locks_row_t*	requested_lock_row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_ad(mutex_own(&kernel_mutex));
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_ad(mutex_own(&kernel_mutex));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	trx_i_s_cache_clear(cache);
End Check: 1
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_clear(cache);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* We iterate over the list of all transactions and add each one
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	to innodb_trx's cache. We also add all locks that are relevant
The real line: +	to each transaction into innodb_locks' and innodb_lock_waits'
The real line: +	caches. */
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (trx = UT_LIST_GET_FIRST(trx_sys->trx_list);
End Check: 1
LINE TO PARSE FOR KEYWORD:	for (trx = ut_list_get_first(trx_sys->trx_list);
The real line: +	     trx != NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	     trx != null;
The real line: +	     trx = UT_LIST_GET_NEXT(trx_list, trx)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	     trx = ut_list_get_next(trx_list, trx)) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (!add_trx_relevant_locks_to_cache(cache, trx,
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (!add_trx_relevant_locks_to_cache(cache, trx,
The real line: +						     &requested_lock_row)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:						     &requested_lock_row)) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			cache->is_truncated = TRUE;
End Check: 3
LINE TO PARSE FOR KEYWORD:			cache->is_truncated = true;
The real line: +			return;
End Check: 3
LINE TO PARSE FOR KEYWORD:			return;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		trx_row = (i_s_trx_row_t*)
End Check: 2
LINE TO PARSE FOR KEYWORD:		trx_row = (i_s_trx_row_t*)
The real line: +			table_cache_create_empty_row(&cache->innodb_trx,
End Check: 2
LINE TO PARSE FOR KEYWORD:			table_cache_create_empty_row(&cache->innodb_trx,
The real line: +						     cache);
End Check: 2
LINE TO PARSE FOR KEYWORD:						     cache);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* memory could not be allocated */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		if (trx_row == NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (trx_row == null) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			cache->is_truncated = TRUE;
End Check: 3
LINE TO PARSE FOR KEYWORD:			cache->is_truncated = true;
The real line: +			return;
End Check: 3
LINE TO PARSE FOR KEYWORD:			return;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (!fill_trx_row(trx_row, trx, requested_lock_row, cache)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (!fill_trx_row(trx_row, trx, requested_lock_row, cache)) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			/* memory could not be allocated */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			cache->innodb_trx.rows_used--;
End Check: 3
LINE TO PARSE FOR KEYWORD:			cache->innodb_trx.rows_used--;
The real line: +			cache->is_truncated = TRUE;
End Check: 3
LINE TO PARSE FOR KEYWORD:			cache->is_truncated = true;
The real line: +			return;
End Check: 3
LINE TO PARSE FOR KEYWORD:			return;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	cache->is_truncated = FALSE;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->is_truncated = false;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1152 : 1198
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Update the transactions cache if it has not been read for some time.
The real line: +Called from handler/i_s.cc.
The real line: +@return	0 - fetched, 1 - not */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +int
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:int
Depths: 0:0
[]
The real line: +trx_i_s_possibly_fetch_data_into_cache(
Current Name Search:   UNIV_INTERN int 
LINE TO PARSE FOR KEYWORD:trx_i_s_possibly_fetch_data_into_cache(
Depths: 0:0
[]
The real line: +/*===================================*/
Current Name Search:   UNIV_INTERN int trx_i_s_possibly_fetch_data_into_cache( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in/out: cache */
Current Name Search:   UNIV_INTERN int trx_i_s_possibly_fetch_data_into_cache(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN int trx_i_s_possibly_fetch_data_into_cache(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN int trx_i_s_possibly_fetch_data_into_cache(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  int trx_i_s_possibly_fetch_data_into_cache(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	if (!can_cache_be_updated(cache)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (!can_cache_be_updated(cache)) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		return(1);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return(1);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* We need to read trx_sys and record/table lock queues */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	mutex_enter(&kernel_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mutex_enter(&kernel_mutex);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	fetch_data_into_cache(cache);
End Check: 1
LINE TO PARSE FOR KEYWORD:	fetch_data_into_cache(cache);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	mutex_exit(&kernel_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mutex_exit(&kernel_mutex);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(0);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1209 : 1223
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Returns TRUE if the data in the cache is truncated due to the memory
The real line: +limit posed by TRX_I_S_MEM_LIMIT.
The real line: +@return	TRUE if truncated */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +ibool
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:ibool
Depths: 0:0
[]
The real line: +trx_i_s_cache_is_truncated(
Current Name Search:   UNIV_INTERN ibool 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_is_truncated(
Depths: 0:0
[]
The real line: +/*=======================*/
Current Name Search:   UNIV_INTERN ibool trx_i_s_cache_is_truncated( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in: cache */
Current Name Search:   UNIV_INTERN ibool trx_i_s_cache_is_truncated(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN ibool trx_i_s_cache_is_truncated(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN ibool trx_i_s_cache_is_truncated(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  ibool trx_i_s_cache_is_truncated(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	return(cache->is_truncated);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(cache->is_truncated);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1234 : 1236
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Initialize INFORMATION SCHEMA trx related cache. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_init(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_init(
Depths: 0:0
[]
The real line: +/*===============*/
Current Name Search:   UNIV_INTERN void trx_i_s_cache_init( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< out: cache to init */
Current Name Search:   UNIV_INTERN void trx_i_s_cache_init(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void trx_i_s_cache_init(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN void trx_i_s_cache_init(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_init(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	/* The latching is done in the following order:
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	acquire trx_i_s_cache_t::rw_lock, X
The real line: +	acquire kernel_mutex
The real line: +	release kernel_mutex
The real line: +	release trx_i_s_cache_t::rw_lock
The real line: +	acquire trx_i_s_cache_t::rw_lock, S
The real line: +	acquire trx_i_s_cache_t::last_read_mutex
The real line: +	release trx_i_s_cache_t::last_read_mutex
The real line: +	release trx_i_s_cache_t::rw_lock */
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	rw_lock_create(&cache->rw_lock, SYNC_TRX_I_S_RWLOCK);
End Check: 1
LINE TO PARSE FOR KEYWORD:	rw_lock_create(&cache->rw_lock, sync_trx_i_s_rwlock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	cache->last_read = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->last_read = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	mutex_create(&cache->last_read_mutex, SYNC_TRX_I_S_LAST_READ);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mutex_create(&cache->last_read_mutex, sync_trx_i_s_last_read);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	table_cache_init(&cache->innodb_trx, sizeof(i_s_trx_row_t));
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache_init(&cache->innodb_trx, sizeof(i_s_trx_row_t));
The real line: +	table_cache_init(&cache->innodb_locks, sizeof(i_s_locks_row_t));
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache_init(&cache->innodb_locks, sizeof(i_s_locks_row_t));
The real line: +	table_cache_init(&cache->innodb_lock_waits,
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache_init(&cache->innodb_lock_waits,
The real line: +			 sizeof(i_s_lock_waits_row_t));
End Check: 1
LINE TO PARSE FOR KEYWORD:			 sizeof(i_s_lock_waits_row_t));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	cache->locks_hash = hash_create(LOCKS_HASH_CELLS_NUM);
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->locks_hash = hash_create(locks_hash_cells_num);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	cache->storage = ha_storage_create(CACHE_STORAGE_INITIAL_SIZE,
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->storage = ha_storage_create(cache_storage_initial_size,
The real line: +					   CACHE_STORAGE_HASH_CELLS);
End Check: 1
LINE TO PARSE FOR KEYWORD:					   cache_storage_hash_cells);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	cache->mem_allocd = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->mem_allocd = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	cache->is_truncated = FALSE;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->is_truncated = false;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1245 : 1275
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Free the INFORMATION SCHEMA trx related cache. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_free(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_free(
Depths: 0:0
[]
The real line: +/*===============*/
Current Name Search:   UNIV_INTERN void trx_i_s_cache_free( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in, own: cache to free */
Current Name Search:   UNIV_INTERN void trx_i_s_cache_free(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void trx_i_s_cache_free(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN void trx_i_s_cache_free(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_free(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	hash_table_free(cache->locks_hash);
End Check: 1
LINE TO PARSE FOR KEYWORD:	hash_table_free(cache->locks_hash);
The real line: +	ha_storage_free(cache->storage);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ha_storage_free(cache->storage);
The real line: +	table_cache_free(&cache->innodb_trx);
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache_free(&cache->innodb_trx);
The real line: +	table_cache_free(&cache->innodb_locks);
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache_free(&cache->innodb_locks);
The real line: +	table_cache_free(&cache->innodb_lock_waits);
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache_free(&cache->innodb_lock_waits);
The real line: +	memset(cache, 0, sizeof *cache);
End Check: 1
LINE TO PARSE FOR KEYWORD:	memset(cache, 0, sizeof *cache);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1284 : 1291
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Issue a shared/read lock on the tables cache. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_start_read(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_start_read(
Depths: 0:0
[]
The real line: +/*=====================*/
Current Name Search:   UNIV_INTERN void trx_i_s_cache_start_read( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in: cache */
Current Name Search:   UNIV_INTERN void trx_i_s_cache_start_read(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void trx_i_s_cache_start_read(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN void trx_i_s_cache_start_read(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_start_read(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	rw_lock_s_lock(&cache->rw_lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	rw_lock_s_lock(&cache->rw_lock);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1300 : 1302
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Release a shared/read lock on the tables cache. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_end_read(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_end_read(
Depths: 0:0
[]
The real line: +/*===================*/
Current Name Search:   UNIV_INTERN void trx_i_s_cache_end_read( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in: cache */
Current Name Search:   UNIV_INTERN void trx_i_s_cache_end_read(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void trx_i_s_cache_end_read(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN void trx_i_s_cache_end_read(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_end_read(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ullint	now;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ullint	now;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef UNIV_SYNC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef univ_sync_debug
The real line: +	ut_a(rw_lock_own(&cache->rw_lock, RW_LOCK_SHARED));
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(rw_lock_own(&cache->rw_lock, rw_lock_shared));
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* update cache last read time */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	now = ut_time_us(NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	now = ut_time_us(null);
The real line: +	mutex_enter(&cache->last_read_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mutex_enter(&cache->last_read_mutex);
The real line: +	cache->last_read = now;
End Check: 1
LINE TO PARSE FOR KEYWORD:	cache->last_read = now;
The real line: +	mutex_exit(&cache->last_read_mutex);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mutex_exit(&cache->last_read_mutex);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	rw_lock_s_unlock(&cache->rw_lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	rw_lock_s_unlock(&cache->rw_lock);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1311 : 1325
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Issue an exclusive/write lock on the tables cache. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_start_write(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_start_write(
Depths: 0:0
[]
The real line: +/*======================*/
Current Name Search:   UNIV_INTERN void trx_i_s_cache_start_write( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in: cache */
Current Name Search:   UNIV_INTERN void trx_i_s_cache_start_write(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void trx_i_s_cache_start_write(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN void trx_i_s_cache_start_write(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_start_write(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	rw_lock_x_lock(&cache->rw_lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	rw_lock_x_lock(&cache->rw_lock);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1334 : 1336
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Release an exclusive/write lock on the tables cache. */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +trx_i_s_cache_end_write(
Current Name Search:   UNIV_INTERN void 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_end_write(
Depths: 0:0
[]
The real line: +/*====================*/
Current Name Search:   UNIV_INTERN void trx_i_s_cache_end_write( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache)	/*!< in: cache */
Current Name Search:   UNIV_INTERN void trx_i_s_cache_end_write(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void trx_i_s_cache_end_write(  	trx_i_s_cache_t*	cache)	 
Checking if function:   UNIV_INTERN void trx_i_s_cache_end_write(  	trx_i_s_cache_t*	cache)	 {
PATTERN 1
Function:  void trx_i_s_cache_end_write(  trx_i_s_cache_t*cache) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +#ifdef UNIV_SYNC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef univ_sync_debug
The real line: +	ut_a(rw_lock_own(&cache->rw_lock, RW_LOCK_EX));
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(rw_lock_own(&cache->rw_lock, rw_lock_ex));
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	rw_lock_x_unlock(&cache->rw_lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	rw_lock_x_unlock(&cache->rw_lock);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1345 : 1351
Next: (  trx_i_s_cache_t*cache)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Selects a INFORMATION SCHEMA table cache from the whole cache.
The real line: +@return	table cache */
The real line: +static
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static
Depths: 0:0
[]
The real line: +i_s_table_cache_t*
Current Name Search:   static 
LINE TO PARSE FOR KEYWORD:i_s_table_cache_t*
Depths: 0:0
[]
The real line: +cache_select_table(
Current Name Search:   static i_s_table_cache_t* 
LINE TO PARSE FOR KEYWORD:cache_select_table(
Depths: 0:0
[]
The real line: +/*===============*/
Current Name Search:   static i_s_table_cache_t* cache_select_table( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,	/*!< in: whole cache */
Current Name Search:   static i_s_table_cache_t* cache_select_table(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,	
Depths: 0:0
[]
The real line: +	enum i_s_table		table)	/*!< in: which table */
Current Name Search:   static i_s_table_cache_t* cache_select_table(  	trx_i_s_cache_t*	cache,	 
LINE TO PARSE FOR KEYWORD:	enum i_s_table		table)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   static i_s_table_cache_t* cache_select_table(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table)	 
Checking if function:   static i_s_table_cache_t* cache_select_table(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table)	 {
PATTERN 1
Function:  i_s_table_cache_t* cache_select_table(  trx_i_s_cache_t*cache, enum i_s_tabletable) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	i_s_table_cache_t*	table_cache;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t*	table_cache;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef UNIV_SYNC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef univ_sync_debug
The real line: +	ut_a(rw_lock_own(&cache->rw_lock, RW_LOCK_SHARED)
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(rw_lock_own(&cache->rw_lock, rw_lock_shared)
The real line: +	     || rw_lock_own(&cache->rw_lock, RW_LOCK_EX));
End Check: 1
LINE TO PARSE FOR KEYWORD:	     || rw_lock_own(&cache->rw_lock, rw_lock_ex));
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	switch (table) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	switch (table) {
The real line: +	case I_S_INNODB_TRX:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case i_s_innodb_trx:
The real line: +		table_cache = &cache->innodb_trx;
End Check: 2
LINE TO PARSE FOR KEYWORD:		table_cache = &cache->innodb_trx;
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	case I_S_INNODB_LOCKS:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case i_s_innodb_locks:
The real line: +		table_cache = &cache->innodb_locks;
End Check: 2
LINE TO PARSE FOR KEYWORD:		table_cache = &cache->innodb_locks;
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	case I_S_INNODB_LOCK_WAITS:
End Check: 2
LINE TO PARSE FOR KEYWORD:	case i_s_innodb_lock_waits:
The real line: +		table_cache = &cache->innodb_lock_waits;
End Check: 2
LINE TO PARSE FOR KEYWORD:		table_cache = &cache->innodb_lock_waits;
The real line: +		break;
End Check: 2
LINE TO PARSE FOR KEYWORD:		break;
The real line: +	default:
End Check: 2
LINE TO PARSE FOR KEYWORD:	default:
The real line: +		ut_error;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ut_error;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(table_cache);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(table_cache);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1362 : 1385
Next: (  trx_i_s_cache_t*cache, enum i_s_tabletable)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Retrieves the number of used rows in the cache for a given
The real line: +INFORMATION SCHEMA table.
The real line: +@return	number of rows */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +ulint
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:ulint
Depths: 0:0
[]
The real line: +trx_i_s_cache_get_rows_used(
Current Name Search:   UNIV_INTERN ulint 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_get_rows_used(
Depths: 0:0
[]
The real line: +/*========================*/
Current Name Search:   UNIV_INTERN ulint trx_i_s_cache_get_rows_used( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,	/*!< in: cache */
Current Name Search:   UNIV_INTERN ulint trx_i_s_cache_get_rows_used(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,	
Depths: 0:0
[]
The real line: +	enum i_s_table		table)	/*!< in: which table */
Current Name Search:   UNIV_INTERN ulint trx_i_s_cache_get_rows_used(  	trx_i_s_cache_t*	cache,	 
LINE TO PARSE FOR KEYWORD:	enum i_s_table		table)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN ulint trx_i_s_cache_get_rows_used(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table)	 
Checking if function:   UNIV_INTERN ulint trx_i_s_cache_get_rows_used(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table)	 {
PATTERN 1
Function:  ulint trx_i_s_cache_get_rows_used(  trx_i_s_cache_t*cache, enum i_s_tabletable) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	i_s_table_cache_t*	table_cache;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t*	table_cache;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	table_cache = cache_select_table(cache, table);
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache = cache_select_table(cache, table);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(table_cache->rows_used);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(table_cache->rows_used);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1397 : 1403
Next: (  trx_i_s_cache_t*cache, enum i_s_tabletable)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Retrieves the nth row (zero-based) in the cache for a given
The real line: +INFORMATION SCHEMA table.
The real line: +@return	row */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +void*
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:void*
Depths: 0:0
[]
The real line: +trx_i_s_cache_get_nth_row(
Current Name Search:   UNIV_INTERN void* 
LINE TO PARSE FOR KEYWORD:trx_i_s_cache_get_nth_row(
Depths: 0:0
[]
The real line: +/*======================*/
Current Name Search:   UNIV_INTERN void* trx_i_s_cache_get_nth_row( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	trx_i_s_cache_t*	cache,	/*!< in: cache */
Current Name Search:   UNIV_INTERN void* trx_i_s_cache_get_nth_row(  
LINE TO PARSE FOR KEYWORD:	trx_i_s_cache_t*	cache,	
Depths: 0:0
[]
The real line: +	enum i_s_table		table,	/*!< in: which table */
Current Name Search:   UNIV_INTERN void* trx_i_s_cache_get_nth_row(  	trx_i_s_cache_t*	cache,	 
LINE TO PARSE FOR KEYWORD:	enum i_s_table		table,	
Depths: 0:0
[]
The real line: +	ulint			n)	/*!< in: row number */
Current Name Search:   UNIV_INTERN void* trx_i_s_cache_get_nth_row(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table,	 
LINE TO PARSE FOR KEYWORD:	ulint			n)	
Depths: 0:0
[]
The real line: +{
Current Name Search:   UNIV_INTERN void* trx_i_s_cache_get_nth_row(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table,	 	ulint			n)	 
Checking if function:   UNIV_INTERN void* trx_i_s_cache_get_nth_row(  	trx_i_s_cache_t*	cache,	 	enum i_s_table		table,	 	ulint			n)	 {
PATTERN 1
Function:  void* trx_i_s_cache_get_nth_row(  trx_i_s_cache_t*cache, enum i_s_tabletable, ulintn) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	i_s_table_cache_t*	table_cache;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i_s_table_cache_t*	table_cache;
The real line: +	ulint			i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ulint			i;
The real line: +	void*			row;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void*			row;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	table_cache = cache_select_table(cache, table);
End Check: 1
LINE TO PARSE FOR KEYWORD:	table_cache = cache_select_table(cache, table);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_a(n < table_cache->rows_used);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(n < table_cache->rows_used);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	row = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	row = null;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < MEM_CHUNKS_IN_TABLE_CACHE; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < mem_chunks_in_table_cache; i++) {
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (table_cache->chunks[i].offset
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (table_cache->chunks[i].offset
The real line: +		    + table_cache->chunks[i].rows_allocd > n) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		    + table_cache->chunks[i].rows_allocd > n) {
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			row = (char*) table_cache->chunks[i].base
End Check: 3
LINE TO PARSE FOR KEYWORD:			row = (char*) table_cache->chunks[i].base
The real line: +				+ (n - table_cache->chunks[i].offset)
End Check: 3
LINE TO PARSE FOR KEYWORD:				+ (n - table_cache->chunks[i].offset)
The real line: +				* table_cache->row_size;
End Check: 3
LINE TO PARSE FOR KEYWORD:				* table_cache->row_size;
The real line: +			break;
End Check: 3
LINE TO PARSE FOR KEYWORD:			break;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ut_a(row != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(row != null);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(row);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(row);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1416 : 1442
Next: (  trx_i_s_cache_t*cache, enum i_s_tabletable, ulintn)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*******************************************************************//**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +Crafts a lock id string from a i_s_locks_row_t object. Returns its
The real line: +second argument. This function aborts if there is not enough space in
The real line: +lock_id. Be sure to provide at least TRX_I_S_LOCK_ID_MAX_LEN + 1 if you
The real line: +want to be 100% sure that it will not abort.
The real line: +@return	resulting lock id */
The real line: +UNIV_INTERN
Current Name Search:   
LINE TO PARSE FOR KEYWORD:univ_intern
Depths: 0:0
[]
The real line: +char*
Current Name Search:   UNIV_INTERN 
LINE TO PARSE FOR KEYWORD:char*
Depths: 0:0
[]
The real line: +trx_i_s_create_lock_id(
Current Name Search:   UNIV_INTERN char* 
LINE TO PARSE FOR KEYWORD:trx_i_s_create_lock_id(
Depths: 0:0
[]
The real line: +/*===================*/
Current Name Search:   UNIV_INTERN char* trx_i_s_create_lock_id( 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +	const i_s_locks_row_t*	row,	/*!< in: innodb_locks row */
Current Name Search:   UNIV_INTERN char* trx_i_s_create_lock_id(  
LINE TO PARSE FOR KEYWORD:	const i_s_locks_row_t*	row,	
Depths: 0:0
[]
The real line: +	char*			lock_id,/*!< out: resulting lock_id */
Current Name Search:   UNIV_INTERN char* trx_i_s_create_lock_id(  	const i_s_locks_row_t*	row,	 
LINE TO PARSE FOR KEYWORD:	char*			lock_id,
Depths: 0:0
[]
The real line: +	ulint			lock_id_size)/*!< in: size of the lock id
Current Name Search:   UNIV_INTERN char* trx_i_s_create_lock_id(  	const i_s_locks_row_t*	row,	 	char*			lock_id, 
LINE TO PARSE FOR KEYWORD:	ulint			lock_id_size)
Depths: 0:0
[]
The real line: +					buffer */
The real line: +{
Current Name Search:   UNIV_INTERN char* trx_i_s_create_lock_id(  	const i_s_locks_row_t*	row,	 	char*			lock_id, 	ulint			lock_id_size) 
Checking if function:   UNIV_INTERN char* trx_i_s_create_lock_id(  	const i_s_locks_row_t*	row,	 	char*			lock_id, 	ulint			lock_id_size) {
PATTERN 1
Function:  char* trx_i_s_create_lock_id( i_s_locks_row_t*row, char*lock_id, ulintlock_id_size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	int	res_len;
End Check: 1
LINE TO PARSE FOR KEYWORD:	int	res_len;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* please adjust TRX_I_S_LOCK_ID_MAX_LEN if you change this */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (row->lock_space != ULINT_UNDEFINED) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (row->lock_space != ulint_undefined) {
The real line: +		/* record lock */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		res_len = ut_snprintf(lock_id, lock_id_size,
End Check: 2
LINE TO PARSE FOR KEYWORD:		res_len = ut_snprintf(lock_id, lock_id_size,
The real line: +				      TRX_ID_FMT ":%lu:%lu:%lu",
End Check: 2
LINE TO PARSE FOR KEYWORD:				      trx_id_fmt ,
The real line: +				      row->lock_trx_id, row->lock_space,
End Check: 2
LINE TO PARSE FOR KEYWORD:				      row->lock_trx_id, row->lock_space,
The real line: +				      row->lock_page, row->lock_rec);
End Check: 2
LINE TO PARSE FOR KEYWORD:				      row->lock_page, row->lock_rec);
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWOR.D:	} else {
The real line: +		/* table lock */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		res_len = ut_snprintf(lock_id, lock_id_size,
End Check: 2
LINE TO PARSE FOR KEYWORD:		res_len = ut_snprintf(lock_id, lock_id_size,
The real line: +				      TRX_ID_FMT ":%llu",
End Check: 2
LINE TO PARSE FOR KEYWORD:				      trx_id_fmt ,
The real line: +				      row->lock_trx_id,
End Check: 2
LINE TO PARSE FOR KEYWORD:				      row->lock_trx_id,
The real line: +				      row->lock_table_id);
End Check: 2
LINE TO PARSE FOR KEYWORD:				      row->lock_table_id);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* the typecast is safe because snprintf(3) never returns
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	negative result */
The real line: +	ut_a(res_len >= 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a(res_len >= 0);
The real line: +	ut_a((ulint) res_len < lock_id_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ut_a((ulint) res_len < lock_id_size);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return(lock_id);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return(lock_id);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1458 : 1483
Next: ( i_s_locks_row_t*row, char*lock_id, ulintlock_id_size)
Chunk End.
The real line: +/**
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * @file  SFMT.c
The real line: + * @brief SIMD oriented Fast Mersenne Twister(SFMT)
The real line: + *
The real line: + * @author Mutsuo Saito (Hiroshima University)
The real line: + * @author Makoto Matsumoto (Hiroshima University)
The real line: + *
The real line: + * Copyright (C) 2006, 2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima
The real line: + * University.
The real line: + * Copyright (C) 2012 Mutsuo Saito, Makoto Matsumoto, Hiroshima
The real line: + * University and The University of Tokyo.
The real line: + * All rights reserved.
The real line: + *
The real line: + * The 3-clause BSD License is applied to this software, see
The real line: + * LICENSE.txt
The real line: + */
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if defined(__cplusplus)
Current Name Search:   
LINE TO PARSE FOR KEYWORD:#if defined(__cplusplus)
Depths: 0:0
[]
The real line: +extern "C" {
Current Name Search:   #if defined(__cplusplus) 
Checking if function:   #if defined(__cplusplus) extern  {
Extern:  #if defined(__cplusplus) extern  {
LINE TO PARSE FOR KEYWORD:extern  {
Depths: 1:1
[]
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#include <string.h>
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:#include <string.h>
Depths: 1:1
[]
The real line: +#include <assert.h>
Current Name Search: #endif  #include <string.h> 
LINE TO PARSE FOR KEYWORD:#include <>
Depths: 1:1
[]
The real line: +#include "SFMT.h"
Current Name Search: #endif  #include <string.h> #include <assert.h> 
LINE TO PARSE FOR KEYWORD:#include 
Depths: 1:1
[]
The real line: +#include "SFMT-params.h"
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 1:1
[]
The real line: +#include "SFMT-common.h"
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 1:1
[]
The real line: +
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64)
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   
LINE TO PARSE FOR KEYWORD:#if defined(__big_endian__) && !defined(__amd64) && !defined(big_endian64)
Depths: 1:1
[]
The real line: +#define BIG_ENDIAN64 1
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) 
LINE TO PARSE FOR KEYWORD:#define big_endian64 1
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64)
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif 
LINE TO PARSE FOR KEYWORD:#if defined(have_altivec) && !defined(big_endian64)
Depths: 1:1
[]
The real line: +#define BIG_ENDIAN64 1
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) 
LINE TO PARSE FOR KEYWORD:#define big_endian64 1
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if defined(ONLY64) && !defined(BIG_ENDIAN64)
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif 
LINE TO PARSE FOR KEYWORD:#if defined(only64) && !defined(big_endian64)
Depths: 1:1
[]
The real line: +  #if defined(__GNUC__)
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64) 
LINE TO PARSE FOR KEYWORD:  #if defined(__gnuc__)
Depths: 1:1
[]
The real line: +    #error "-DONLY64 must be specified with -DBIG_ENDIAN64"
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__) 
LINE TO PARSE FOR KEYWORD:    #error 
Depths: 1:1
[]
The real line: +  #endif
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error  
LINE TO PARSE FOR KEYWORD:  #endif
Depths: 1:1
[]
The real line: +#undef ONLY64
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif 
LINE TO PARSE FOR KEYWORD:#undef only64
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif #undef ONLY64 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif #undef ONLY64 #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif #undef ONLY64 #endif  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * parameters used by sse2.
The real line: + */
The real line: +static const w128_t sse2_param_mask = {{SFMT_MSK1, SFMT_MSK2,
Current Name Search: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif #undef ONLY64 #endif   
Checking if function: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif #undef ONLY64 #endif   static const w128_t sse2_param_mask = {
Other type of bracket: #endif  #include <string.h> #include <assert.h> #include  #include  #include   #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64) #define BIG_ENDIAN64 1 #endif #if defined(ONLY64) && !defined(BIG_ENDIAN64)   #if defined(__GNUC__)     #error    #endif #undef ONLY64 #endif   static const w128_t sse2_param_mask = {
LINE TO PARSE FOR KEYWORD:static const w128_t sse2_param_mask = {{sfmt_msk1, sfmt_msk2,
Depths: 3:2
[]
The real line: +					SFMT_MSK3, SFMT_MSK4}};
Current Name Search: 
Checking if function: 					SFMT_MSK3, SFMT_MSK4}};
Other type of bracket: 					SFMT_MSK3, SFMT_MSK4}};
LINE TO PARSE FOR KEYWORD:					sfmt_msk3, sfmt_msk4}};
Depths: 1:3
[]
Adjusting depth.
The real line: +/*----------------
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +  STATIC FUNCTIONS
The real line: +  ----------------*/
The real line: +inline static int idxof(int i);
Current Name Search:  
LINE TO PARSE FOR KEYWORD:inline static int idxof(int i);
Depths: 1:1
[]
The real line: +inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size);
Current Name Search: inline static int idxof(int i); 
LINE TO PARSE FOR KEYWORD:inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size);
Depths: 1:1
[]
The real line: +inline static uint32_t func1(uint32_t x);
Current Name Search: inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size); 
LINE TO PARSE FOR KEYWORD:inline static uint32_t func1(uint32_t x);
Depths: 1:1
[]
The real line: +inline static uint32_t func2(uint32_t x);
Current Name Search: inline static uint32_t func1(uint32_t x); 
LINE TO PARSE FOR KEYWORD:inline static uint32_t func2(uint32_t x);
Depths: 1:1
[]
The real line: +static void period_certification(sfmt_t * sfmt);
Current Name Search: inline static uint32_t func2(uint32_t x); 
LINE TO PARSE FOR KEYWORD:static void period_certification(sfmt_t * sfmt);
Depths: 1:1
[]
The real line: +#if defined(BIG_ENDIAN64) && !defined(ONLY64)
Current Name Search: static void period_certification(sfmt_t * sfmt); 
LINE TO PARSE FOR KEYWORD:#if defined(big_endian64) && !defined(only64)
Depths: 1:1
[]
The real line: +inline static void swap(w128_t *array, int size);
Current Name Search: static void period_certification(sfmt_t * sfmt); #if defined(BIG_ENDIAN64) && !defined(ONLY64) 
LINE TO PARSE FOR KEYWORD:inline static void swap(w128_t *array, int size);
Depths: 1:1
[]
The real line: +#endif
Current Name Search: inline static void swap(w128_t *array, int size); 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: inline static void swap(w128_t *array, int size); #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#if defined(HAVE_ALTIVEC)
Current Name Search: inline static void swap(w128_t *array, int size); #endif  
LINE TO PARSE FOR KEYWORD:#if defined(have_altivec)
Depths: 1:1
[]
The real line: +  #include "SFMT-alti.h"
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC) 
LINE TO PARSE FOR KEYWORD:  #include 
Depths: 1:1
[]
The real line: +#elif defined(HAVE_SSE2)
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  
LINE TO PARSE FOR KEYWORD:#elif defined(have_sse2)
Depths: 1:1
[]
The real line: +  #include "SFMT-sse2.h"
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2) 
LINE TO PARSE FOR KEYWORD:  #include 
Depths: 1:1
[]
The real line: +#endif
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2)   #include  
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2)   #include  #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2)   #include  #endif  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function simulate a 64-bit index of LITTLE ENDIAN
The real line: + * in BIG ENDIAN machine.
The real line: + */
The real line: +#ifdef ONLY64
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2)   #include  #endif   
LINE TO PARSE FOR KEYWORD:#ifdef only64
Depths: 1:1
[]
The real line: +inline static int idxof(int i) {
Current Name Search: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2)   #include  #endif   #ifdef ONLY64 
Checking if function: inline static void swap(w128_t *array, int size); #endif  #if defined(HAVE_ALTIVEC)   #include  #elif defined(HAVE_SSE2)   #include  #endif   #ifdef ONLY64 inline static int idxof(int i) {
PATTERN 1
Function:  endif  defined(HAVE_ALTIVEC)   include  elif defined(HAVE_SSE2)   include  endif    ONLY64 inline static int idxof(int i) {
LINE TO PARSE FOR KEYWORD:inline static int idxof(int i) {
Depths: 2:1
[]
The real line: +    return i ^ 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return i ^ 1;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
69 : 71
Next: (HAVE_ALTIVEC)
Next: (HAVE_SSE2)
Next: (int i)
The real line: +#else
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#else
Depths: 1:1
[]
The real line: +inline static int idxof(int i) {
Current Name Search: #else 
Checking if function: #else inline static int idxof(int i) {
PATTERN 1
Function:  int idxof(int i) {
LINE TO PARSE FOR KEYWORD:inline static int idxof(int i) {
Depths: 2:1
[]
The real line: +    return i;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return i;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
73 : 75
Next: (int i)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:#if (!defined(have_altivec)) && (!defined(have_sse2))
Depths: 1:1
[]
The real line: +/**
Current Name Search: #endif  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2)) 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function fills the user-specified array with pseudorandom
The real line: + * integers.
The real line: + *
The real line: + * @param sfmt SFMT internal state
The real line: + * @param array an 128-bit array to be filled by pseudorandom numbers.
The real line: + * @param size number of 128-bit pseudorandom numbers to be generated.
The real line: + */
The real line: +inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size) {
Current Name Search: #endif  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))  
Checking if function: #endif  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))  inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size) {
PATTERN 1
Function:  void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size) {
LINE TO PARSE FOR KEYWORD:inline static void gen_rand_array(sfmt_t * sfmt, w128_t *array, int size) {
Depths: 2:1
[]
The real line: +    int i, j;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int i, j;
The real line: +    w128_t *r1, *r2;
End Check: 2
LINE TO PARSE FOR KEYWORD:    w128_t *r1, *r2;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    r1 = &sfmt->state[SFMT_N - 2];
End Check: 2
LINE TO PARSE FOR KEYWORD:    r1 = &sfmt->state[sfmt_n - 2];
The real line: +    r2 = &sfmt->state[SFMT_N - 1];
End Check: 2
LINE TO PARSE FOR KEYWORD:    r2 = &sfmt->state[sfmt_n - 1];
The real line: +    for (i = 0; i < SFMT_N - SFMT_POS1; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < sfmt_n - sfmt_pos1; i++) {
The real line: +	do_recursion(&array[i], &sfmt->state[i], &sfmt->state[i + SFMT_POS1], r1, r2);
End Check: 3
LINE TO PARSE FOR KEYWORD:	do_recursion(&array[i], &sfmt->state[i], &sfmt->state[i + sfmt_pos1], r1, r2);
The real line: +	r1 = r2;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r1 = r2;
The real line: +	r2 = &array[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	r2 = &array[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (; i < SFMT_N; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (; i < sfmt_n; i++) {
The real line: +	do_recursion(&array[i], &sfmt->state[i],
End Check: 3
LINE TO PARSE FOR KEYWORD:	do_recursion(&array[i], &sfmt->state[i],
The real line: +		     &array[i + SFMT_POS1 - SFMT_N], r1, r2);
End Check: 3
LINE TO PARSE FOR KEYWORD:		     &array[i + sfmt_pos1 - sfmt_n], r1, r2);
The real line: +	r1 = r2;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r1 = r2;
The real line: +	r2 = &array[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	r2 = &array[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (; i < size - SFMT_N; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (; i < size - sfmt_n; i++) {
The real line: +	do_recursion(&array[i], &array[i - SFMT_N],
End Check: 3
LINE TO PARSE FOR KEYWORD:	do_recursion(&array[i], &array[i - sfmt_n],
The real line: +		     &array[i + SFMT_POS1 - SFMT_N], r1, r2);
End Check: 3
LINE TO PARSE FOR KEYWORD:		     &array[i + sfmt_pos1 - sfmt_n], r1, r2);
The real line: +	r1 = r2;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r1 = r2;
The real line: +	r2 = &array[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	r2 = &array[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (j = 0; j < 2 * SFMT_N - size; j++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (j = 0; j < 2 * sfmt_n - size; j++) {
The real line: +	sfmt->state[j] = array[j + size - SFMT_N];
End Check: 3
LINE TO PARSE FOR KEYWORD:	sfmt->state[j] = array[j + size - sfmt_n];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (; i < size; i++, j++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (; i < size; i++, j++) {
The real line: +	do_recursion(&array[i], &array[i - SFMT_N],
End Check: 3
LINE TO PARSE FOR KEYWORD:	do_recursion(&array[i], &array[i - sfmt_n],
The real line: +		     &array[i + SFMT_POS1 - SFMT_N], r1, r2);
End Check: 3
LINE TO PARSE FOR KEYWORD:		     &array[i + sfmt_pos1 - sfmt_n], r1, r2);
The real line: +	r1 = r2;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r1 = r2;
The real line: +	r2 = &array[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	r2 = &array[i];
The real line: +	sfmt->state[j] = array[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	sfmt->state[j] = array[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
87 : 120
Next: (sfmt_t * sfmt, w128_t *array, int size)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(HAVE_ALTIVEC)
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:#if defined(big_endian64) && !defined(only64) && !defined(have_altivec)
Depths: 1:1
[]
The real line: +inline static void swap(w128_t *array, int size) {
Current Name Search: #endif  #if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(HAVE_ALTIVEC) 
Checking if function: #endif  #if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(HAVE_ALTIVEC) inline static void swap(w128_t *array, int size) {
PATTERN 1
Function:  void swap(w128_t *array, int size) {
LINE TO PARSE FOR KEYWORD:inline static void swap(w128_t *array, int size) {
Depths: 2:1
[]
The real line: +    int i;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int i;
The real line: +    uint32_t x, y;
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint32_t x, y;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    for (i = 0; i < size; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < size; i++) {
The real line: +	x = array[i].u[0];
End Check: 3
LINE TO PARSE FOR KEYWORD:	x = array[i].u[0];
The real line: +	y = array[i].u[2];
End Check: 3
LINE TO PARSE FOR KEYWORD:	y = array[i].u[2];
The real line: +	array[i].u[0] = array[i].u[1];
End Check: 3
LINE TO PARSE FOR KEYWORD:	array[i].u[0] = array[i].u[1];
The real line: +	array[i].u[2] = array[i].u[3];
End Check: 3
LINE TO PARSE FOR KEYWORD:	array[i].u[2] = array[i].u[3];
The real line: +	array[i].u[1] = x;
End Check: 3
LINE TO PARSE FOR KEYWORD:	array[i].u[1] = x;
The real line: +	array[i].u[3] = y;
End Check: 3
LINE TO PARSE FOR KEYWORD:	array[i].u[3] = y;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
124 : 136
Next: (w128_t *array, int size)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +/**
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function represents a function used in the initialization
The real line: + * by init_by_array
The real line: + * @param x 32-bit integer
The real line: + * @return 32-bit integer
The real line: + */
The real line: +static uint32_t func1(uint32_t x) {
Current Name Search: #endif  
Checking if function: #endif  static uint32_t func1(uint32_t x) {
PATTERN 1
Function:  uint32_t func1(uint32_t x) {
LINE TO PARSE FOR KEYWORD:static uint32_t func1(uint32_t x) {
Depths: 2:1
[]
The real line: +    return (x ^ (x >> 27)) * (uint32_t)1664525UL;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return (x ^ (x >> 27)) * (uint32_t)1664525ul;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
144 : 146
Next: (uint32_t x)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function represents a function used in the initialization
The real line: + * by init_by_array
The real line: + * @param x 32-bit integer
The real line: + * @return 32-bit integer
The real line: + */
The real line: +static uint32_t func2(uint32_t x) {
Current Name Search:   
Checking if function:   static uint32_t func2(uint32_t x) {
PATTERN 1
Function:  uint32_t func2(uint32_t x) {
LINE TO PARSE FOR KEYWORD:static uint32_t func2(uint32_t x) {
Depths: 2:1
[]
The real line: +    return (x ^ (x >> 27)) * (uint32_t)1566083941UL;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return (x ^ (x >> 27)) * (uint32_t)1566083941ul;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
154 : 156
Next: (uint32_t x)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function certificate the period of 2^{MEXP}
The real line: + * @param sfmt SFMT internal state
The real line: + */
The real line: +static void period_certification(sfmt_t * sfmt) {
Current Name Search:   
Checking if function:   static void period_certification(sfmt_t * sfmt) {
PATTERN 1
Function:  void period_certification(sfmt_t * sfmt) {
LINE TO PARSE FOR KEYWORD:static void period_certification(sfmt_t * sfmt) {
Depths: 2:1
[]
The real line: +    int inner = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int inner = 0;
The real line: +    int i, j;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int i, j;
The real line: +    uint32_t work;
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint32_t work;
The real line: +    uint32_t *psfmt32 = &sfmt->state[0].u[0];
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint32_t *psfmt32 = &sfmt->state[0].u[0];
The real line: +    const uint32_t parity[4] = {SFMT_PARITY1, SFMT_PARITY2,
End Check: 3
LINE TO PARSE FOR KEYWORD:    const uint32_t parity[4] = {sfmt_parity1, sfmt_parity2,
The real line: +				SFMT_PARITY3, SFMT_PARITY4};
End Check: 2
LINE TO PARSE FOR KEYWORD:				sfmt_parity3, sfmt_parity4};
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    for (i = 0; i < 4; i++)
End Check: 2
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < 4; i++)
The real line: +	inner ^= psfmt32[idxof(i)] & parity[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:	inner ^= psfmt32[idxof(i)] & parity[i];
The real line: +    for (i = 16; i > 0; i >>= 1)
End Check: 2
LINE TO PARSE FOR KEYWORD:    for (i = 16; i > 0; i >>= 1)
The real line: +	inner ^= inner >> i;
End Check: 2
LINE TO PARSE FOR KEYWORD:	inner ^= inner >> i;
The real line: +    inner &= 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:    inner &= 1;
The real line: +    /* check OK */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    if (inner == 1) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (inner == 1) {
The real line: +	return;
End Check: 3
LINE TO PARSE FOR KEYWORD:	return;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    /* check NG, and modification */
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    for (i = 0; i < 4; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < 4; i++) {
The real line: +	work = 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:	work = 1;
The real line: +	for (j = 0; j < 32; j++) {
End Check: 4
LINE TO PARSE FOR KEYWORD:	for (j = 0; j < 32; j++) {
The real line: +	    if ((work & parity[i]) != 0) {
End Check: 5
LINE TO PARSE FOR KEYWORD:	    if ((work & parity[i]) != 0) {
The real line: +		psfmt32[idxof(i)] ^= work;
End Check: 5
LINE TO PARSE FOR KEYWORD:		psfmt32[idxof(i)] ^= work;
The real line: +		return;
End Check: 5
LINE TO PARSE FOR KEYWORD:		return;
The real line: +	    }
End Check: 4
LINE TO PARSE FOR KEYWORD:	    }
The real line: +	    work = work << 1;
End Check: 4
LINE TO PARSE FOR KEYWORD:	    work = work << 1;
The real line: +	}
End Check: 3
LINE TO PARSE FOR KEYWORD:	}
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
162 : 190
Next: (sfmt_t * sfmt)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/*----------------
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +  PUBLIC FUNCTIONS
The real line: +  ----------------*/
The real line: +#define UNUSED_VARIABLE(x) (void)(x)
Current Name Search:   
LINE TO PARSE FOR KEYWORD:#define unused_variable(x) (void)(x)
Depths: 1:1
[]
The real line: +/**
Current Name Search:   #define UNUSED_VARIABLE(x) (void)(x) 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function returns the identification string.
The real line: + * The string shows the word size, the Mersenne exponent,
The real line: + * and all parameters of this generator.
The real line: + * @param sfmt SFMT internal state
The real line: + */
The real line: +const char *sfmt_get_idstring(sfmt_t * sfmt) {
Current Name Search:   #define UNUSED_VARIABLE(x) (void)(x)  
Checking if function:   #define UNUSED_VARIABLE(x) (void)(x)  const char *sfmt_get_idstring(sfmt_t * sfmt) {
PATTERN 2
Function:  char *sfmt_get_idstring(sfmt_t * sfmt) {
LINE TO PARSE FOR KEYWORD:const char *sfmt_get_idstring(sfmt_t * sfmt) {
Depths: 2:1
[]
The real line: +    UNUSED_VARIABLE(sfmt);
End Check: 2
LINE TO PARSE FOR KEYWORD:    unused_variable(sfmt);
The real line: +    return SFMT_IDSTR;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return sfmt_idstr;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
202 : 205
Next: (sfmt_t * sfmt)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function returns the minimum size of array used for \b
The real line: + * fill_array32() function.
The real line: + * @param sfmt SFMT internal state
The real line: + * @return minimum size of array used for fill_array32() function.
The real line: + */
The real line: +int sfmt_get_min_array_size32(sfmt_t * sfmt) {
Current Name Search:   
Checking if function:   int sfmt_get_min_array_size32(sfmt_t * sfmt) {
PATTERN 4
Function: int sfmt_get_min_array_size32(sfmt_t * sfmt) {
LINE TO PARSE FOR KEYWORD:int sfmt_get_min_array_size32(sfmt_t * sfmt) {
Depths: 2:1
[]
The real line: +    UNUSED_VARIABLE(sfmt);
End Check: 2
LINE TO PARSE FOR KEYWORD:    unused_variable(sfmt);
The real line: +    return SFMT_N32;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return sfmt_n32;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
213 : 216
Next: (sfmt_t * sfmt)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function returns the minimum size of array used for \b
The real line: + * fill_array64() function.
The real line: + * @param sfmt SFMT internal state
The real line: + * @return minimum size of array used for fill_array64() function.
The real line: + */
The real line: +int sfmt_get_min_array_size64(sfmt_t * sfmt) {
Current Name Search:   
Checking if function:   int sfmt_get_min_array_size64(sfmt_t * sfmt) {
PATTERN 4
Function: int sfmt_get_min_array_size64(sfmt_t * sfmt) {
LINE TO PARSE FOR KEYWORD:int sfmt_get_min_array_size64(sfmt_t * sfmt) {
Depths: 2:1
[]
The real line: +    UNUSED_VARIABLE(sfmt);
End Check: 2
LINE TO PARSE FOR KEYWORD:    unused_variable(sfmt);
The real line: +    return SFMT_N64;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return sfmt_n64;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
224 : 227
Next: (sfmt_t * sfmt)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#if !defined(HAVE_SSE2) && !defined(HAVE_ALTIVEC)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#if !defined(have_sse2) && !defined(have_altivec)
Depths: 1:1
[]
The real line: +/**
Current Name Search:  #if !defined(HAVE_SSE2) && !defined(HAVE_ALTIVEC) 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function fills the internal state array with pseudorandom
The real line: + * integers.
The real line: + * @param sfmt SFMT internal state
The real line: + */
The real line: +void sfmt_gen_rand_all(sfmt_t * sfmt) {
Current Name Search:  #if !defined(HAVE_SSE2) && !defined(HAVE_ALTIVEC)  
Checking if function:  #if !defined(HAVE_SSE2) && !defined(HAVE_ALTIVEC)  void sfmt_gen_rand_all(sfmt_t * sfmt) {
PATTERN 1
Function:  void sfmt_gen_rand_all(sfmt_t * sfmt) {
LINE TO PARSE FOR KEYWORD:void sfmt_gen_rand_all(sfmt_t * sfmt) {
Depths: 2:1
[]
The real line: +    int i;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int i;
The real line: +    w128_t *r1, *r2;
End Check: 2
LINE TO PARSE FOR KEYWORD:    w128_t *r1, *r2;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    r1 = &sfmt->state[SFMT_N - 2];
End Check: 2
LINE TO PARSE FOR KEYWORD:    r1 = &sfmt->state[sfmt_n - 2];
The real line: +    r2 = &sfmt->state[SFMT_N - 1];
End Check: 2
LINE TO PARSE FOR KEYWORD:    r2 = &sfmt->state[sfmt_n - 1];
The real line: +    for (i = 0; i < SFMT_N - SFMT_POS1; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < sfmt_n - sfmt_pos1; i++) {
The real line: +	do_recursion(&sfmt->state[i], &sfmt->state[i],
End Check: 3
LINE TO PARSE FOR KEYWORD:	do_recursion(&sfmt->state[i], &sfmt->state[i],
The real line: +		     &sfmt->state[i + SFMT_POS1], r1, r2);
End Check: 3
LINE TO PARSE FOR KEYWORD:		     &sfmt->state[i + sfmt_pos1], r1, r2);
The real line: +	r1 = r2;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r1 = r2;
The real line: +	r2 = &sfmt->state[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	r2 = &sfmt->state[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (; i < SFMT_N; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (; i < sfmt_n; i++) {
The real line: +	do_recursion(&sfmt->state[i], &sfmt->state[i],
End Check: 3
LINE TO PARSE FOR KEYWORD:	do_recursion(&sfmt->state[i], &sfmt->state[i],
The real line: +		     &sfmt->state[i + SFMT_POS1 - SFMT_N], r1, r2);
End Check: 3
LINE TO PARSE FOR KEYWORD:		     &sfmt->state[i + sfmt_pos1 - sfmt_n], r1, r2);
The real line: +	r1 = r2;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r1 = r2;
The real line: +	r2 = &sfmt->state[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:	r2 = &sfmt->state[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
235 : 253
Next: (sfmt_t * sfmt)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#ifndef ONLY64
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:#ifndef only64
Depths: 1:1
[]
The real line: +/**
Current Name Search: #endif  #ifndef ONLY64 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function generates pseudorandom 32-bit integers in the
The real line: + * specified array[] by one call. The number of pseudorandom integers
The real line: + * is specified by the argument size, which must be at least 624 and a
The real line: + * multiple of four.  The generation by this function is much faster
The real line: + * than the following gen_rand function.
The real line: + *
The real line: + * For initialization, init_gen_rand or init_by_array must be called
The real line: + * before the first call of this function. This function can not be
The real line: + * used after calling gen_rand function, without initialization.
The real line: + *
The real line: + * @param sfmt SFMT internal state
The real line: + * @param array an array where pseudorandom 32-bit integers are filled
The real line: + * by this function.  The pointer to the array must be \b "aligned"
The real line: + * (namely, must be a multiple of 16) in the SIMD version, since it
The real line: + * refers to the address of a 128-bit integer.  In the standard C
The real line: + * version, the pointer is arbitrary.
The real line: + *
The real line: + * @param size the number of 32-bit pseudorandom integers to be
The real line: + * generated.  size must be a multiple of 4, and greater than or equal
The real line: + * to (MEXP / 128 + 1) * 4.
The real line: + *
The real line: + * @note \b memalign or \b posix_memalign is available to get aligned
The real line: + * memory. Mac OSX doesn't have these functions, but \b malloc of OSX
The real line: + * returns the pointer to the aligned memory block.
The real line: + */
The real line: +void sfmt_fill_array32(sfmt_t * sfmt, uint32_t *array, int size) {
Current Name Search: #endif  #ifndef ONLY64  
Checking if function: #endif  #ifndef ONLY64  void sfmt_fill_array32(sfmt_t * sfmt, uint32_t *array, int size) {
PATTERN 1
Function:  void sfmt_fill_array32(sfmt_t * sfmt, uint32_t *array, int size) {
LINE TO PARSE FOR KEYWORD:void sfmt_fill_array32(sfmt_t * sfmt, uint32_t *array, int size) {
Depths: 2:1
[]
The real line: +    assert(sfmt->idx == SFMT_N32);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert(sfmt->idx == sfmt_n32);
The real line: +    assert(size % 4 == 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert(size % 4 == 0);
The real line: +    assert(size >= SFMT_N32);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert(size >= sfmt_n32);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    gen_rand_array(sfmt, (w128_t *)array, size / 4);
End Check: 2
LINE TO PARSE FOR KEYWORD:    gen_rand_array(sfmt, (w128_t *)array, size / 4);
The real line: +    sfmt->idx = SFMT_N32;
End Check: 2
LINE TO PARSE FOR KEYWORD:    sfmt->idx = sfmt_n32;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
283 : 290
Next: (sfmt_t * sfmt, uint32_t *array, int size)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function generates pseudorandom 64-bit integers in the
The real line: + * specified array[] by one call. The number of pseudorandom integers
The real line: + * is specified by the argument size, which must be at least 312 and a
The real line: + * multiple of two.  The generation by this function is much faster
The real line: + * than the following gen_rand function.
The real line: + *
The real line: + * @param sfmt SFMT internal state
The real line: + * For initialization, init_gen_rand or init_by_array must be called
The real line: + * before the first call of this function. This function can not be
The real line: + * used after calling gen_rand function, without initialization.
The real line: + *
The real line: + * @param array an array where pseudorandom 64-bit integers are filled
The real line: + * by this function.  The pointer to the array must be "aligned"
The real line: + * (namely, must be a multiple of 16) in the SIMD version, since it
The real line: + * refers to the address of a 128-bit integer.  In the standard C
The real line: + * version, the pointer is arbitrary.
The real line: + *
The real line: + * @param size the number of 64-bit pseudorandom integers to be
The real line: + * generated.  size must be a multiple of 2, and greater than or equal
The real line: + * to (MEXP / 128 + 1) * 2
The real line: + *
The real line: + * @note \b memalign or \b posix_memalign is available to get aligned
The real line: + * memory. Mac OSX doesn't have these functions, but \b malloc of OSX
The real line: + * returns the pointer to the aligned memory block.
The real line: + */
The real line: +void sfmt_fill_array64(sfmt_t * sfmt, uint64_t *array, int size) {
Current Name Search: #endif   
Checking if function: #endif   void sfmt_fill_array64(sfmt_t * sfmt, uint64_t *array, int size) {
PATTERN 1
Function:  void sfmt_fill_array64(sfmt_t * sfmt, uint64_t *array, int size) {
LINE TO PARSE FOR KEYWORD:void sfmt_fill_array64(sfmt_t * sfmt, uint64_t *array, int size) {
Depths: 2:1
[]
The real line: +    assert(sfmt->idx == SFMT_N32);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert(sfmt->idx == sfmt_n32);
The real line: +    assert(size % 2 == 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert(size % 2 == 0);
The real line: +    assert(size >= SFMT_N64);
End Check: 2
LINE TO PARSE FOR KEYWORD:    assert(size >= sfmt_n64);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    gen_rand_array(sfmt, (w128_t *)array, size / 2);
End Check: 2
LINE TO PARSE FOR KEYWORD:    gen_rand_array(sfmt, (w128_t *)array, size / 2);
The real line: +    sfmt->idx = SFMT_N32;
End Check: 2
LINE TO PARSE FOR KEYWORD:    sfmt->idx = sfmt_n32;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#if defined(BIG_ENDIAN64) && !defined(ONLY64)
End Check: 2
LINE TO PARSE FOR KEYWORD:#if defined(big_endian64) && !defined(only64)
The real line: +    swap((w128_t *)array, size /2);
End Check: 2
LINE TO PARSE FOR KEYWORD:    swap((w128_t *)array, size /2);
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
319 : 330
Next: (sfmt_t * sfmt, uint64_t *array, int size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function initializes the internal state array with a 32-bit
The real line: + * integer seed.
The real line: + *
The real line: + * @param sfmt SFMT internal state
The real line: + * @param seed a 32-bit integer used as the seed.
The real line: + */
The real line: +void sfmt_init_gen_rand(sfmt_t * sfmt, uint32_t seed) {
Current Name Search:   
Checking if function:   void sfmt_init_gen_rand(sfmt_t * sfmt, uint32_t seed) {
PATTERN 4
Function: void sfmt_init_gen_rand(sfmt_t * sfmt, uint32_t seed) {
LINE TO PARSE FOR KEYWORD:void sfmt_init_gen_rand(sfmt_t * sfmt, uint32_t seed) {
Depths: 2:1
[]
The real line: +    int i;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int i;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    uint32_t *psfmt32 = &sfmt->state[0].u[0];
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint32_t *psfmt32 = &sfmt->state[0].u[0];
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    psfmt32[idxof(0)] = seed;
End Check: 2
LINE TO PARSE FOR KEYWORD:    psfmt32[idxof(0)] = seed;
The real line: +    for (i = 1; i < SFMT_N32; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 1; i < sfmt_n32; i++) {
The real line: +	psfmt32[idxof(i)] = 1812433253UL * (psfmt32[idxof(i - 1)]
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof(i)] = 1812433253ul * (psfmt32[idxof(i - 1)]
The real line: +					    ^ (psfmt32[idxof(i - 1)] >> 30))
End Check: 3
LINE TO PARSE FOR KEYWORD:					    ^ (psfmt32[idxof(i - 1)] >> 30))
The real line: +	    + i;
End Check: 3
LINE TO PARSE FOR KEYWORD:	    + i;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    sfmt->idx = SFMT_N32;
End Check: 2
LINE TO PARSE FOR KEYWORD:    sfmt->idx = sfmt_n32;
The real line: +    period_certification(sfmt);
End Check: 2
LINE TO PARSE FOR KEYWORD:    period_certification(sfmt);
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
339 : 352
Next: (sfmt_t * sfmt, uint32_t seed)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: + * This function initializes the internal state array,
The real line: + * with an array of 32-bit integers used as the seeds
The real line: + * @param sfmt SFMT internal state
The real line: + * @param init_key the array of 32-bit integers, used as a seed.
The real line: + * @param key_length the length of init_key.
The real line: + */
The real line: +void sfmt_init_by_array(sfmt_t * sfmt, uint32_t *init_key, int key_length) {
Current Name Search:   
Checking if function:   void sfmt_init_by_array(sfmt_t * sfmt, uint32_t *init_key, int key_length) {
PATTERN 4
Function: void sfmt_init_by_array(sfmt_t * sfmt, uint32_t *init_key, int key_length) {
LINE TO PARSE FOR KEYWORD:void sfmt_init_by_array(sfmt_t * sfmt, uint32_t *init_key, int key_length) {
Depths: 2:1
[]
The real line: +    int i, j, count;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int i, j, count;
The real line: +    uint32_t r;
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint32_t r;
The real line: +    int lag;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int lag;
The real line: +    int mid;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int mid;
The real line: +    int size = SFMT_N * 4;
End Check: 2
LINE TO PARSE FOR KEYWORD:    int size = sfmt_n * 4;
The real line: +    uint32_t *psfmt32 = &sfmt->state[0].u[0];
End Check: 2
LINE TO PARSE FOR KEYWORD:    uint32_t *psfmt32 = &sfmt->state[0].u[0];
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    if (size >= 623) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (size >= 623) {
The real line: +	lag = 11;
End Check: 3
LINE TO PARSE FOR KEYWORD:	lag = 11;
The real line: +    } else if (size >= 68) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    } else if (size >= 68) {
The real line: +	lag = 7;
End Check: 3
LINE TO PARSE FOR KEYWORD:	lag = 7;
The real line: +    } else if (size >= 39) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    } else if (size >= 39) {
The real line: +	lag = 5;
End Check: 3
LINE TO PARSE FOR KEYWORD:	lag = 5;
The real line: +    } else {
End Check: 3
LINE TO PARSE FOR KEYWORD:    } else {
The real line: +	lag = 3;
End Check: 3
LINE TO PARSE FOR KEYWORD:	lag = 3;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    mid = (size - lag) / 2;
End Check: 2
LINE TO PARSE FOR KEYWORD:    mid = (size - lag) / 2;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    memset(sfmt, 0x8b, sizeof(sfmt_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:    memset(sfmt, 0x8b, sizeof(sfmt_t));
The real line: +    if (key_length + 1 > SFMT_N32) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (key_length + 1 > sfmt_n32) {
The real line: +	count = key_length + 1;
End Check: 3
LINE TO PARSE FOR KEYWORD:	count = key_length + 1;
The real line: +    } else {
End Check: 3
LINE TO PARSE FOR KEYWORD:    } else {
The real line: +	count = SFMT_N32;
End Check: 3
LINE TO PARSE FOR KEYWORD:	count = sfmt_n32;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    r = func1(psfmt32[idxof(0)] ^ psfmt32[idxof(mid)]
End Check: 2
LINE TO PARSE FOR KEYWORD:    r = func1(psfmt32[idxof(0)] ^ psfmt32[idxof(mid)]
The real line: +	      ^ psfmt32[idxof(SFMT_N32 - 1)]);
End Check: 2
LINE TO PARSE FOR KEYWORD:	      ^ psfmt32[idxof(sfmt_n32 - 1)]);
The real line: +    psfmt32[idxof(mid)] += r;
End Check: 2
LINE TO PARSE FOR KEYWORD:    psfmt32[idxof(mid)] += r;
The real line: +    r += key_length;
End Check: 2
LINE TO PARSE FOR KEYWORD:    r += key_length;
The real line: +    psfmt32[idxof(mid + lag)] += r;
End Check: 2
LINE TO PARSE FOR KEYWORD:    psfmt32[idxof(mid + lag)] += r;
The real line: +    psfmt32[idxof(0)] = r;
End Check: 2
LINE TO PARSE FOR KEYWORD:    psfmt32[idxof(0)] = r;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    count--;
End Check: 2
LINE TO PARSE FOR KEYWORD:    count--;
The real line: +    for (i = 1, j = 0; (j < count) && (j < key_length); j++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 1, j = 0; (j < count) && (j < key_length); j++) {
The real line: +	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % SFMT_N32)]
End Check: 3
LINE TO PARSE FOR KEYWORD:	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % sfmt_n32)]
The real line: +		  ^ psfmt32[idxof((i + SFMT_N32 - 1) % SFMT_N32)]);
End Check: 3
LINE TO PARSE FOR KEYWORD:		  ^ psfmt32[idxof((i + sfmt_n32 - 1) % sfmt_n32)]);
The real line: +	psfmt32[idxof((i + mid) % SFMT_N32)] += r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof((i + mid) % sfmt_n32)] += r;
The real line: +	r += init_key[j] + i;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r += init_key[j] + i;
The real line: +	psfmt32[idxof((i + mid + lag) % SFMT_N32)] += r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof((i + mid + lag) % sfmt_n32)] += r;
The real line: +	psfmt32[idxof(i)] = r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof(i.)] = r;
The real line: +	i = (i + 1) % SFMT_N32;
End Check: 3
LINE TO PARSE FOR KEYWORD:	i = (i + 1) % sfmt_n32;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (; j < count; j++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (; j < count; j++) {
The real line: +	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % SFMT_N32)]
End Check: 3
LINE TO PARSE FOR KEYWORD:	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % sfmt_n32)]
The real line: +		  ^ psfmt32[idxof((i + SFMT_N32 - 1) % SFMT_N32)]);
End Check: 3
LINE TO PARSE FOR KEYWORD:		  ^ psfmt32[idxof((i + sfmt_n32 - 1) % sfmt_n32)]);
The real line: +	psfmt32[idxof((i + mid) % SFMT_N32)] += r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof((i + mid) % sfmt_n32)] += r;
The real line: +	r += i;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r += i;
The real line: +	psfmt32[idxof((i + mid + lag) % SFMT_N32)] += r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof((i + mid + lag) % sfmt_n32)] += r;
The real line: +	psfmt32[idxof(i)] = r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof(i)] = r;
The real line: +	i = (i + 1) % SFMT_N32;
End Check: 3
LINE TO PARSE FOR KEYWORD:	i = (i + 1) % sfmt_n32;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    for (j = 0; j < SFMT_N32; j++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (j = 0; j < sfmt_n32; j++) {
The real line: +	r = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % SFMT_N32)]
End Check: 3
LINE TO PARSE FOR KEYWORD:	r = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % sfmt_n32)]
The real line: +		  + psfmt32[idxof((i + SFMT_N32 - 1) % SFMT_N32)]);
End Check: 3
LINE TO PARSE FOR KEYWORD:		  + psfmt32[idxof((i + sfmt_n32 - 1) % sfmt_n32)]);
The real line: +	psfmt32[idxof((i + mid) % SFMT_N32)] ^= r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof((i + mid) % sfmt_n32)] ^= r;
The real line: +	r -= i;
End Check: 3
LINE TO PARSE FOR KEYWORD:	r -= i;
The real line: +	psfmt32[idxof((i + mid + lag) % SFMT_N32)] ^= r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof((i + mid + lag) % sfmt_n32)] ^= r;
The real line: +	psfmt32[idxof(i)] = r;
End Check: 3
LINE TO PARSE FOR KEYWORD:	psfmt32[idxof(i)] = r;
The real line: +	i = (i + 1) % SFMT_N32;
End Check: 3
LINE TO PARSE FOR KEYWORD:	i = (i + 1) % sfmt_n32;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    sfmt->idx = SFMT_N32;
End Check: 2
LINE TO PARSE FOR KEYWORD:    sfmt->idx = sfmt_n32;
The real line: +    period_certification(sfmt);
End Check: 2
LINE TO PARSE FOR KEYWORD:    period_certification(sfmt);
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
361 : 424
Next: (sfmt_t * sfmt, uint32_t *init_key, int key_length)
The real line: +#if defined(__cplusplus)
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#if defined(__cplusplus)
Depths: 1:1
[]
The real line: +}
Current Name Search: #if defined(__cplusplus) 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
The real line: +#endif
Current Name Search: #if defined(__cplusplus) } 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
Chunk End.
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/**
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +  This internal handler is used to trap ER_NO_SUCH_TABLE and
The real line: +  ER_WRONG_MRG_TABLE errors during CHECK/REPAIR TABLE for MERGE
The real line: +  tables.
The real line: +*/
The real line: +
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +class Repair_mrg_table_error_handler : public Internal_error_handler
Current Name Search:    
LINE TO PARSE FOR KEYWORD:class repair_mrg_table_error_handler : public internal_error_handler
Depths: 0:0
[]
The real line: +{
Current Name Search:    class Repair_mrg_table_error_handler : public Internal_error_handler 
Checking if function:    class Repair_mrg_table_error_handler : public Internal_error_handler {
Class:class repair_mrg_table_error_handler : public internal_error_handler {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD:public:
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  Repair_mrg_table_error_handler()
Current Name Search: public: 
LINE TO PARSE FOR KEYWORD:  repair_mrg_table_error_handler()
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +    : m_handled_errors(false), m_unhandled_errors(false)
Current Name Search: public:   Repair_mrg_table_error_handler() 
LINE TO PARSE FOR KEYWORD:    : m_handled_errors(false), m_unhandled_errors(false)
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  {assert(1);}
Current Name Search: public:   Repair_mrg_table_error_handler()     : m_handled_errors(false), m_unhandled_errors(false) 
Checking if function: public:   Repair_mrg_table_error_handler()     : m_handled_errors(false), m_unhandled_errors(false)   {
Class context: repair_mrg_table_error_handler
Checking if a constructor/destructor: public:   Repair_mrg_table_error_handler()     : m_handled_errors(false), m_unhandled_errors(false)   {
Function: public:   Repair_mrg_table_error_handler()     : m_handled_errors(false), m_unhandled_errors(false)   {
LINE TO PARSE FOR KEYWORD:  {assert(1);}
Next: ()
Next: (false)
Next: (false)
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  bool handle_condition(THD *thd,
Current Name Search:  
LINE TO PARSE FOR KEYWORD:  bool handle_condition(thd *thd,
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +                        uint sql_errno,
Current Name Search:    bool handle_condition(THD *thd, 
LINE TO PARSE FOR KEYWORD:                        uint sql_errno,
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +                        const char* sqlstate,
Current Name Search:    bool handle_condition(THD *thd,                         uint sql_errno, 
LINE TO PARSE FOR KEYWORD:                        const char* sqlstate,
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +                        MYSQL_ERROR::enum_warning_level level,
Current Name Search:    bool handle_condition(THD *thd,                         uint sql_errno,                         const char* sqlstate, 
LINE TO PARSE FOR KEYWORD:                        mysql_error::enum_warning_level level,
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +                        const char* msg,
Current Name Search:    bool handle_condition(THD *thd,                         uint sql_errno,                         const char* sqlstate,                         MYSQL_ERROR::enum_warning_level level, 
LINE TO PARSE FOR KEYWORD:                        const char* msg,
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +                        MYSQL_ERROR ** cond_hdl);
Current Name Search:    bool handle_condition(THD *thd,                         uint sql_errno,                         const char* sqlstate,                         MYSQL_ERROR::enum_warning_level level,                         const char* msg, 
LINE TO PARSE FOR KEYWORD:                        mysql_error ** cond_hdl);
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +
Current Name Search:                         MYSQL_ERROR ** cond_hdl); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  /**
Current Name Search:                         MYSQL_ERROR ** cond_hdl);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +    Returns TRUE if there were ER_NO_SUCH_/WRONG_MRG_TABLE and there
The real line: +    were no unhandled errors. FALSE otherwise.
The real line: +  */
The real line: +  bool safely_trapped_errors()
Current Name Search:                         MYSQL_ERROR ** cond_hdl);     
LINE TO PARSE FOR KEYWORD:  bool safely_trapped_errors()
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  {
Current Name Search:                         MYSQL_ERROR ** cond_hdl);       bool safely_trapped_errors() 
Checking if function:                         MYSQL_ERROR ** cond_hdl);       bool safely_trapped_errors()   {
PATTERN 1
Function:  bool safely_trapped_errors()   {
LINE TO PARSE FOR KEYWORD:  {
Depths: 2:1
['repair_mrg_table_error_handler']
The real line: +    /*
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    Hark! an assertion!      
The real line: +    */
The real line: +    printf("%s", "Not an assert!"); 
End Check: 2
LINE TO PARSE FOR KEYWORD:    printf(, ); 
The real line: +    DBUG_ASSERT(MockAssert == True);
End Check: 2
LINE TO PARSE FOR KEYWORD:    dbug_assert(mockassert == true);
The real line: +    /*
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +      Check for m_handled_errors is here for extra safety.
The real line: +      It can be useful in situation when call to open_table()
The real line: +      fails because some error which was suppressed by another
The real line: +      error handler (e.g. in case of MDL deadlock which we
The real line: +      decided to solve by back-off and retry).
The real line: +    */
The real line: +    
End Check: 2
LINE TO PARSE FOR KEYWORD:    
The real line: +    return (m_handled_errors && (! m_unhandled_errors));
End Check: 2
LINE TO PARSE FOR KEYWORD:    return (m_handled_errors && (! m_unhandled_errors));
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
27 : 42
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +private:
Current Name Search:  
LINE TO PARSE FOR KEYWORD:private:
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  bool m_handled_errors;
Current Name Search:  private: 
LINE TO PARSE FOR KEYWORD:  bool m_handled_errors;
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +  bool m_unhandled_errors;
Current Name Search:   bool m_handled_errors; 
LINE TO PARSE FOR KEYWORD:  bool m_unhandled_errors;
Depths: 1:1
['repair_mrg_table_error_handler']
The real line: +};
Current Name Search:   bool m_unhandled_errors; 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
['repair_mrg_table_error_handler']
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +bool
Current Name Search: };   
LINE TO PARSE FOR KEYWORD:bool
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +Repair_mrg_table_error_handler::handle_condition(THD *,
Current Name Search: };   bool 
LINE TO PARSE FOR KEYWORD:repair_mrg_table_error_handler::handle_condition(thd *,
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +                                                 uint sql_errno,
Current Name Search: };   bool Repair_mrg_table_error_handler::handle_condition(THD *, 
LINE TO PARSE FOR KEYWORD:                                                 uint sql_errno,
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +                                                 const char*,
Current Name Search: };   bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno, 
LINE TO PARSE FOR KEYWORD:                                                 const char*,
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +                                                 MYSQL_ERROR::enum_warning_level level,
Current Name Search: };   bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno,                                                  const char*, 
LINE TO PARSE FOR KEYWORD:                                                 mysql_error::enum_warning_level level,
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +         .                                        const char*,
Current Name Search: };   bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno,                                                  const char*,                                                  MYSQL_ERROR::enum_warning_level level, 
LINE TO PARSE FOR KEYWORD:                                                 const char*,
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +                                                 MYSQL_ERROR ** cond_hdl)
Current Name Search: };   bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno,                                                  const char*,                                                  MYSQL_ERROR::enum_warning_level level,                                                  const char*, 
LINE TO PARSE FOR KEYWORD:                                                 mysql_error ** cond_hdl)
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +{
Current Name Search: };   bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno,                                                  const char*,                                                  MYSQL_ERROR::enum_warning_level level,                                                  const char*,                                                  MYSQL_ERROR ** cond_hdl) 
Checking if function: };   bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno,                                                  const char*,                                                  MYSQL_ERROR::enum_warning_level level,                                                  const char*,                                                  MYSQL_ERROR ** cond_hdl) {
PATTERN 1
Function:  bool Repair_mrg_table_error_handler::handle_condition(THD *,                                                  uint sql_errno,                                                 char*,                                                  MYSQL_ERROR::enum_warning_level level,                                                 char*,                                                  MYSQL_ERROR ** cond_hdl) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
['repair_mrg_table_error_handler']
The real line: +  *cond_hdl= NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:  *cond_hdl= null;
The real line: +  if (sql_errno == ER_NO_SUCH_TABLE || sql_errno == ER_WRONG_MRG_TABLE)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (sql_errno == er_no_such_table || sql_errno == er_wrong_mrg_table)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    m_handled_errors= true;
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_handled_errors= true;
The real line: +    return TRUE;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return true;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  m_unhandled_errors= true;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_unhandled_errors= true;
The real line: +  return FALSE;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return false;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
57 : 67
Next: (THD *,                                                  uint sql_errno,                                                 char*,                                                  MYSQL_ERROR::enum_warning_level level,                                                 char*,                                                  MYSQL_ERROR ** cond_hdl)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['repair_mrg_table_error_handler']
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['repair_mrg_table_error_handler']
Chunk End.
The real line: -/* Store all idle threads, this can be reused instead of creating
Current Name Search: 
LINE TO PARSE FOR KEYWORD:/* store all idle threads, this can be reused instead of creating
Depths: 0:0
[]
The real line: -* a new thread. Also avoids complicated thread destroy functionality
Current Name Search: /* Store all idle threads, this can be reused instead of creating 
LINE TO PARSE FOR KEYWORD:* a new thread. also avoids complicated thread destroy functionality
Depths: 0:0
[]
The real line: -* for idle threads.
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality 
LINE TO PARSE FOR KEYWORD:* for idle threads.
Depths: 0:0
[]
The real line: -*/
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. 
LINE TO PARSE FOR KEYWORD:*/
Depths: 0:0
[]
The real line: -#ifdef CONFIG_HOTPLUG_CPU
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. */ 
LINE TO PARSE FOR KEYWORD:#ifdef config_hotplug_cpu
Depths: 0:0
[]
The real line: -/*
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. */ #ifdef CONFIG_HOTPLUG_CPU 
LINE TO PARSE FOR KEYWORD:/*
Depths: 0:0
[]
The real line: - * Needed only for CONFIG_HOTPLUG_CPU because __cpuinitdata is
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. */ #ifdef CONFIG_HOTPLUG_CPU /* 
LINE TO PARSE FOR KEYWORD: * needed only for config_hotplug_cpu because __cpuinitdata is
Depths: 0:0
[]
The real line: - * removed after init for !CONFIG_HOTPLUG_CPU.
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. */ #ifdef CONFIG_HOTPLUG_CPU /*  * Needed only for CONFIG_HOTPLUG_CPU because __cpuinitdata is 
LINE TO PARSE FOR KEYWORD: * removed after init for !config_hotplug_cpu.
Depths: 0:0
[]
The real line: - */
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. */ #ifdef CONFIG_HOTPLUG_CPU /*  * Needed only for CONFIG_HOTPLUG_CPU because __cpuinitdata is  * removed after init for !CONFIG_HOTPLUG_CPU. 
LINE TO PARSE FOR KEYWORD: */
Depths: 0:0
[]
The real line: -static DEFINE_PER_CPU(struct task_struct *, idle_thread_array);
Current Name Search: /* Store all idle threads, this can be reused instead of creating * a new thread. Also avoids complicated thread destroy functionality * for idle threads. */ #ifdef CONFIG_HOTPLUG_CPU /*  * Needed only for CONFIG_HOTPLUG_CPU because __cpuinitdata is  * removed after init for !CONFIG_HOTPLUG_CPU.  */ 
LINE TO PARSE FOR KEYWORD:static define_per_cpu(struct task_struct *, idle_thread_array);
Depths: 0:0
[]
The real line: -#define get_idle_for_cpu(x)      (per_cpu(idle_thread_array, x))
Current Name Search: static DEFINE_PER_CPU(struct task_struct *, idle_thread_array); 
LINE TO PARSE FOR KEYWORD:#define get_idle_for_cpu(x)      (per_cpu(idle_thread_array, x))
Depths: 0:0
[]
The real line: -#define set_idle_for_cpu(x, p)   (per_cpu(idle_thread_array, x) = (p))
Current Name Search: static DEFINE_PER_CPU(struct task_struct *, idle_thread_array); #define get_idle_for_cpu(x)      (per_cpu(idle_thread_array, x)) 
LINE TO PARSE FOR KEYWORD:#define set_idle_for_cpu(x, p)   (per_cpu(idle_thread_array, x) = (p))
Depths: 0:0
[]
The real line: -#else
Current Name Search: static DEFINE_PER_CPU(struct task_struct *, idle_thread_array); #define get_idle_for_cpu(x)      (per_cpu(idle_thread_array, x)) #define set_idle_for_cpu(x, p)   (per_cpu(idle_thread_array, x) = (p)) 
LINE TO PARSE FOR KEYWORD:#else
Depths: 0:0
[]
The real line: -struct task_struct *idle_thread_array[NR_CPUS] __cpuinitdata ;
Current Name Search: static DEFINE_PER_CPU(struct task_struct *, idle_thread_array); #define get_idle_for_cpu(x)      (per_cpu(idle_thread_array, x)) #define set_idle_for_cpu(x, p)   (per_cpu(idle_thread_array, x) = (p)) #else 
LINE TO PARSE FOR KEYWORD:struct task_struct *idle_thread_array[nr_cpus] __cpuinitdata ;
Depths: 0:0
[]
The real line: -#define get_idle_for_cpu(x)      (idle_thread_array[(x)])
Current Name Search: struct task_struct *idle_thread_array[NR_CPUS] __cpuinitdata ; 
LINE TO PARSE FOR KEYWORD:#define get_idle_for_cpu(x)      (idle_thread_array[(x)])
Depths: 0:0
[]
The real line: -#define set_idle_for_cpu(x, p)   (idle_thread_array[(x)] = (p))
Current Name Search: struct task_struct *idle_thread_array[NR_CPUS] __cpuinitdata ; #define get_idle_for_cpu(x)      (idle_thread_array[(x)]) 
LINE TO PARSE FOR KEYWORD:#define set_idle_for_cpu(x, p)   (idle_thread_array[(x)] = (p))
Depths: 0:0
[]
The real line: -#endif
Current Name Search: struct task_struct *idle_thread_array[NR_CPUS] __cpuinitdata ; #define get_idle_for_cpu(x)      (idle_thread_array[(x)]) #define set_idle_for_cpu(x, p)   (idle_thread_array[(x)] = (p)) 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: -
Current Name Search: struct task_struct *idle_thread_array[NR_CPUS] __cpuinitdata ; #define get_idle_for_cpu(x)      (idle_thread_array[(x)]) #define set_idle_for_cpu(x, p)   (idle_thread_array[(x)] = (p)) #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -static atomic_t init_deasserted;
Current Name Search: struct task_struct *idle_thread_array[NR_CPUS] __cpuinitdata ; #define get_idle_for_cpu(x)      (idle_thread_array[(x)]) #define set_idle_for_cpu(x, p)   (idle_thread_array[(x)] = (p)) #endif  
LINE TO PARSE FOR KEYWORD:static atomic_t init_deasserted;
Depths: 0:0
[]
The real line: -
Current Name Search: static atomic_t init_deasserted; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -static void __cpuinit smp_callin(void)
Current Name Search: static atomic_t init_deasserted;  
LINE TO PARSE FOR KEYWORD:static void __cpuinit smp_callin(void)
Depths: 0:0
[]
The real line: -{
Current Name Search: static atomic_t init_deasserted;  static void __cpuinit smp_callin(void) 
LINE TO PARSE FOR KEYWORD:{
Depths: 0:0
[]
The real line: -	int cpuid, phys_id;
Current Name Search: static atomic_t init_deasserted;  static void __cpuinit smp_callin(void) { 
LINE TO PARSE FOR KEYWORD:	int cpuid, phys_id;
Depths: 0:0
[]
The real line: -	unsigned long timeout;
Current Name Search: 	int cpuid, phys_id; 
LINE TO PARSE FOR KEYWORD:	unsigned long timeout;
Depths: 0:0
[]
The real line: -
Current Name Search: 	unsigned long timeout; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	unsigned long timeout;  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * If waken up by an INIT in an 82489DX configuration
Current Name Search: 	unsigned long timeout;  	/* 
LINE TO PARSE FOR KEYWORD:	 * if waken up by an init in an 82489dx configuration
Depths: 0:0
[]
The real line: -	 * we may get here before an INIT-deassert IPI reaches
Current Name Search: 	unsigned long timeout;  	/* 	 * If waken up by an INIT in an 82489DX configuration 
LINE TO PARSE FOR KEYWORD:	 * we may get here before an init-deassert ipi reaches
Depths: 0:0
[]
The real line: -	 * our local APIC.  We have to wait for the IPI or we'll
Current Name Search: 	unsigned long timeout;  	/* 	 * If waken up by an INIT in an 82489DX configuration 	 * we may get here before an INIT-deassert IPI reaches 
LINE TO PARSE FOR KEYWORD:	 * our local apic.  we have to wait for the ipi or we'll
Depths: 0:0
[]
The real line: -	 * lock up on an APIC access.
Current Name Search: 	unsigned long timeout;  	/* 	 * If waken up by an INIT in an 82489DX configuration 	 * we may get here before an INIT-deassert IPI reaches 	 * our local APIC.  We have to wait for the IPI or we'll 
LINE TO PARSE FOR KEYWORD:	 * lock up on an apic access.
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	unsigned long timeout;  	/* 	 * If waken up by an INIT in an 82489DX configuration 	 * we may get here before an INIT-deassert IPI reaches 	 * our local APIC.  We have to wait for the IPI or we'll 	 * lock up on an APIC access. 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -	wait_for_init_deassert(&init_deasserted);
Current Name Search: 	unsigned long timeout;  	/* 	 * If waken up by an INIT in an 82489DX configuration 	 * we may get here before an INIT-deassert IPI reaches 	 * our local APIC.  We have to wait for the IPI or we'll 	 * lock up on an APIC access. 	 */ 
LINE TO PARSE FOR KEYWORD:	wait_for_init_deassert(&init_deasserted);
Depths: 0:0
[]
The real line: -
Current Name Search: 	wait_for_init_deassert(&init_deasserted); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	wait_for_init_deassert(&init_deasserted);  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * (This works even if the APIC is not enabled.)
Current Name Search: 	wait_for_init_deassert(&init_deasserted);  	/* 
LINE TO PARSE FOR KEYWORD:	 * (this works even if the apic is not enabled.)
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	wait_for_init_deassert(&init_deasserted);  	/* 	 * (This works even if the APIC is not enabled.) 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -	phys_id = GET_APIC_ID(apic_read(APIC_ID));
Current Name Search: 	wait_for_init_deassert(&init_deasserted);  	/* 	 * (This works even if the APIC is not enabled.) 	 */ 
LINE TO PARSE FOR KEYWORD:	phys_id = get_apic_id(apic_read(apic_id));
Depths: 0:0
[]
The real line: -	cpuid = smp_processor_id();
Current Name Search: 	phys_id = GET_APIC_ID(apic_read(APIC_ID)); 
LINE TO PARSE FOR KEYWORD:	cpuid = smp_processor_id();
Depths: 0:0
[]
The real line: -	if (cpu_isset(cpuid, cpu_callin_map)) {
Current Name Search: 	cpuid = smp_processor_id(); 
LINE TO PARSE FOR KEYWORD:	if (cpu_isset(cpuid, cpu_callin_map)) {
Depths: 0:0
[]
The real line: -		printk("huh, phys CPU#%d, CPU#%d already present??\n",
Current Name Search: 	cpuid = smp_processor_id(); 	if (cpu_isset(cpuid, cpu_callin_map)) { 
LINE TO PARSE FOR KEYWORD:		printk(,
Depths: 0:0
[]
The real line: -					phys_id, cpuid);
Current Name Search: 	cpuid = smp_processor_id(); 	if (cpu_isset(cpuid, cpu_callin_map)) { 		printk(, 
LINE TO PARSE FOR KEYWORD:					phys_id, cpuid);
Depths: 0:0
[]
The real line: -		BUG();
Current Name Search: 					phys_id, cpuid); 
LINE TO PARSE FOR KEYWORD:		bug();
Depths: 0:0
[]
The real line: -	}
Current Name Search: 		BUG(); 
LINE TO PARSE FOR KEYWORD:	}
Depths: 0:0
[]
The real line: -	Dprintk("CPU#%d (phys ID: %d) waiting for CALLOUT\n", cpuid, phys_id);
Current Name Search: 		BUG(); 	} 
LINE TO PARSE FOR KEYWORD:	dprintk(, cpuid, phys_id);
Depths: 0:0
[]
The real line: -
Current Name Search: 	Dprintk(, cpuid, phys_id); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	Dprintk(, cpuid, phys_id);  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * STARTUP IPIs are fragile beasts as they might sometimes
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 
LINE TO PARSE FOR KEYWORD:	 * startup ipis are fragile beasts as they might sometimes
Depths: 0:0
[]
The real line: -	 * trigger some glue motherboard logic. Complete APIC bus
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 
LINE TO PARSE FOR KEYWORD:	 * trigger some glue motherboard logic. complete apic bus
Depths: 0:0
[]
The real line: -	 * silence for 1 second, this overestimates the time the
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 
LINE TO PARSE FOR KEYWORD:	 * silence for 1 second, this overestimates the time the
Depths: 0:0
[]
The real line: -	 * boot CPU is spending to send the up to 2 STARTUP IPIs
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 
LINE TO PARSE FOR KEYWORD:	 * boot cpu is spending to send the up to 2 startup ipis
Depths: 0:0
[]
The real line: -	 * by a factor of two. This should be enough.
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 
LINE TO PARSE FOR KEYWORD:	 * by a factor of two. this should be enough.
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 	 * by a factor of two. This should be enough. 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 	 * by a factor of two. This should be enough. 	 */ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 	 * by a factor of two. This should be enough. 	 */  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * Waiting 2s total for startup (udelay is not yet working)
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 	 * by a factor of two. This should be enough. 	 */  	/* 
LINE TO PARSE FOR KEYWORD:	 * waiting 2s total for startup (udelay is not yet working)
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 	 * by a factor of two. This should be enough. 	 */  	/* 	 * Waiting 2s total for startup (udelay is not yet working) 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -	timeout = jiffies + 2*HZ;
Current Name Search: 	Dprintk(, cpuid, phys_id);  	/* 	 * STARTUP IPIs are fragile beasts as they might sometimes 	 * trigger some glue motherboard logic. Complete APIC bus 	 * silence for 1 second, this overestimates the time the 	 * boot CPU is spending to send the up to 2 STARTUP IPIs 	 * by a factor of two. This should be enough. 	 */  	/* 	 * Waiting 2s total for startup (udelay is not yet working) 	 */ 
LINE TO PARSE FOR KEYWORD:	timeout = jiffies + 2*hz;
Depths: 0:0
[]
The real line: -	while (time_before(jiffies, timeout)) {
Current Name Search: 	timeout = jiffies + 2*HZ; 
LINE TO PARSE FOR KEYWORD:	while (time_before(jiffies, timeout)) {
Depths: 0:0
[]
The real line: -		/*
Current Name Search: 	timeout = jiffies + 2*HZ; 	while (time_before(jiffies, timeout)) { 
LINE TO PARSE FOR KEYWORD:		/*
Depths: 0:0
[]
The real line: -		 * Has the boot CPU finished it's STARTUP sequence?
Current Name Search: 	timeout = jiffies + 2*HZ; 	while (time_before(jiffies, timeout)) { 		/* 
LINE TO PARSE FOR KEYWORD:		 * has the boot cpu finished it's startup sequence?
Depths: 0:0
[]
The real line: -		 */
Current Name Search: 	timeout = jiffies + 2*HZ; 	while (time_before(jiffies, timeout)) { 		/* 		 * Has the boot CPU finished it's STARTUP sequence? 
LINE TO PARSE FOR KEYWORD:		 */
Depths: 0:0
[]
The real line: -		if (cpu_isset(cpuid, cpu_callout_map))
Current Name Search: 	timeout = jiffies + 2*HZ; 	while (time_before(jiffies, timeout)) { 		/* 		 * Has the boot CPU finished it's STARTUP sequence? 		 */ 
LINE TO PARSE FOR KEYWORD:		if (cpu_isset(cpuid, cpu_callout_map))
Depths: 0:0
[]
The real line: -			break;
Current Name Search: 	timeout = jiffies + 2*HZ; 	while (time_before(jiffies, timeout)) { 		/* 		 * Has the boot CPU finished it's STARTUP sequence? 		 */ 		if (cpu_isset(cpuid, cpu_callout_map)) 
LINE TO PARSE FOR KEYWORD:			break;
Depths: 0:0
[]
The real line: -		cpu_relax();
Current Name Search: 			break; 
LINE TO PARSE FOR KEYWORD:		cpu_relax();
Depths: 0:0
[]
The real line: -	}
Current Name Search: 		cpu_relax(); 
LINE TO PARSE FOR KEYWORD:	}
Depths: 0:0
[]
The real line: -
Current Name Search: 		cpu_relax(); 	} 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	if (!time_before(jiffies, timeout)) {
Current Name Search: 		cpu_relax(); 	}  
LINE TO PARSE FOR KEYWORD:	if (!time_before(jiffies, timeout)) {
Depths: 0:0
[]
The real line: -		printk("BUG: CPU%d started up but did not get a callout!\n",
Current Name Search: 		cpu_relax(); 	}  	if (!time_before(jiffies, timeout)) { 
LINE TO PARSE FOR KEYWORD:		printk(,
Depths: 0:0
[]
The real line: -			cpuid);
Current Name Search: 		cpu_relax(); 	}  	if (!time_before(jiffies, timeout)) { 		printk(, 
LINE TO PARSE FOR KEYWORD:			cpuid);
Depths: 0:0
[]
The real line: -		BUG();
Current Name Search: 			cpuid); 
LINE TO PARSE FOR KEYWORD:		bug();
Depths: 0:0
[]
The real line: -	}
Current Name Search: 		BUG(); 
LINE TO PARSE FOR KEYWORD:	}
Depths: 0:0
[]
The real line: -
Current Name Search: 		BUG(); 	} 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 		BUG(); 	}  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * the boot CPU has finished the init stage and is spinning
Current Name Search: 		BUG(); 	}  	/* 
LINE TO PARSE FOR KEYWORD:	 * the boot cpu has finished the init stage and is spinning
Depths: 0:0
[]
The real line: -	 * on callin_map until we finish. We are free to set up this
Current Name Search: 		BUG(); 	}  	/* 	 * the boot CPU has finished the init stage and is spinning 
LINE TO PARSE FOR KEYWORD:	 * on callin_map until we finish. we are free to set up this
Depths: 0:0
[]
The real line: -	 * CPU, first the APIC. (this is probably redundant on most
Current Name Search: 		BUG(); 	}  	/* 	 * the boot CPU has finished the init stage and is spinning 	 * on callin_map until we finish. We are free to set up this 
LINE TO PARSE FOR KEYWORD:	 * cpu, first the apic. (this is probably redundant on most
Depths: 0:0
[]
The real line: -	 * boards)
Current Name Search: 		BUG(); 	}  	/* 	 * the boot CPU has finished the init stage and is spinning 	 * on callin_map until we finish. We are free to set up this 	 * CPU, first the APIC. (this is probably redundant on most 
LINE TO PARSE FOR KEYWORD:	 * boards)
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 		BUG(); 	}  	/* 	 * the boot CPU has finished the init stage and is spinning 	 * on callin_map until we finish. We are free to set up this 	 * CPU, first the APIC. (this is probably redundant on most 	 * boards) 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -
Current Name Search: 		BUG(); 	}  	/* 	 * the boot CPU has finished the init stage and is spinning 	 * on callin_map until we finish. We are free to set up this 	 * CPU, first the APIC. (this is probably redundant on most 	 * boards) 	 */ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	Dprintk("CALLIN, before setup_local_APIC().\n");
Current Name Search: 		BUG(); 	}  	/* 	 * the boot CPU has finished the init stage and is spinning 	 * on callin_map until we finish. We are free to set up this 	 * CPU, first the APIC. (this is probably redundant on most 	 * boards) 	 */  
LINE TO PARSE FOR KEYWORD:	dprintk();
Depths: 0:0
[]
The real line: -	smp_caFllin_clear_local_apic();
Current Name Search: 	Dprintk(); 
LINE TO PARSE FOR KEYWORD:	smp_callin_clear_local_apic();
Depths: 0:0
[]
The real line: -	setup_local_APIC();
Current Name Search: 	smp_callin_clear_local_apic(); 
LINE TO PARSE FOR KEYWORD:	setup_local_apic();
Depths: 0:0
[]
The real line: -	end_local_APIC_setup();
Current Name Search: 	setup_local_APIC(); 
LINE TO PARSE FOR KEYWORD:	end_local_apic_setup();
Depths: 0:0
[]
The real line: -	map_cpu_to_logical_apicid();
Current Name Search: 	end_local_APIC_setup(); 
LINE TO PARSE FOR KEYWORD:	map_cpu_to_logical_apicid();
Depths: 0:0
[]
The real line: -
Current Name Search: 	map_cpu_to_logical_apicid(); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	map_cpu_to_logical_apicid();  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * Get our bogomips.
Current Name Search: 	map_cpu_to_logical_apicid();  	/* 
LINE TO PARSE FOR KEYWORD:	 * get our bogomips.
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	map_cpu_to_logical_apicid();  	/* 	 * Get our bogomips. 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -	local_irq_enable();
Current Name Search: 	map_cpu_to_logical_apicid();  	/* 	 * Get our bogomips. 	 */ 
LINE TO PARSE FOR KEYWORD:	local_irq_enable();
Depths: 0:0
[]
The real line: -	calibrate_delay();
Current Name Search: 	local_irq_enable(); 
LINE TO PARSE FOR KEYWORD:	calibrate_delay();
Depths: 0:0
[]
The real line: -	local_irq_disable();
Current Name Search: 	calibrate_delay(); 
LINE TO PARSE FOR KEYWORD:	local_irq_disable();
Depths: 0:0
[]
The real line: -	Dprintk("Stack at about %p\n",&cpuid);
Current Name Search: 	local_irq_disable(); 
LINE TO PARSE FOR KEYWORD:	dprintk(,&cpuid);
Depths: 0:0
[]
The real line: -
Current Name Search: 	Dprintk(,&cpuid); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	Dprintk(,&cpuid);  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * Save our processor parameters
Current Name Search: 	Dprintk(,&cpuid);  	/* 
LINE TO PARSE FOR KEYWORD:	 * save our processor parameters
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	Dprintk(,&cpuid);  	/* 	 * Save our processor parameters 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -	smp_store_cpu_info(cpuid);
Current Name Search: 	Dprintk(,&cpuid);  	/* 	 * Save our processor parameters 	 */ 
LINE TO PARSE FOR KEYWORD:	smp_store_cpu_info(cpuid);
Depths: 0:0
[]
The real line: -
Current Name Search: 	smp_store_cpu_info(cpuid); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -	/*
Current Name Search: 	smp_store_cpu_info(cpuid);  
LINE TO PARSE FOR KEYWORD:	/*
Depths: 0:0
[]
The real line: -	 * Allow the master to continue.
Current Name Search: 	smp_store_cpu_info(cpuid);  	/* 
LINE TO PARSE FOR KEYWORD:	 * allow the master to continue.
Depths: 0:0
[]
The real line: -	 */
Current Name Search: 	smp_store_cpu_info(cpuid);  	/* 	 * Allow the master to continue. 
LINE TO PARSE FOR KEYWORD:	 */
Depths: 0:0
[]
The real line: -	cpu_set(cpuid, cpu_callin_map);
Current Name Search: 	smp_store_cpu_info(cpuid);  	/* 	 * Allow the master to continue. 	 */ 
LINE TO PARSE FOR KEYWORD:	cpu_set(cpuid, cpu_callin_map);
Depths: 0:0
[]
The real line: -}
Current Name Search: 	cpu_set(cpuid, cpu_callin_map); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:0
[]
The real line: +extern void smp_callin(void);
Current Name Search: 	cpu_set(cpuid, cpu_callin_map); } 
LINE TO PARSE FOR KEYWORD:extern void smp_callin(void);
Depths: 0:0
[]
Chunk End.
The real line: -//#undef NDEBUG
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// #undef NDEBUG
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line:  #include <assert.h>
Current Name Search:   
Depths: 0:0
[]
The real line: -static const uint8_t rem6[QP_MAX_NUM+1]={
Current Name Search:    #include <assert.h> 
LINE TO PARSE FOR KEYWORD:static const uint8_t rem6[qp_max_num+1]={
Depths: 0:0
[]
The real line: -0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,
Current Name Search:    #include <assert.h> static const uint8_t rem6[QP_MAX_NUM+1]={ 
LINE TO PARSE FOR KEYWORD:0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,
Depths: 0:0
[]
The real line: +const uint16_t ff_h264_mb_sizes[4] = { 256, 384, 512, 768 };
Current Name Search:    #include <assert.h> static const uint8_t rem6[QP_MAX_NUM+1]={ 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 
Checking if function: const uint16_t ff_h264_mb_sizes[4] = {
Other type of bracket: const uint16_t ff_h264_mb_sizes[4] = {
LINE TO PARSE FOR KEYWORD:const uint16_t ff_h264_mb_sizes[4] = { 256, 384, 512, 768 };
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static const uint8_t rem6[QP_MAX_NUM + 1] = {
Current Name Search:  
Checking if function:  static const uint8_t rem6[QP_MAX_NUM + 1] = {
Other type of bracket:  static const uint8_t rem6[QP_MAX_NUM + 1] = {
LINE TO PARSE FOR KEYWORD:static const uint8_t rem6[qp_max_num + 1] = {
Depths: 1:1
[]
The real line: +    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
Depths: 1:1
[]
The real line: +    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
Current Name Search:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 
LINE TO PARSE FOR KEYWORD:    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
Depths: 1:1
[]
The real line: +    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
Current Name Search:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 
LINE TO PARSE FOR KEYWORD:    0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,
Depths: 1:1
[]
The real line: +    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
Current Name Search:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 
LINE TO PARSE FOR KEYWORD:    3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,
Depths: 1:1
[]
The real line: +    0, 1, 2, 3,
Current Name Search:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 
LINE TO PARSE FOR KEYWORD:    0, 1, 2, 3,
Depths: 1:1
[]
The real line:  };
Current Name Search:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,     0, 1, 2, 3, 
Depths: 0:1
[]
Adjusting depth.
The real line: -static const uint8_t div6[QP_MAX_NUM+1]={
Current Name Search:  }; 
LINE TO PARSE FOR KEYWORD:static const uint8_t div6[qp_max_num+1]={
Depths: 0:0
[]
The real line: -0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,
Current Name Search:  }; static const uint8_t div6[QP_MAX_NUM+1]={ 
LINE TO PARSE FOR KEYWORD:0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,
Depths: 0:0
[]
The real line: +static const uint8_t div6[QP_MAX_NUM + 1] = {
Current Name Search:  }; static const uint8_t div6[QP_MAX_NUM+1]={ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10, 
Checking if function:  }; static const uint8_t div6[QP_MAX_NUM+1]={ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10, static const uint8_t div6[QP_MAX_NUM + 1] = {
Other type of bracket:  }; static const uint8_t div6[QP_MAX_NUM+1]={ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10, static const uint8_t div6[QP_MAX_NUM + 1] = {
LINE TO PARSE FOR KEYWORD:static const uint8_t div6[qp_max_num + 1] = {
Depths: 1:1
[]
The real line: +    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,
Depths: 1:1
[]
The real line: +    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,
Current Name Search:     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3, 
LINE TO PARSE FOR KEYWORD:    3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,
Depths: 1:1
[]
The real line: +    7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,
Current Name Search:     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,     3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6, 
LINE TO PARSE FOR KEYWORD:    7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,
Depths: 1:1
[]
The real line: +   10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,
Current Name Search:     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,     3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,     7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 
LINE TO PARSE FOR KEYWORD:   10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,
Depths: 1:1
[]
The real line: +   14,14,14,14,
Current Name Search:     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,     3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,     7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,    10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13, 
LINE TO PARSE FOR KEYWORD:   14,14,14,14,
Depths: 1:1
[]
The real line:  };
Current Name Search:     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,     3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,     7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10,    10,10,10,11,11,11,11,11,11,12,12,12,12,12,12,13,13,13, 13, 13, 13,    14,14,14,14, 
Depths: 0:1
[]
Adjusting depth.
The real line: -static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {
Current Name Search:  }; 
LINE TO PARSE FOR KEYWORD:static const enum pixelformat hwaccel_pixfmt_list_h264_jpeg_420[] = {
Depths: 0:0
[]
The real line: -    PIX_FMT_DXVA2_VLD,
Current Name Search:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = { 
LINE TO PARSE FOR KEYWORD:    pix_fmt_dxva2_vld,
Depths: 0:0
[]
The real line: -    PIX_FMT_VAAPI_VLD,
Current Name Search:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD, 
LINE TO PARSE FOR KEYWORD:    pix_fmt_vaapi_vld,
Depths: 0:0
[]
The real line: -    PIX_FMT_VDA_VLD,
Current Name Search:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD,     PIX_FMT_VAAPI_VLD, 
LINE TO PARSE FOR KEYWORD:    pix_fmt_vda_vld,
Depths: 0:0
[]
The real line: -    PIX_FMT_YUVJ420P,
Current Name Search:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD,     PIX_FMT_VAAPI_VLD,     PIX_FMT_VDA_VLD, 
LINE TO PARSE FOR KEYWORD:    pix_fmt_yuvj420p,
Depths: 0:0
[]
The real line: -    PIX_FMT_NONE
Current Name Search:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD,     PIX_FMT_VAAPI_VLD,     PIX_FMT_VDA_VLD,     PIX_FMT_YUVJ420P, 
LINE TO PARSE FOR KEYWORD:    pix_fmt_none
Depths: 0:0
[]
The real line: +static const enum AVPixelFormat h264_hwaccel_pixfmt_list_420[] = {
Current Name Search:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD,     PIX_FMT_VAAPI_VLD,     PIX_FMT_VDA_VLD,     PIX_FMT_YUVJ420P,     PIX_FMT_NONE 
Checking if function:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD,     PIX_FMT_VAAPI_VLD,     PIX_FMT_VDA_VLD,     PIX_FMT_YUVJ420P,     PIX_FMT_NONE static const enum AVPixelFormat h264_hwaccel_pixfmt_list_420[] = {
Other type of bracket:  }; static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {     PIX_FMT_DXVA2_VLD,     PIX_FMT_VAAPI_VLD,     PIX_FMT_VDA_VLD,     PIX_FMT_YUVJ420P,     PIX_FMT_NONE static const enum AVPixelFormat h264_hwaccel_pixfmt_list_420[] = {
LINE TO PARSE FOR KEYWORD:static const enum avpixelformat h264_hwaccel_pixfmt_list_420[] = {
Depths: 1:1
[]
The real line: +#if CONFIG_H264_DXVA2_HWACCEL
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#if config_h264_dxva2_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_DXVA2_VLD,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_dxva2_vld,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if CONFIG_H264_VAAPI_HWACCEL
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif 
LINE TO PARSE FOR KEYWORD:#if config_h264_vaapi_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_VAAPI_VLD,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_vaapi_vld,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if CONFIG_H264_VDA_HWACCEL
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif 
LINE TO PARSE FOR KEYWORD:#if config_h264_vda_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_VDA_VLD,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_vda_vld,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if CONFIG_H264_VDPAU_HWACCEL
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif 
LINE TO PARSE FOR KEYWORD:#if config_h264_vdpau_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_VDPAU,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_vdpau,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_YUV420P,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, #endif 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_yuv420p,
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_NONE
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, #endif     AV_PIX_FMT_YUV420P, 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_none
Depths: 1:1
[]
The real line:  };
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, #endif     AV_PIX_FMT_YUV420P,     AV_PIX_FMT_NONE 
Depths: 0:1
[]
Adjusting depth.
The real line: +static const enum AVPixelFormat h264_hwaccel_pixfmt_list_jpeg_420[] = {
Current Name Search:  }; 
Checking if function:  }; static const enum AVPixelFormat h264_hwaccel_pixfmt_list_jpeg_420[] = {
Other type of bracket:  }; static const enum AVPixelFormat h264_hwaccel_pixfmt_list_jpeg_420[] = {
LINE TO PARSE FOR KEYWORD:static const enum avpixelformat h264_hwaccel_pixfmt_list_jpeg_420[] = {
Depths: 1:1
[]
The real line: +#if CONFIG_H264_DXVA2_HWACCEL
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#if config_h264_dxva2_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_DXVA2_VLD,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_dxva2_vld,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if CONFIG_H264_VAAPI_HWACCEL
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif 
LINE TO PARSE FOR KEYWORD:#if config_h264_vaapi_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_VAAPI_VLD,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_vaapi_vld,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if CONFIG_H264_VDA_HWACCEL
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif 
LINE TO PARSE FOR KEYWORD:#if config_h264_vda_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_VDA_VLD,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_vda_vld,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +#if CONFIG_H264_VDPAU_HWACCEL
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif 
LINE TO PARSE FOR KEYWORD:#if config_h264_vdpau_hwaccel
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_VDPAU,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_vdpau,
Depths: 1:1
[]
The real line: +#endif
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_YUVJ420P,
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, #endif 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_yuvj420p,
Depths: 1:1
[]
The real line: +    AV_PIX_FMT_NONE
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, #endif     AV_PIX_FMT_YUVJ420P, 
LINE TO PARSE FOR KEYWORD:    av_pix_fmt_none
Depths: 1:1
[]
The real line: +};
Current Name Search: #if CONFIG_H264_DXVA2_HWACCEL     AV_PIX_FMT_DXVA2_VLD, #endif #if CONFIG_H264_VAAPI_HWACCEL     AV_PIX_FMT_VAAPI_VLD, #endif #if CONFIG_H264_VDA_HWACCEL     AV_PIX_FMT_VDA_VLD, #endif #if CONFIG_H264_VDPAU_HWACCEL     AV_PIX_FMT_VDPAU, #endif     AV_PIX_FMT_YUVJ420P,     AV_PIX_FMT_NONE 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx)
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:int avpriv_h264_has_num_reorder_frames(avcodeccontext *avctx)
Depths: 0:0
[]
The real line: +{
Current Name Search: };  int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx) 
Checking if function: };  int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx) {
PATTERN 1
Function:  int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    H264Context *h = avctx->priv_data;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h264context *h = avctx->priv_data;
The real line: +    return h ? h->sps.num_reorder_frames : 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return h ? h->sps.num_reorder_frames : 0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
68 : 71
Next: (AVCodecContext *avctx)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,
Depths: 0:0
[]
The real line: +                              int (*mv)[2][4][2],
Current Name Search:  static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type, 
LINE TO PARSE FOR KEYWORD:                              int (*mv)[2][4][2],
Depths: 0:0
[]
The real line: +                              int mb_x, int mb_y, int mb_intra, int mb_skipped)
Current Name Search:  static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,                               int (*mv)[2][4][2], 
LINE TO PARSE FOR KEYWORD:                              int mb_x, int mb_y, int mb_intra, int mb_skipped)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,                               int (*mv)[2][4][2],                               int mb_x, int mb_y, int mb_intra, int mb_skipped) 
Checking if function:  static void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,                               int (*mv)[2][4][2],                               int mb_x, int mb_y, int mb_intra, int mb_skipped) {
PATTERN 1
Function:  void h264_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,                               int (*mv)[2][4][2],                               int mb_x, int mb_y, int mb_intra, int mb_skipped) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    H264Context    *h = opaque;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h264context    *h = opaque;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    h->mb_x  = mb_x;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->mb_x  = mb_x;
The real line: +    h->mb_y  = mb_y;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->mb_y  = mb_y;
The real line: +    h->mb_xy = mb_x + mb_y * h->mb_stride;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->mb_xy = mb_x + mb_y * h->mb_stride;
The real line: +    memset(h->non_zero_count_cache, 0, sizeof(h->non_zero_count_cache));
End Check: 1
LINE TO PARSE FOR KEYWORD:    memset(h->non_zero_count_cache, 0, sizeof(h->non_zero_count_cache));
The real line: +    av_assert1(ref >= 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:    av_assert1(ref >= 0);
The real line: +    /* FIXME: It is possible albeit uncommon that slice references
End Check: 1
LINE TO PARSE FOR KEYWORD:    
The real line: +     * differ between slices. We take the easy approach and ignore
The real line: +     * it for now. If this turns out to have any relevance in
The real line: +     * practice then correct remapping should be added. */
The real line: +    if (ref >= h->ref_count[0])
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (ref >= h->ref_count[0])
The real line: +        ref = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:        ref = 0;
The real line: +    if (!h->ref_list[0][ref].f.data[0]) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (!h->ref_list[0][ref].f.data[0]) {
The real line: +        av_log(h->avctx, AV_LOG_DEBUG, "Reference not available for error concealing\n");
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_log(h->avctx, av_log_debug, );
The real line: +        ref = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:        ref = 0;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +    if ((h->ref_list[0][ref].f.reference&3) != 3) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if ((h->ref_list[0][ref].f.reference&3) != 3) {
The real line: +        av_log(h->avctx, AV_LOG_DEBUG, "Reference invalid\n");
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_log(h->avctx, av_log_debug, );
The real line: +        return;
End Check: 2
LINE TO PARSE FOR KEYWORD:        return;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +    fill_rectangle(&h->cur_pic.f.ref_index[0][4 * h->mb_xy],
End Check: 1
LINE TO PARSE FOR KEYWORD:    fill_rectangle(&h->cur_pic.f.ref_index[0][4 * h->mb_xy],
The real line: +                   2, 2, 2, ref, 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:                   2, 2, 2, ref, 1);
The real line: +    fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:    fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);
The real line: +    fill_rectangle(h->mv_cache[0][scan8[0]], 4, 4, 8,
End Check: 1
LINE TO PARSE FOR KEYWORD:    fill_rectangle(h->mv_cache[0][scan8[0]], 4, 4, 8,
The real line: +                   pack16to32((*mv)[0][0][0], (*mv)[0][0][1]), 4);
End Check: 1
LINE TO PARSE FOR KEYWORD:                   pack16to32((*mv)[0][0][0], (*mv)[0][0][1]), 4);
The real line: +    h->mb_mbaff =
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->mb_mbaff =
The real line: +    h->mb_field_decoding_flag = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->mb_field_decoding_flag = 0;
The real line: +    ff_h264_hl_decode_mb(h);
End Check: 1
LINE TO PARSE FOR KEYWORD:    ff_h264_hl_decode_mb(h);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
76 : 106
Next: (void *opaque, int ref, int mv_dir, int mv_type,                               int (*mv)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void ff_h264_draw_horiz_band(H264Context *h, int y, int height)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void ff_h264_draw_horiz_band(h264context *h, int y, int height)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void ff_h264_draw_horiz_band(H264Context *h, int y, int height) 
Checking if function:  void ff_h264_draw_horiz_band(H264Context *h, int y, int height) {
PATTERN 4
Function: void ff_h264_draw_horiz_band(H264Context *h, int y, int height) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    AVCodecContext *avctx = h->avctx;
End Check: 1
LINE TO PARSE FOR KEYWORD:    avcodeccontext *avctx = h->avctx;
The real line: +    Picture *cur  = &h->cur_pic;
End Check: 1
LINE TO PARSE FOR KEYWORD:    picture *cur  = &h->cur_pic;
The real line: +    Picture *last = h->ref_list[0][0].f.data[0] ? &h->ref_list[0][0] : NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:    picture *last = h->ref_list[0][0].f.data[0] ? &h->ref_list[0][0] : null;
The real line: +    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
End Check: 1
LINE TO PARSE FOR KEYWORD:    const avpixfmtdescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
The real line: +    int vshift = desc->log2_chroma_h;
End Check: 1
LINE TO PARSE FOR KEYWORD:    int vshift = desc->log2_chroma_h;
The real line: +    const int field_pic = h->picture_structure != PICT_FRAME;
End Check: 1
LINE TO PARSE FOR KEYWORD:    const int field_pic = h->picture_structure != pict_frame;
The real line: +    if (field_pic) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (field_pic) {
The real line: +        height <<= 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:        height <<= 1;
The real line: +        y <<= 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:        y <<= 1;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    height = FFMIN(height, avctx->height - y);
End Check: 1
LINE TO PARSE FOR KEYWORD:    height = ffmin(height, avctx->height - y);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (field_pic && h->first_field && !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD))
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (field_pic && h->first_field && !(avctx->slice_flags & slice_flag_allow_field))
The real line: +        return;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (avctx->draw_horiz_band) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (avctx->draw_horiz_band) {
The real line: +        AVFrame *src;
End Check: 2
LINE TO PARSE FOR KEYWORD:        avframe *src;
The real line: +        int offset[AV_NUM_DATA_POINTERS];
End Check: 2
LINE TO PARSE FOR KEYWORD:        int offset[av_num_data_pointers];
The real line: +        int i;
End Check: 2
LINE TO PARSE FOR KEYWORD:        int i;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        if (cur->f.pict_type == AV_PICTURE_TYPE_B || h->low_delay ||
End Check: 2
LINE TO PARSE FOR KEYWORD:        if (cur->f.pict_type == av_picture_type_b || h->low_delay ||
The real line: +           (avctx->slice_flags & SLICE_FLAG_CODED_ORDER))
End Check: 2
LINE TO PARSE FOR KEYWORD:           (avctx->slice_flags & slice_flag_coded_order))
The real line: +            src = &cur->f;
End Check: 2
LINE TO PARSE FOR KEYWORD:            src = &cur->f;
The real line: +        else if (last)
End Check: 2
LINE TO PARSE FOR KEYWORD:        else if (last)
The real line: +            src = &last->f;
End Check: 2
LINE TO PARSE FOR KEYWORD:            src = &last->f;
The real line: +        else
End Check: 2
LINE TO PARSE FOR KEYWORD:        else
The real line: +            return;
End Check: 2
LINE TO PARSE FOR KEYWORD:            return;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        offset[0] = y * src->linesize[0];
End Check: 2
LINE TO PARSE FOR KEYWORD:        offset[0] = y * src->linesize[0];
The real line: +        offset[1] =
End Check: 2
LINE TO PARSE FOR KEYWORD:        offset[1] =
The real line: +        offset[2] = (y >> vshift) * src->linesize[1];
End Check: 2
LINE TO PARSE FOR KEYWORD:        offset[2] = (y >> vshift) * src->linesize[1];
The real line: +        for (i = 3; i < AV_NUM_DATA_POINTERS; i++)
End Check: 2
LINE TO PARSE FOR KEYWORD:        for (i = 3; i < av_num_data_pointers; i++)
The real line: +            offset[i] = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:            offset[i] = 0;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        emms_c();
End Check: 2
LINE TO PARSE FOR KEYWORD:        emms_c();
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        avctx->draw_horiz_band(avctx, src, offset,
End Check: 2
LINE TO PARSE FOR KEYWORD:        avctx->draw_horiz_band(avctx, src, offset,
The real line: +                               y, h->picture_structure, height);
End Check: 2
LINE TO PARSE FOR KEYWORD:                               y, h->picture_structure, height);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
109 : 150
Next: (H264Context *h, int y, int height)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void free_frame_buffer(H264Context *h, Picture *pic)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void free_frame_buffer(h264context *h, picture *pic)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void free_frame_buffer(H264Context *h, Picture *pic) 
Checking if function:  static void free_frame_buffer(H264Context *h, Picture *pic) {
PATTERN 1
Function:  void free_frame_buffer(H264Context *h, Picture *pic) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    pic->period_since_free = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    pic->period_since_free = 0;
The real line: +    ff_thread_release_buffer(h->avctx, &pic->f);
End Check: 1
LINE TO PARSE FOR KEYWORD:    ff_thread_release_buffer(h->avctx, &pic->f);
The real line: +    av_freep(&pic->f.hwaccel_picture_private);
End Check: 1
LINE TO PARSE FOR KEYWORD:    av_freep(&pic->f.hwaccel_picture_private);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
153 : 157
Next: (H264Context *h, Picture *pic)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void free_picture(H264Context *h, Picture *pic)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void free_picture(h264context *h, picture *pic)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void free_picture(H264Context *h, Picture *pic) 
Checking if function:  static void free_picture(H264Context *h, Picture *pic) {
PATTERN 1
Function:  void free_picture(H264Context *h, Picture *pic) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    int i;
End Check: 1
LINE TO PARSE FOR KEYWORD:    int i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (pic->f.data[0])
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (pic->f.data[0])
The real line: +        free_frame_buffer(h, pic);
End Check: 1
LINE TO PARSE FOR KEYWORD:        free_frame_buffer(h, pic);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    av_freep(&pic->qscale_table_base);
End Check: 1
LINE TO PARSE FOR KEYWORD:    av_freep(&pic->qscale_table_base);
The real line: +    pic->f.qscale_table = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:    pic->f.qscale_table = null;
The real line: +    av_freep(&pic->mb_type_base);
End Check: 1
LINE TO PARSE FOR KEYWORD:    av_freep(&pic->mb_type_base);
The real line: +    pic->f.mb_type = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:    pic->f.mb_type = null;
The real line: +    for (i = 0; i < 2; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < 2; i++) {
The real line: +        av_freep(&pic->motion_val_base[i]);
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_freep(&pic->motion_val_base[i]);
The real line: +        av_freep(&pic->f.ref_index[i]);
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_freep(&pic->f.ref_index[i]);
The real line: +        pic->f.motion_val[i] = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:        pic->f.motion_val[i] = null;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
160 : 175
Next: (H264Context *h, Picture *pic)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void release_unused_pictures(H264Context *h, int remove_current)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void release_unused_pictures(h264context *h, int remove_current)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void release_unused_pictures(H264Context *h, int remove_current) 
Checking if function:  static void release_unused_pictures(H264Context *h, int remove_current) {
PATTERN 1
Function:  void release_unused_pictures(H264Context *h, int remove_current) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    int i;
End Check: 1
LINE TO PARSE FOR KEYWORD:    int i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    /* release non reference frames */
End Check: 1
LINE TO PARSE FOR KEYWORD:    
The real line: +    for (i = 0; i < h->picture_count; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < h->picture_count; i++) {
The real line: +        if (h->DPB[i].f.data[0] && !h->DPB[i].f.reference &&
End Check: 2
LINE TO PARSE FOR KEYWORD:        if (h->dpb[i].f.data[0] && !h->dpb[i].f.reference &&
The real line: +            (!h->DPB[i].owner2 || h->DPB[i].owner2 == h) &&
End Check: 2
LINE TO PARSE FOR KEYWORD:            (!h->dpb[i].owner2 || h->dpb[i].owner2 == h) &&
The real line: +            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:            (remove_current || &h->dpb[i] != h->cur_pic_ptr)) {
The real line: +            free_frame_buffer(h, &h->DPB[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:            free_frame_buffer(h, &h->dpb[i]);
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
178 : 189
Next: (H264Context *h, int remove_current)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static int alloc_scratch_buffers(H264Context *h, int linesize)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static int alloc_scratch_buffers(h264context *h, int linesize)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static int alloc_scratch_buffers(H264Context *h, int linesize) 
Checking if function:  static int alloc_scratch_buffers(H264Context *h, int linesize) {
PATTERN 1
Function:  int alloc_scratch_buffers(H264Context *h, int linesize) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);
End Check: 1
LINE TO PARSE FOR KEYWORD:    int alloc_size = ffalign(ffabs(linesize) + 32, 32);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (h->bipred_scratchpad)
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (h->bipred_scratchpad)
The real line: +        return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    h->bipred_scratchpad = av_malloc(16 * 6 * alloc_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->bipred_scratchpad = av_malloc(16 * 6 * alloc_size);
The real line: +    // edge emu needs blocksize + filter length - 1
End Check: 1
LINE TO PARSE FOR KEYWORD:    
The real line: +    // (= 21x21 for  h264)
End Check: 1
LINE TO PARSE FOR KEYWORD:    
The real line: +    h->edge_emu_buffer = av_mallocz(alloc_size * 2 * 21);
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->edge_emu_buffer = av_mallocz(alloc_size * 2 * 21);
The real line: +    h->me.scratchpad   = av_mallocz(alloc_size * 2 * 16 * 2);
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->me.scratchpad   = av_mallocz(alloc_size * 2 * 16 * 2);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (!h->bipred_scratchpad || !h->edge_emu_buffer || !h->me.scratchpad) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (!h->bipred_scratchpad || !h->edge_emu_buffer || !h->me.scratchpad) {
The real line: +        av_freep(&h->bipred_scratchpad);
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_freep(&h->bipred_scratchpad);
The real line: +        av_freep(&h->edge_emu_buffer);
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_freep(&h->edge_emu_buffer);
The real line: +        av_freep(&h->me.scratchpad);
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_freep(&h->me.scratchpad);
The real line: +        return AVERROR(ENOMEM);
End Check: 2
LINE TO PARSE FOR KEYWORD:        return averror(enomem);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    h->me.temp = h->me.scratchpad;
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->me.temp = h->me.scratchpad;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
192 : 214
Next: (H264Context *h, int linesize)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static int alloc_picture(H264Context *h, Picture *pic)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static int alloc_picture(h264context *h, picture *pic)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static int alloc_picture(H264Context *h, Picture *pic) 
Checking if function:  static int alloc_picture(H264Context *h, Picture *pic) {
PATTERN 1
Function:  int alloc_picture(H264Context *h, Picture *pic) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    const int big_mb_num    = h->mb_stride * (h->mb_height + 1) + 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    const int big_mb_num    = h->mb_stride * (h->mb_height + 1) + 1;
The real line: +    const int mb_array_size = h->mb_stride * h->mb_height;
End Check: 1
LINE TO PARSE FOR KEYWORD:    const int mb_array_size = h->mb_stride * h->mb_height;
The real line: +    const int b4_stride     = h->mb_width * 4 + 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:    const int b4_stride     = h->mb_width * 4 + 1;
The real line: +    const int b4_array_size = b4_stride * h->mb_height * 4;
End Check: 1
LINE TO PARSE FOR KEYWORD:    const int b4_array_size = b4_stride * h->mb_height * 4;
The real line: +    int i, ret = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    int i, ret = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    av_assert0(!pic->f.data[0]);
End Check: 1
LINE TO PARSE FOR KEYWORD:    av_assert0(!pic->f.data[0]);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (h->avctx->hwaccel) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (h->avctx->hwaccel) {
The real line: +        const AVHWAccel *hwaccel = h->avctx->hwaccel;
End Check: 2
LINE TO PARSE FOR KEYWORD:        const avhwaccel *hwaccel = h->avctx->hwaccel;
The real line: +        av_assert0(!pic->f.hwaccel_picture_private);
End Check: 2
LINE TO PARSE FOR KEYWORD:        av_assert0(!pic->f.hwaccel_picture_private);
The real line: +        if (hwaccel->priv_data_size) {
End Check: 3
LINE TO PARSE FOR KEYWORD:        if (hwaccel->priv_data_size) {
The real line: +            pic->f.hwaccel_picture_private = av_mallocz(hwaccel->priv_data_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:            pic->f.hwaccel_picture_private = av_mallocz(hwaccel->priv_data_size);
The real line: +            if (!pic->f.hwaccel_picture_private)
End Check: 3
LINE TO PARSE FOR KEYWORD:            if (!pic->f.hwaccel_picture_private)
The real line: +                return AVERROR(ENOMEM);
End Check: 3
LINE TO PARSE FOR KEYWORD:                return averror(enomem);
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +    ret = ff_thread_get_buffer(h->avctx, &pic->f);
End Check: 1
LINE TO PARSE FOR KEYWORD:    ret = ff_thread_get_buffer(h->avctx, &pic->f);
The real line: +    if (ret < 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (ret < 0)
The real line: +        goto fail;
End Check: 1
LINE TO PARSE FOR KEYWORD:        goto fail;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    h->linesize   = pic->f.linesize[0];
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->linesize   = pic->f.linesize[0];
The real line: +    h->uvlinesize = pic->f.linesize[1];
End Check: 1
LINE TO PARSE FOR KEYWORD:    h->uvlinesize = pic->f.linesize[1];
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (pic->f.qscale_table == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (pic->f.qscale_table == null) {
The real line: +        FF_ALLOCZ_OR_GOTO(h->avctx, pic->qscale_table_base,
End Check: 2
LINE TO PARSE FOR KEYWORD:        ff_allocz_or_goto(h->avctx, pic->qscale_table_base,
The real line: +                          (big_mb_num + h->mb_stride) * sizeof(uint8_t),
End Check: 2
LINE TO PARSE FOR KEYWORD:                          (big_mb_num + h->mb_stride) * sizeof(uint8_t),
The real line: +                          fail)
End Check: 2
LINE TO PARSE FOR KEYWORD:                          fail)
The real line: +        FF_ALLOCZ_OR_GOTO(h->avctx, pic->mb_type_base,
End Check: 2
LINE TO PARSE FOR KEYWORD:        ff_allocz_or_goto(h->avctx, pic->mb_type_base,
The real line: +                          (big_mb_num + h->mb_stride) * sizeof(uint32_t),
End Check: 2
LINE TO PARSE FOR KEYWORD:                          (big_mb_num + h->mb_stride) * sizeof(uint32_t),
The real line: +                          fail)
End Check: 2
LINE TO PARSE FOR KEYWORD:                          fail)
The real line: +        pic->f.mb_type = pic->mb_type_base + 2 * h->mb_stride + 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:        pic->f.mb_type = pic->mb_type_base + 2 * h->mb_stride + 1;
The real line: +        pic->f.qscale_table = pic->qscale_table_base + 2 * h->mb_stride + 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:        pic->f.qscale_table = pic->qscale_table_base + 2 * h->mb_stride + 1;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        for (i = 0; i < 2; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:        for (i = 0; i < 2; i++) {
The real line: +            FF_ALLOCZ_OR_GOTO(h->avctx, pic->motion_val_base[i],
End Check: 3
LINE TO PARSE FOR KEYWORD:            ff_allocz_or_goto(h->avctx, pic->motion_val_base[i],
The real line: +                              2 * (b4_array_size + 4) * sizeof(int16_t),
End Check: 3
LINE TO PARSE FOR KEYWORD:                              2 * (b4_array_size + 4) * sizeof(int16_t),
The real line: +                              fail)
End Check: 3
LINE TO PARSE FOR KEYWORD:                              fail)
The real line: +            pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
End Check: 3
LINE TO PARSE FOR KEYWORD:            pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
The real line: +            FF_ALLOCZ_OR_GOTO(h->avctx, pic->f.ref_index[i],
End Check: 3
LINE TO PARSE FOR KEYWORD:            ff_allocz_or_goto(h->avctx, pic->f.ref_index[i],
The real line: +                              4 * mb_array_size * sizeof(uint8_t), fail)
End Check: 3
LINE TO PARSE FOR KEYWORD:                              4 * mb_array_size * sizeof(uint8_t), fail)
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
The real line: +        pic->f.motion_subsample_log2 = 2;
End Check: 2
LINE TO PARSE FOR KEYWORD:        pic->f.motion_subsample_log2 = 2;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        pic->f.qstride = h->mb_stride;
End Check: 2
LINE TO PARSE FOR KEYWORD:        pic->f.qstride = h->mb_stride;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    pic->owner2 = h;
End Check: 1
LINE TO PARSE FOR KEYWORD:    pic->owner2 = h;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 0;
The real line: +fail:
End Check: 1
LINE TO PARSE FOR KEYWORD:fail:
The real line: +    free_frame_buffer(h, pic);
End Check: 1
LINE TO PARSE FOR KEYWORD:    free_frame_buffer(h, pic);
The real line: +    return (ret < 0) ? ret : AVERROR(ENOMEM);
End Check: 1
LINE TO PARSE FOR KEYWORD:    return (ret < 0) ? ret : averror(enomem);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
217 : 271
Next: (H264Context *h, Picture *pic)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline int pic_is_unused(H264Context *h, Picture *pic)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static inline int pic_is_unused(h264context *h, picture *pic)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static inline int pic_is_unused(H264Context *h, Picture *pic) 
Checking if function:  static inline int pic_is_unused(H264Context *h, Picture *pic) {
PATTERN 1
Function:  int pic_is_unused(H264Context *h, Picture *pic) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    if (   (h->avctx->active_thread_type & FF_THREAD_FRAME)
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (   (h->avctx->active_thread_type & ff_thread_frame)
The real line: +        && pic->f.qscale_table //check if the frame has anything allocated
End Check: 1
LINE TO PARSE FOR KEYWORD:        && pic->f.qscale_table 
The real line: +        && pic->period_since_free < h->avctx->thread_count)
End Check: 1
LINE TO PARSE FOR KEYWORD:        && pic->period_since_free < h->avctx->thread_count)
The real line: +        return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return 0;
The real line: +    if (pic->f.data[0] == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (pic->f.data[0] == null)
The real line: +        return 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return 1;
The real line: +    if (pic->needs_realloc && !(pic->f.reference & DELAYED_PIC_REF))
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (pic->needs_realloc && !(pic->f.reference & delayed_pic_ref))
The real line: +        if (!pic->owner2 || pic->owner2 == h)
End Check: 1
LINE TO PARSE FOR KEYWORD:        if (!pic->owner2 || pic->owner2 == h)
The real line: +            return 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:            return 1;
The real line: +    return 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return 0;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
274 : 285
Next: (H264Context *h, Picture *pic)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static int find_unused_picture(H264Context *h)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static int find_unused_picture(h264context *h)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static int find_unused_picture(H264Context *h) 
Checking if function:  static int find_unused_picture(H264Context *h) {
PATTERN 1
Function:  int find_unused_picture(H264Context *h) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +    int i;
End Check: 1
LINE TO PARSE FOR KEYWORD:    int i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    for (i = h->picture_range_start; i < h->picture_range_end; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:    for (i = h->picture_range_start; i < h->picture_range_end; i++) {
The real line: +        if (pic_is_unused(h, &h->DPB[i]))
End Check: 2
LINE TO PARSE FOR KEYWORD:        if (pic_is_unused(h, &h->dpb[i]))
The real line: +            break;
End Check: 2
LINE TO PARSE FOR KEYWORD:            break;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +    if (i == h->picture_range_end)
End Check: 1
LINE TO PARSE FOR KEYWORD:    if (i == h->picture_range_end)
The real line: +        return AVERROR_INVALIDDATA;
End Check: 1
LINE TO PARSE FOR KEYWORD:        return averror_invaliddata;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    if (h->DPB[i].needs_realloc) {
End Check: 2
LINE TO PARSE FOR KEYWORD:  .  if (h->dpb[i].needs_realloc) {
The real line: +        h->DPB[i].needs_realloc = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:        h->dpb[i].needs_realloc = 0;
The real line: +        free_picture(h, &h->DPB[i]);
End Check: 2
LINE TO PARSE FOR KEYWORD:        free_picture(h, &h->dpb[i]);
The real line: +        avcodec_get_frame_defaults(&h->DPB[i].f);
End Check: 2
LINE TO PARSE FOR KEYWORD:        avcodec_get_frame_defaults(&h->dpb[i].f);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +    return i;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return i;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
288 : 305
Next: (H264Context *h)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
Chunk End.
The real line: +static const char* kAlertDialogMessage = "WebKitGTK+ alert dialog message";
Current Name Search: 
LINE TO PARSE FOR KEYWORD:static const char* kalertdialogmessage = ;
Depths: 0:0
[]
The real line: +static const char* kConfirmDialogMessage = "WebKitGTK+ confirm dialog message";
Current Name Search: static const char* kAlertDialogMessage = ; 
LINE TO PARSE FOR KEYWORD:static const char* kconfirmdialogmessage = ;
Depths: 0:0
[]
The real line: +static const char* kPromptDialogMessage = "WebKitGTK+ prompt dialog message";
Current Name Search: static const char* kConfirmDialogMessage = ; 
LINE TO PARSE FOR KEYWORD:static const char* kpromptdialogmessage = ;
Depths: 0:0
[]
The real line: +static const char* kPromptDialogReturnedText = "WebKitGTK+ prompt dialog returned text";
Current Name Search: static const char* kPromptDialogMessage = ; 
LINE TO PARSE FOR KEYWORD:static const char* kpromptdialogreturnedtext = ;
Depths: 0:0
[]
The real line: +
Current Name Search: static const char* kPromptDialogReturnedText = ; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +class UIClientTest: public WebViewTest {
Current Name Search: static const char* kPromptDialogReturnedText = ;  
Checking if function: static const char* kPromptDialogReturnedText = ;  class UIClientTest: public WebViewTest {
Class: class uiclienttest: public webviewtest {
LINE TO PARSE FOR KEYWORD:class uiclienttest: public webviewtest {
Depths: 1:1
['uiclienttest']
The real line: +public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD:public:
Depths: 1:1
['uiclienttest']
The real line: +    MAKE_GLIB_TEST_FIXTURE(UIClientTest);
Current Name Search: public: 
LINE TO PARSE FOR KEYWORD:    make_glib_test_fixture(uiclienttest);
Depths: 1:1
['uiclienttest']
The real line: +
Current Name Search:     MAKE_GLIB_TEST_FIXTURE(UIClientTest); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest']
The real line: +    enum WebViewEvents {
Current Name Search:     MAKE_GLIB_TEST_FIXTURE(UIClientTest);  
Checking if function:     MAKE_GLIB_TEST_FIXTURE(UIClientTest);      enum WebViewEvents {
Class context: uiclienttest
Checking if a constructor/destructor:     MAKE_GLIB_TEST_FIXTURE(UIClientTest);      enum WebViewEvents {
Other type of bracket:     MAKE_GLIB_TEST_FIXTURE(UIClientTest);      enum WebViewEvents {
LINE TO PARSE FOR KEYWORD:    enum webviewevents {
Depths: 2:2
['uiclienttest']
The real line: +        Create,
Current Name Search: 
LINE TO PARSE FOR KEYWORD:        create,
Depths: 2:2
['uiclienttest']
The real line: +        ReadyToShow,
Current Name Search:         Create, 
LINE TO PARSE FOR KEYWORD:        readytoshow,
Depths: 2:2
['uiclienttest']
The real line: +        RunAsModal,
Current Name Search:         Create,         ReadyToShow, 
LINE TO PARSE FOR KEYWORD:        runasmodal,
Depths: 2:2
['uiclienttest']
The real line: +        Close
Current Name Search:         Create,         ReadyToShow,         RunAsModal, 
LINE TO PARSE FOR KEYWORD:        close
Depths: 2:2
['uiclienttest']
The real line: +    };
Current Name Search:         Create,         ReadyToShow,         RunAsModal,         Close 
LINE TO PARSE FOR KEYWORD:    };
Depths: 1:2
['uiclienttest']
Adjusting depth.
The real line: +
Current Name Search:     }; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest']
The real line: +    class WindowProperties {
Current Name Search:     };  
Checking if function:     };      class WindowProperties {
Class context: uiclienttest
Checking if a constructor/destructor:     };      class WindowProperties {
Class: class windowproperties {
LINE TO PARSE FOR KEYWORD:    class windowproperties {
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +    public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    public:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        WindowProperties()
Current Name Search:     public: 
LINE TO PARSE FOR KEYWORD:        windowproperties()
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            : m_isNull(true)
Current Name Search:     public:         WindowProperties() 
LINE TO PARSE FOR KEYWORD:            : m_isnull(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_toolbarVisible(true)
Current Name Search:     public:         WindowProperties()             : m_isNull(true) 
LINE TO PARSE FOR KEYWORD:            , m_toolbarvisible(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_statusbarVisible(true)
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true) 
LINE TO PARSE FOR KEYWORD:            , m_statusbarvisible(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_scrollbarsVisible(true)
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true) 
LINE TO PARSE FOR KEYWORD:            , m_scrollbarsvisible(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_menubarVisible(true)
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true) 
LINE TO PARSE FOR KEYWORD:            , m_menubarvisible(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_locationbarVisible(true)
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true) 
LINE TO PARSE FOR KEYWORD:            , m_locationbarvisible(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_resizable(true)
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true) 
LINE TO PARSE FOR KEYWORD:            , m_resizable(true)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_fullscreen(false)
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true)             , m_resizable(true) 
LINE TO PARSE FOR KEYWORD:            , m_fullscreen(false)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        {
Current Name Search:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true)             , m_resizable(true)             , m_fullscreen(false) 
Checking if function:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true)             , m_resizable(true)             , m_fullscreen(false)         {
Class context: uiclienttest
Checking if a constructor/destructor:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true)             , m_resizable(true)             , m_fullscreen(false)         {
Class context: windowproperties
Checking if a constructor/destructor:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true)             , m_resizable(true)             , m_fullscreen(false)         {
Function:     public:         WindowProperties()             : m_isNull(true)             , m_toolbarVisible(true)             , m_statusbarVisible(true)             , m_scrollbarsVisible(true)             , m_menubarVisible(true)             , m_locationbarVisible(true)             , m_resizable(true)             , m_fullscreen(false)         {
LINE TO PARSE FOR KEYWORD:        {
Depths: 3:2
['uiclienttest', 'windowproperties']
The real line: +            memset(&m_geometry, 0, sizeof(GdkRectangle));
End Check: 3
LINE TO PARSE FOR KEYWORD:            memset(&m_geometry, 0, sizeof(gdkrectangle));
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
28 : 30
Next: ()
Next: (true)
Next: (true)
Next: (true)
Next: (true)
Next: (true)
Next: (true)
Next: (true)
Next: (false)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        WindowProperties(WebKitWindowProperties* windowProperties)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:        windowproperties(webkitwindowproperties* windowproperties)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            : m_isNull(false)
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties) 
LINE TO PARSE FOR KEYWORD:            : m_isnull(false)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false) 
LINE TO PARSE FOR KEYWORD:            , m_toolbarvisible(webkit_window_properties_get_toolbar_visible(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties)) 
LINE TO PARSE FOR KEYWORD:            , m_statusbarvisible(webkit_window_properties_get_statusbar_visible(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties)) 
LINE TO PARSE FOR KEYWORD:            , m_scrollbarsvisible(webkit_window_properties_get_scrollbars_visible(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties)) 
LINE TO PARSE FOR KEYWORD:            , m_menubarvisible(webkit_window_properties_get_menubar_visible(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties)) 
LINE TO PARSE FOR KEYWORD:            , m_locationbarvisible(webkit_window_properties_get_locationbar_visible(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_resizable(webkit_window_properties_get_resizable(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties)) 
LINE TO PARSE FOR KEYWORD:            , m_resizable(webkit_window_properties_get_resizable(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_fullscreen(webkit_window_properties_get_fullscreen(windowProperties))
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))             , m_resizable(webkit_window_properties_get_resizable(windowProperties)) 
LINE TO PARSE FOR KEYWORD:            , m_fullscreen(webkit_window_properties_get_fullscreen(windowproperties))
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        {
Current Name Search:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))             , m_resizable(webkit_window_properties_get_resizable(windowProperties))             , m_fullscreen(webkit_window_properties_get_fullscreen(windowProperties)) 
Checking if function:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))             , m_resizable(webkit_window_properties_get_resizable(windowProperties))             , m_fullscreen(webkit_window_properties_get_fullscreen(windowProperties))         {
Class context: uiclienttest
Checking if a constructor/destructor:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))             , m_resizable(webkit_window_properties_get_resizable(windowProperties))             , m_fullscreen(webkit_window_properties_get_fullscreen(windowProperties))         {
Class context: windowproperties
Checking if a constructor/destructor:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))             , m_resizable(webkit_window_properties_get_resizable(windowProperties))             , m_fullscreen(webkit_window_properties_get_fullscreen(windowProperties))         {
Function:          WindowProperties(WebKitWindowProperties* windowProperties)             : m_isNull(false)             , m_toolbarVisible(webkit_window_properties_get_toolbar_visible(windowProperties))             , m_statusbarVisible(webkit_window_properties_get_statusbar_visible(windowProperties))             , m_scrollbarsVisible(webkit_window_properties_get_scrollbars_visible(windowProperties))             , m_menubarVisible(webkit_window_properties_get_menubar_visible(windowProperties))             , m_locationbarVisible(webkit_window_properties_get_locationbar_visible(windowProperties))             , m_resizable(webkit_window_properties_get_resizable(windowProperties))             , m_fullscreen(webkit_window_properties_get_fullscreen(windowProperties))         {
LINE TO PARSE FOR KEYWORD:        {
Depths: 3:2
['uiclienttest', 'windowproperties']
The real line: +            webkit_window_properties_get_geometry(windowProperties, &m_geometry);
End Check: 3
LINE TO PARSE FOR KEYWORD:            webkit_window_properties_get_geometry(windowproperties, &m_geometry);
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
41 : 43
Next: (WebKitWindowProperties* windowProperties)
Next: (false)
Next: (webkit_window_properties_get_toolbar_visible(windowProperties)
Next: (webkit_window_properties_get_statusbar_visible(windowProperties)
Next: (webkit_window_properties_get_scrollbars_visible(windowProperties)
Next: (webkit_window_properties_get_menubar_visible(windowProperties)
Next: (webkit_window_properties_get_locationbar_visible(windowProperties)
Next: (webkit_window_properties_get_resizable(windowProperties)
Next: (webkit_window_properties_get_fullscreen(windowProperties)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,
Current Name Search:  
LINE TO PARSE FOR KEYWORD:        windowproperties(gdkrectangle* geometry, bool toolbarvisible, bool statusbarvisible, bool scrollbarsvisible, bool menubarvisible,
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +                         bool locationbarVisible, bool resizable, bool fullscreen)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible, 
LINE TO PARSE FOR KEYWORD:                         bool locationbarvisible, bool resizable, bool fullscreen)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            : m_isNull(false)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen) 
LINE TO PARSE FOR KEYWORD:            : m_isnull(false)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_geometry(*geometry)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false) 
LINE TO PARSE FOR KEYWORD:            , m_geometry(*geometry)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_toolbarVisible(toolbarVisible)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry) 
LINE TO PARSE FOR KEYWORD:            , m_toolbarvisible(toolbarvisible)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_statusbarVisible(statusbarVisible)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible) 
LINE TO PARSE FOR KEYWORD:            , m_statusbarvisible(statusbarvisible)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_scrollbarsVisible(scrollbarsVisible)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible) 
LINE TO PARSE FOR KEYWORD:            , m_scrollbarsvisible(scrollbarsvisible)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_menubarVisible(menubarVisible)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible) 
LINE TO PARSE FOR KEYWORD:            , m_menubarvisible(menubarvisible)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_locationbarVisible(locationbarVisible)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible) 
LINE TO PARSE FOR KEYWORD:            , m_locationbarvisible(locationbarvisible)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_resizable(resizable)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible) 
LINE TO PARSE FOR KEYWORD:            , m_resizable(resizable)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +            , m_fullscreen(fullscreen)
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable) 
LINE TO PARSE FOR KEYWORD:            , m_fullscreen(fullscreen)
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        {
Current Name Search:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable)             , m_fullscreen(fullscreen) 
Checking if function:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable)             , m_fullscreen(fullscreen)         {
Class context: uiclienttest
Checking if a constructor/destructor:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable)             , m_fullscreen(fullscreen)         {
Class context: windowproperties
Checking if a constructor/destructor:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable)             , m_fullscreen(fullscreen)         {
Function:          WindowProperties(GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)             : m_isNull(false)             , m_geometry(*geometry)             , m_toolbarVisible(toolbarVisible)             , m_statusbarVisible(statusbarVisible)             , m_scrollbarsVisible(scrollbarsVisible)             , m_menubarVisible(menubarVisible)             , m_locationbarVisible(locationbarVisible)             , m_resizable(resizable)             , m_fullscreen(fullscreen)         {
LINE TO PARSE FOR KEYWORD:        {
Depths: 3:2
['uiclienttest', 'windowproperties']
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
56 : 57
Next: (GdkRectangle* geometry, bool toolbarVisible, bool statusbarVisible, bool scrollbarsVisible, bool menubarVisible,                          bool locationbarVisible, bool resizable, bool fullscreen)
Next: (false)
Next: (*geometry)
Next: (toolbarVisible)
Next: (statusbarVisible)
Next: (scrollbarsVisible)
Next: (menubarVisible)
Next: (locationbarVisible)
Next: (resizable)
Next: (fullscreen)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool isNull() const { return m_isNull; }
Current Name Search:  
Checking if function:          bool isNull() const {
PATTERN 4
Function: bool isNull(){
LINE TO PARSE FOR KEYWORD:        bool isnull() const { return m_isnull; }
Next: ()
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        void assertEqual(const WindowProperties& other) const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:        void assertequal(const windowproperties& other) const
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        {
Current Name Search:          void assertEqual(const WindowProperties& other) const 
Checking if function:          void assertEqual(const WindowProperties& other) const         {
PATTERN 4
Function: void assertEqual(const WindowProperties& other)        {
LINE TO PARSE FOR KEYWORD:        {
Depths: 3:2
['uiclienttest', 'windowproperties']
The real line: +            g_assert_cmpint(m_geometry.x, ==, other.m_geometry.x);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(m_geometry.x, ==, other.m_geometry.x);
The real line: +            g_assert_cmpint(m_geometry.y, ==, other.m_geometry.y);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(m_geometry.y, ==, other.m_geometry.y);
The real line: +            g_assert_cmpint(m_geometry.width, ==, other.m_geometry.width);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(m_geometry.width, ==, other.m_geometry.width);
The real line: +            g_assert_cmpint(m_geometry.height, ==, other.m_geometry.height);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(m_geometry.height, ==, other.m_geometry.height);
The real line: +            g_assert_cmpint(static_cast<int>(m_toolbarVisible), ==, static_cast<int>(other.m_toolbarVisible));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_toolbarvisible), ==, static_cast<int>(other.m_toolbarvisible));
The real line: +            g_assert_cmpint(static_cast<int>(m_statusbarVisible), ==, static_cast<int>(other.m_statusbarVisible));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_statusbarvisible), ==, static_cast<int>(other.m_statusbarvisible));
The real line: +            g_assert_cmpint(static_cast<int>(m_scrollbarsVisible), ==, static_cast<int>(other.m_scrollbarsVisible));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_scrollbarsvisible), ==, static_cast<int>(other.m_scrollbarsvisible));
The real line: +            g_assert_cmpint(static_cast<int>(m_menubarVisible), ==, static_cast<int>(other.m_menubarVisible));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_menubarvisible), ==, static_cast<int>(other.m_menubarvisible));
The real line: +            g_assert_cmpint(static_cast<int>(m_locationbarVisible), ==, static_cast<int>(other.m_locationbarVisible));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_locationbarvisible), ==, static_cast<int>(other.m_locationbarvisible));
The real line: +            g_assert_cmpint(static_cast<int>(m_resizable), ==, static_cast<int>(other.m_resizable));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_resizable), ==, static_cast<int>(other.m_resizable));
The real line: +            g_assert_cmpint(static_cast<int>(m_fullscreen), ==, static_cast<int>(other.m_fullscreen));
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpint(static_cast<int>(m_fullscreen), ==, static_cast<int>(other.m_fullscreen));
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
62 : 74
Next: (const WindowProperties& other)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +    private:
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    private:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_isNull;
Current Name Search:      private: 
LINE TO PARSE FOR KEYWORD:        bool m_isnull;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +
Current Name Search:         bool m_isNull; 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        GdkRectangle m_geometry;
Current Name Search:         bool m_isNull;  
LINE TO PARSE FOR KEYWORD:        gdkrectangle m_geometry;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +
Current Name Search:         GdkRectangle m_geometry; 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_toolbarVisible;
Current Name Search:         GdkRectangle m_geometry;  
LINE TO PARSE FOR KEYWORD:        bool m_toolbarvisible;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_statusbarVisible;
Current Name Search:         bool m_toolbarVisible; 
LINE TO PARSE FOR KEYWORD:        bool m_statusbarvisible;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_scrollbarsVisible;
Current Name Search:         bool m_statusbarVisible; 
LINE TO PARSE FOR KEYWORD:        bool m_scrollbarsvisible;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_menubarVisible;
Current Name Search:         bool m_scrollbarsVisible; 
LINE TO PARSE FOR KEYWORD:        bool m_menubarvisible;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_locationbarVisible;
Current Name Search:         bool m_menubarVisible; 
LINE TO PARSE FOR KEYWORD:        bool m_locationbarvisible;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +
Current Name Search:         bool m_locationbarVisible; 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_resizable;
Current Name Search:         bool m_locationbarVisible;  
LINE TO PARSE FOR KEYWORD:        bool m_resizable;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        bool m_fullscreen;
Current Name Search:         bool m_resizable; 
LINE TO PARSE FOR KEYWORD:        bool m_fullscreen;
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +    };
Current Name Search:         bool m_fullscreen; 
LINE TO PARSE FOR KEYWORD:    };
Depths: 1:2
['uiclienttest', 'windowproperties']
Adjusting depth.
The real line: +
Current Name Search:     }; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static void windowPropertiesNotifyCallback(GObject*, GParamSpec* paramSpec, UIClientTest* test)
Current Name Search:     };  
LINE TO PARSE FOR KEYWORD:    static void windowpropertiesnotifycallback(gobject*, gparamspec* paramspec, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:     };      static void windowPropertiesNotifyCallback(GObject*, GParamSpec* paramSpec, UIClientTest* test) 
Checking if function:     };      static void windowPropertiesNotifyCallback(GObject*, GParamSpec* paramSpec, UIClientTest* test)     {
PATTERN 1
Function:  void windowPropertiesNotifyCallback(GObject*, GParamSpec* paramSpec, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        test->m_windowPropertiesChanged.add(g_param_spec_get_name(paramSpec));
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->m_windowpropertieschanged.add(g_param_spec_get_name(paramspec));
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
92 : 94
Next: (GObject*, GParamSpec* paramSpec, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static GtkWidget* viewCreateCallback(WebKitWebView* webView, UIClientTest* test)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static gtkwidget* viewcreatecallback(webkitwebview* webview, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      static GtkWidget* viewCreateCallback(WebKitWebView* webView, UIClientTest* test) 
Checking if function:      static GtkWidget* viewCreateCallback(WebKitWebView* webView, UIClientTest* test)     {
PATTERN 1
Function:  GtkWidget* viewCreateCallback(WebKitWebView* webView, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        return test->viewCreate(webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        return test->viewcreate(webview);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
97 : 99
Next: (WebKitWebView* webView, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static void viewReadyToShowCallback(WebKitWebView* webView, UIClientTest* test)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static void viewreadytoshowcallback(webkitwebview* webview, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      static void viewReadyToShowCallback(WebKitWebView* webView, UIClientTest* test) 
Checking if function:      static void viewReadyToShowCallback(WebKitWebView* webView, UIClientTest* test)     {
PATTERN 1
Function:  void viewReadyToShowCallback(WebKitWebView* webView, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        test->viewReadyToShow(webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->viewreadytoshow(webview);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
102 : 104
Next: (WebKitWebView* webView, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static void viewCloseCallback(WebKitWebView* webView, UIClientTest* test)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static void viewclosecallback(webkitwebview* webview, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      static void viewCloseCallback(WebKitWebView* webView, UIClientTest* test) 
Checking if function:      static void viewCloseCallback(WebKitWebView* webView, UIClientTest* test)     {
PATTERN 1
Function:  void viewCloseCallback(WebKitWebView* webView, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        test->viewClose(webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->viewclose(webview);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
107 : 109
Next: (WebKitWebView* webView, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    void scriptAlert(WebKitScriptDialog* dialog)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    void scriptalert(webkitscriptdialog* dialog)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      void scriptAlert(WebKitScriptDialog* dialog) 
Checking if function:      void scriptAlert(WebKitScriptDialog* dialog)     {
PATTERN 4
Function: void scriptAlert(WebKitScriptDialog* dialog)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        switch (m_scriptDialogType) {
End Check: 3
LINE TO PARSE FOR KEYWORD:        switch (m_scriptdialogtype) {
The real line: +        case WEBKIT_SCRIPT_DIALOG_ALERT:
End Check: 3
LINE TO PARSE FOR KEYWORD:        case webkit_script_dialog_alert:
The real line: +            g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kAlertDialogMessage);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kalertdialogmessage);
The real line: +            break;
End Check: 3
LINE TO PARSE FOR KEYWORD:            break;
The real line: +        case WEBKIT_SCRIPT_DIALOG_CONFIRM:
End Check: 3
LINE TO PARSE FOR KEYWORD:        case webkit_script_dialog_confirm:
The real line: +            g_assert(m_scriptDialogConfirmed);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert(m_scriptdialogconfirmed);
The real line: +            g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, "confirmed");
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, );
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +            break;
End Check: 3
LINE TO PARSE FOR KEYWORD:            break;
The real line: +        case WEBKIT_SCRIPT_DIALOG_PROMPT:
End Check: 3
LINE TO PARSE FOR KEYWORD:        case webkit_script_dialog_prompt:
The real line: +            g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kPromptDialogReturnedText);
End Check: 3
LINE TO PARSE FOR KEYWORD:            g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kpromptdialogreturnedtext);
The real line: +            break;
End Check: 3
LINE TO PARSE FOR KEYWORD:            break;
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        g_main_loop_quit(m_mainLoop);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_main_loop_quit(m_mainloop);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
112 : 128
Next: (WebKitScriptDialog* dialog)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    void scriptConfirm(WebKitScriptDialog* dialog)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    void scriptconfirm(webkitscriptdialog* dialog)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      void scriptConfirm(WebKitScriptDialog* dialog) 
Checking if function:      void scriptConfirm(WebKitScriptDialog* dialog)     {
PATTERN 4
Function: void scriptConfirm(WebKitScriptDialog* dialog)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kConfirmDialogMessage);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kconfirmdialogmessage);
The real line: +        m_scriptDialogConfirmed = !m_scriptDialogConfirmed;
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_scriptdialogconfirmed = !m_scriptdialogconfirmed;
The real line: +        webkit_script_dialog_confirm_set_confirmed(dialog, m_scriptDialogConfirmed);
End Check: 2
LINE TO PARSE FOR KEYWORD:        webkit_script_dialog_confirm_set_confirmed(dialog, m_scriptdialogconfirmed);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
131 : 135
Next: (WebKitScriptDialog* dialog)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    void scriptPrompt(WebKitScriptDialog* dialog)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    void scriptprompt(webkitscriptdialog* dialog)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      void scriptPrompt(WebKitScriptDialog* dialog) 
Checking if function:      void scriptPrompt(WebKitScriptDialog* dialog)     {
PATTERN 4
Function: void scriptPrompt(WebKitScriptDialog* dialog)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kPromptDialogMessage);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert_cmpstr(webkit_script_dialog_get_message(dialog), ==, kpromptdialogmessage);
The real line: +        g_assert_cmpstr(webkit_script_dialog_prompt_get_default_text(dialog), ==, "default");
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert_cmpstr(webkit_script_dialog_prompt_get_default_text(dialog), ==, );
The real line: +        webkit_script_dialog_prompt_set_text(dialog, kPromptDialogReturnedText);
End Check: 2
LINE TO PARSE FOR KEYWORD:        webkit_script_dialog_prompt_set_text(dialog, kpromptdialogreturnedtext);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
138 : 142
Next: (WebKitScriptDialog* dialog)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static gboolean scriptDialog(WebKitWebView*, WebKitScriptDialog* dialog, UIClientTest* test)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static gboolean scriptdialog(webkitwebview*, webkitscriptdialog* dialog, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      static gboolean scriptDialog(WebKitWebView*, WebKitScriptDialog* dialog, UIClientTest* test) 
Checking if function:      static gboolean scriptDialog(WebKitWebView*, WebKitScriptDialog* dialog, UIClientTest* test)     {
PATTERN 1
Function:  gboolean scriptDialog(WebKitWebView*, WebKitScriptDialog* dialog, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        switch (webkit_script_dialog_get_dialog_type(dialog)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:        switch (webkit_script_dialog_get_dialog_type(dialog)) {
The real line: +        case WEBKIT_SCRIPT_DIALOG_ALERT:
End Check: 3
LINE TO PARSE FOR KEYWORD:        case webkit_script_dialog_alert:
The real line: +            test->scriptAlert(dialog);
End Check: 3
LINE TO PARSE FOR KEYWORD:            test->scriptalert(dialog);
The real line: +            break;
End Check: 3
LINE TO PARSE FOR KEYWORD:            break;
The real line: +        case WEBKIT_SCRIPT_DIALOG_CONFIRM:
End Check: 3
LINE TO PARSE FOR KEYWORD:        case webkit_script_dialog_confirm:
The real line: +            test->scriptConfirm(dialog);
End Check: 3
LINE TO PARSE FOR KEYWORD:            test->scriptconfirm(dialog);
The real line: +            break;
End Check: 3
LINE TO PARSE FOR KEYWORD:            break;
The real line: +        case WEBKIT_SCRIPT_DIALOG_PROMPT:
End Check: 3
LINE TO PARSE FOR KEYWORD:        case webkit_script_dialog_prompt:
The real line: +            test->scriptPrompt(dialog);
End Check: 3
LINE TO PARSE FOR KEYWORD:            test->scriptprompt(dialog);
The real line: +            break;
End Check: 3
LINE TO PARSE FOR KEYWORD:            break;
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        return TRUE;
End Check: 2
LINE TO PARSE FOR KEYWORD:        return true;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
145 : 159
Next: (WebKitWebView*, WebKitScriptDialog* dialog, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static void mouseTargetChanged(WebKitWebView*, WebKitHitTestResult* hitTestResult, guint modifiers, UIClientTest* test)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static void mousetargetchanged(webkitwebview*, webkithittestresult* hittestresult, guint modifiers, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      static void mouseTargetChanged(WebKitWebView*, WebKitHitTestResult* hitTestResult, guint modifiers, UIClientTest* test) 
Checking if function:      static void mouseTargetChanged(WebKitWebView*, WebKitHitTestResult* hitTestResult, guint modifiers, UIClientTest* test)     {
PATTERN 1
Function:  void mouseTargetChanged(WebKitWebView*, WebKitHitTestResult* hitTestResult, guint modifiers, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert(WEBKIT_IS_HIT_TEST_RESULT(hitTestResult));
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(webkit_is_hit_test_result(hittestresult));
The real line: +        test->assertObjectIsDeletedWhenTestFinishes(G_OBJECT(hitTestResult));
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->assertobjectisdeletedwhentestfinishes(g_object(hittestresult));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        test->m_mouseTargetHitTestResult = hitTestResult;
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->m_mousetargethittestresult = hittestresult;
The real line: +        test->m_mouseTargetModifiers = modifiers;
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->m_mousetargetmodifiers = modifiers;
The real line: +        g_main_loop_quit(test->m_mainLoop);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_main_loop_quit(test->m_mainloop);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
162 : 169
Next: (WebKitWebView*, WebKitHitTestResult* hitTestResult, guint modifiers, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    static gboolean permissionRequested(WebKitWebView*, WebKitPermissionRequest* request, UIClientTest* test)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static gboolean permissionrequested(webkitwebview*, webkitpermissionrequest* request, uiclienttest* test)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      static gboolean permissionRequested(WebKitWebView*, WebKitPermissionRequest* request, UIClientTest* test) 
Checking if function:      static gboolean permissionRequested(WebKitWebView*, WebKitPermissionRequest* request, UIClientTest* test)     {
PATTERN 1
Function:  gboolean permissionRequested(WebKitWebView*, WebKitPermissionRequest* request, UIClientTest* test)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert(WEBKIT_IS_PERMISSION_REQUEST(request));
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(webkit_is_permission_request(request));
The real line: +        test->assertObjectIsDeletedWhenTestFinishes(G_OBJECT(request));
End Check: 2
LINE TO PARSE FOR KEYWORD:        test->assertobjectisdeletedwhentestfinishes(g_object(request));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        if (test->m_allowPermissionRequests)
End Check: 2
LINE TO PARSE FOR KEYWORD:        if (test->m_allowpermissionrequests)
The real line: +            webkit_permission_request_allow(request);
End Check: 2
LINE TO PARSE FOR KEYWORD:            webkit_permission_request_allow(request);
The real line: +        else
End Check: 2
LINE TO PARSE FOR KEYWORD:        else
The real line: +            webkit_permission_request_deny(request);
End Check: 2
LINE TO PARSE FOR KEYWORD:            webkit_permission_request_deny(request);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        return TRUE;
End Check: 2
LINE TO PARSE FOR KEYWORD:        return true;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
172 : 182
Next: (WebKitWebView*, WebKitPermissionRequest* request, UIClientTest* test)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    UIClientTest()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    uiclienttest()
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +        : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)
Current Name Search:      UIClientTest() 
LINE TO PARSE FOR KEYWORD:        : m_scriptdialogtype(webkit_script_dialog_alert)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +        , m_scriptDialogConfirmed(true)
Current Name Search:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT) 
LINE TO PARSE FOR KEYWORD:        , m_scriptdialogconfirmed(true)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +        , m_allowPermissionRequests(false)
Current Name Search:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true) 
LINE TO PARSE FOR KEYWORD:        , m_allowpermissionrequests(false)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +        , m_mouseTargetModifiers(0)
Current Name Search:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true)         , m_allowPermissionRequests(false) 
LINE TO PARSE FOR KEYWORD:        , m_mousetargetmodifiers(0)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true)         , m_allowPermissionRequests(false)         , m_mouseTargetModifiers(0) 
Checking if function:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true)         , m_allowPermissionRequests(false)         , m_mouseTargetModifiers(0)     {
Class context: uiclienttest
Checking if a constructor/destructor:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true)         , m_allowPermissionRequests(false)         , m_mouseTargetModifiers(0)     {
Function:      UIClientTest()         : m_scriptDialogType(WEBKIT_SCRIPT_DIALOG_ALERT)         , m_scriptDialogConfirmed(true)         , m_allowPermissionRequests(false)         , m_mouseTargetModifiers(0)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        webkit_settings_set_javascript_can_open_windows_automatically(webkit_web_view_get_settings(m_webView), TRUE);
End Check: 2
LINE TO PARSE FOR KEYWORD:        webkit_settings_set_javascript_can_open_windows_automatically(webkit_web_view_get_settings(m_webview), true);
The real line: +        g_signal_connect(m_webView, "create", G_CALLBACK(viewCreateCallback), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(m_webview, , g_callback(viewcreatecallback), this);
The real line: +        g_signal_connect(m_webView, "script-dialog", G_CALLBACK(scriptDialog), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(m_webview, , g_callback(scriptdialog), this);
The real line: +        g_signal_connect(m_webView, "mouse-target-changed", G_CALLBACK(mouseTargetChanged), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(m_webview, , g_callback(mousetargetchanged), this);
The real line: +        g_signal_connect(m_webView, "permission-request", G_CALLBACK(permissionRequested), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(m_webview, , g_callback(permissionrequested), this);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
189 : 195
Next: ()
Next: (WEBKIT_SCRIPT_DIALOG_ALERT)
Next: (true)
Next: (false)
Next: (0)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    ~UIClientTest()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    ~uiclienttest()
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      ~UIClientTest() 
Checking if function:      ~UIClientTest()     {
Class context: uiclienttest
Checking if a constructor/destructor:      ~UIClientTest()     {
Function:      ~UIClientTest()     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_signal_handlers_disconnect_matched(m_webView, G_SIGNAL_MATCH_DATA, 0, 0, 0, 0, this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_handlers_disconnect_matched(m_webview, g_signal_match_data, 0, 0, 0, 0, this);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
198 : 200
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    void waitUntilMainLoopFinishes()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    void waituntilmainloopfinishes()
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      void waitUntilMainLoopFinishes() 
Checking if function:      void waitUntilMainLoopFinishes()     {
PATTERN 4
Function: void waitUntilMainLoopFinishes()     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_main_loop_run(m_mainLoop);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_main_loop_run(m_mainloop);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
203 : 205
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    void setExpectedWindowProperties(const WindowProperties& windowProperties)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    void setexpectedwindowproperties(const windowproperties& windowproperties)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      void setExpectedWindowProperties(const WindowProperties& windowProperties) 
Checking if function:      void setExpectedWindowProperties(const WindowProperties& windowProperties)     {
PATTERN 4
Function: void setExpectedWindowProperties(const WindowProperties& windowProperties)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        m_windowProperties = windowProperties;
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_windowproperties = windowproperties;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
208 : 210
Next: (const WindowProperties& windowProperties)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    WebKitHitTestResult* moveMouseAndWaitUntilMouseTargetChanged(int x, int y, unsigned int mouseModifiers = 0)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    webkithittestresult* movemouseandwaituntilmousetargetchanged(int x, int y, unsigned int mousemodifiers = 0)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      WebKitHitTestResult* moveMouseAndWaitUntilMouseTargetChanged(int x, int y, unsigned int mouseModifiers = 0) 
Checking if function:      WebKitHitTestResult* moveMouseAndWaitUntilMouseTargetChanged(int x, int y, unsigned int mouseModifiers = 0)     {
Class context: uiclienttest
Checking if a constructor/destructor:      WebKitHitTestResult* moveMouseAndWaitUntilMouseTargetChanged(int x, int y, unsigned int mouseModifiers = 0)     {
Class context: windowproperties
Checking if a constructor/destructor:      WebKitHitTestResult* moveMouseAndWaitUntilMouseTargetChanged(int x, int y, unsigned int mouseModifiers = 0)     {
Other type of bracket:      WebKitHitTestResult* moveMouseAndWaitUntilMouseTargetChanged(int x, int y, unsigned int mouseModifiers = 0)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        mouseMoveTo(x, y, mouseModifiers);
Current Name Search: 
LINE TO PARSE FOR KEYWORD:        mousemoveto(x, y, mousemodifiers);
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        g_main_loop_run(m_mainLoop);
Current Name Search:         mouseMoveTo(x, y, mouseModifiers); 
LINE TO PARSE FOR KEYWORD:        g_main_loop_run(m_mainloop);
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +        return m_mouseTargetHitTestResult.get();
Current Name Search:         g_main_loop_run(m_mainLoop); 
LINE TO PARSE FOR KEYWORD:        return m_mousetargethittestresult.get();
Depths: 2:2
['uiclienttest', 'windowproperties']
The real line: +    }
Current Name Search:         return m_mouseTargetHitTestResult.get(); 
LINE TO PARSE FOR KEYWORD:    }
Depths: 1:2
['uiclienttest', 'windowproperties']
Adjusting depth.
The real line: +
Current Name Search:         return m_mouseTargetHitTestResult.get();     } 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    virtual GtkWidget* viewCreate(WebKitWebView* webView)
Current Name Search:         return m_mouseTargetHitTestResult.get();     }  
LINE TO PARSE FOR KEYWORD:    virtual gtkwidget* viewcreate(webkitwebview* webview)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:         return m_mouseTargetHitTestResult.get();     }      virtual GtkWidget* viewCreate(WebKitWebView* webView) 
Checking if function:         return m_mouseTargetHitTestResult.get();     }      virtual GtkWidget* viewCreate(WebKitWebView* webView)     {
PATTERN 1
Function:  GtkWidget* viewCreate(WebKitWebView* webView)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert(webView == m_webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(webview == m_webview);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        GtkWidget* newWebView = webkit_web_view_new_with_context(webkit_web_view_get_context(webView));
End Check: 2
LINE TO PARSE FOR KEYWORD:        gtkwidget* newwebview = webkit_web_view_new_with_context(webkit_web_view_get_context(webview));
The real line: +        g_object_ref_sink(newWebView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_object_ref_sink(newwebview);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        m_webViewEvents.append(Create);
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_webviewevents.append(create);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        WebKitWindowProperties* windowProperties = webkit_web_view_get_window_properties(WEBKIT_WEB_VIEW(newWebView));
End Check: 2
LINE TO PARSE FOR KEYWORD:        webkitwindowproperties* windowproperties = webkit_web_view_get_window_properties(webkit_web_view(newwebview));
The real line: +        g_assert(windowProperties);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(windowproperties);
The real line: +        assertObjectIsDeletedWhenTestFinishes(G_OBJECT(windowProperties));
End Check: 2
LINE TO PARSE FOR KEYWORD:        assertobjectisdeletedwhentestfinishes(g_object(windowproperties));
The real line: +        m_windowPropertiesChanged.clear();
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_windowpropertieschanged.clear();
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        g_signal_connect(windowProperties, "notify", G_CALLBACK(windowPropertiesNotifyCallback), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(windowproperties, , g_callback(windowpropertiesnotifycallback), this);
The real line: +        g_signal_connect(newWebView, "ready-to-show", G_CALLBACK(viewReadyToShowCallback), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(newwebview, , g_callback(viewreadytoshowcallback), this);
The real line: +        g_signal_connect(newWebView, "close", G_CALLBACK(viewCloseCallback), this);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_signal_connect(newwebview, , g_callback(viewclosecallback), this);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        return newWebView;
End Check: 2
LINE TO PARSE FOR KEYWORD:        return newwebview;
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
220 : 238
Next: (WebKitWebView* webView)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    virtual void viewReadyToShow(WebKitWebView* webView)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    virtual void viewreadytoshow(webkitwebview* webview)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      virtual void viewReadyToShow(WebKitWebView* webView) 
Checking if function:      virtual void viewReadyToShow(WebKitWebView* webView)     {
PATTERN 1
Function:  void viewReadyToShow(WebKitWebView* webView)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert(webView != m_webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(webview != m_webview);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        WebKitWindowProperties* windowProperties = webkit_web_view_get_window_properties(webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        webkitwindowproperties* windowproperties = webkit_web_view_get_window_properties(webview);
The real line: +        g_assert(windowProperties);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(windowproperties);
The real line: +        if (!m_windowProperties.isNull())
End Check: 2
LINE TO PARSE FOR KEYWORD:        if (!m_windowproperties.isnull())
The real line: +            WindowProperties(windowProperties).assertEqual(m_windowProperties);
End Check: 2
LINE TO PARSE FOR KEYWORD:            windowproperties(windowproperties).assertequal(m_windowproperties);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        m_webViewEvents.append(ReadyToShow);
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_webviewevents.append(readytoshow);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
241 : 250
Next: (WebKitWebView* webView)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    virtual void viewClose(WebKitWebView* webView)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    virtual void viewclose(webkitwebview* webview)
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    {
Current Name Search:      virtual void viewClose(WebKitWebView* webView) 
Checking if function:      virtual void viewClose(WebKitWebView* webView)     {
PATTERN 1
Function:  void viewClose(WebKitWebView* webView)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 2:1
['uiclienttest', 'windowproperties']
The real line: +        g_assert(webView != m_webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_assert(webview != m_webview);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        m_webViewEvents.append(Close);
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_webviewevents.append(close);
The real line: +     .   g_object_unref(webView);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_object_unref(webview);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +        g_main_loop_quit(m_mainLoop);
End Check: 2
LINE TO PARSE FOR KEYWORD:        g_main_loop_quit(m_mainloop);
The real line: +    }
End Check: 1
LINE TO PARSE FOR KEYWORD:    }
253 : 260
Next: (WebKitWebView* webView)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    Vector<WebViewEvents> m_webViewEvents;
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    vector<webviewevents> m_webviewevents;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    WebKitScriptDialogType m_scriptDialogType;
Current Name Search:     Vector<WebViewEvents> m_webViewEvents; 
LINE TO PARSE FOR KEYWORD:    webkitscriptdialogtype m_scriptdialogtype;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    bool m_scriptDialogConfirmed;
Current Name Search:     WebKitScriptDialogType m_scriptDialogType; 
LINE TO PARSE FOR KEYWORD:    bool m_scriptdialogconfirmed;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    bool m_allowPermissionRequests;
Current Name Search:     bool m_scriptDialogConfirmed; 
LINE TO PARSE FOR KEYWORD:    bool m_allowpermissionrequests;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    WindowProperties m_windowProperties;
Current Name Search:     bool m_allowPermissionRequests; 
LINE TO PARSE FOR KEYWORD:    windowproperties m_windowproperties;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    HashSet<WTF::String> m_windowPropertiesChanged;
Current Name Search:     WindowProperties m_windowProperties; 
LINE TO PARSE FOR KEYWORD:    hashset<wtf::string> m_windowpropertieschanged;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    GRefPtr<WebKitHitTestResult> m_mouseTargetHitTestResult;
Current Name Search:     HashSet<WTF::String> m_windowPropertiesChanged; 
LINE TO PARSE FOR KEYWORD:    grefptr<webkithittestresult> m_mousetargethittestresult;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +    unsigned int m_mouseTargetModifiers;
Current Name Search:     GRefPtr<WebKitHitTestResult> m_mouseTargetHitTestResult; 
LINE TO PARSE FOR KEYWORD:    unsigned int m_mousetargetmodifiers;
Depths: 1:1
['uiclienttest', 'windowproperties']
The real line: +};
Current Name Search:     unsigned int m_mouseTargetModifiers; 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
['uiclienttest', 'windowproperties']
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['uiclienttest', 'windowproperties']
Chunk End.
The real line: +#define	JEMALLOC_ARENA_C_
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#define	jemalloc_arena_c_
Depths: 0:0
[]
The real line: +#include "jemalloc/internal/jemalloc_internal.h"
Current Name Search: #define	JEMALLOC_ARENA_C_ 
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search: #define	JEMALLOC_ARENA_C_ #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/******************************************************************************/
Current Name Search: #define	JEMALLOC_ARENA_C_ #include   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Data. */
Current Name Search: #define	JEMALLOC_ARENA_C_ #include    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: #define	JEMALLOC_ARENA_C_ #include     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +size_t	opt_lg_qspace_max = LG_QSPACE_MAX_DEFAULT;
Current Name Search: #define	JEMALLOC_ARENA_C_ #include      
LINE TO PARSE FOR KEYWORD:size_t	opt_lg_qspace_max = lg_qspace_max_default;
Depths: 0:0
[]
The real line: +size_t	opt_lg_cspace_max = LG_CSPACE_MAX_DEFAULT;
Current Name Search: size_t	opt_lg_qspace_max = LG_QSPACE_MAX_DEFAULT; 
LINE TO PARSE FOR KEYWORD:size_t	opt_lg_cspace_max = lg_cspace_max_default;
Depths: 0:0
[]
The real line: +ssize_t		opt_lg_dirty_mult = LG_DIRTY_MULT_DEFAULT;
Current Name Search: size_t	opt_lg_cspace_max = LG_CSPACE_MAX_DEFAULT; 
LINE TO PARSE FOR KEYWORD:ssize_t		opt_lg_dirty_mult = lg_dirty_mult_default;
Depths: 0:0
[]
The real line: +uint8_t const	*small_size2bin;
Current Name Search: ssize_t		opt_lg_dirty_mult = LG_DIRTY_MULT_DEFAULT; 
LINE TO PARSE FOR KEYWORD:uint8_t const	*small_size2bin;
Depths: 0:0
[]
The real line: +
Current Name Search: uint8_t const	*small_size2bin; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Various bin-related settings. */
Current Name Search: uint8_t const	*small_size2bin;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +unsigned	nqbins;
Current Name Search: uint8_t const	*small_size2bin;   
LINE TO PARSE FOR KEYWORD:unsigned	nqbins;
Depths: 0:0
[]
The real line: +unsigned	ncbins;
Current Name Search: unsigned	nqbins; 
LINE TO PARSE FOR KEYWORD:unsigned	ncbins;
Depths: 0:0
[]
The real line: +unsigned	nsbins;
Current Name Search: unsigned	ncbins; 
LINE TO PARSE FOR KEYWORD:unsigned	nsbins;
Depths: 0:0
[]
The real line: +unsigned	nbins;
Current Name Search: unsigned	nsbins; 
LINE TO PARSE FOR KEYWORD:unsigned	nbins;
Depths: 0:0
[]
The real line: +size_t		qspace_max;
Current Name Search: unsigned	nbins; 
LINE TO PARSE FOR KEYWORD:size_t		qspace_max;
Depths: 0:0
[]
The real line: +size_t		cspace_min;
Current Name Search: size_t		qspace_max; 
LINE TO PARSE FOR KEYWORD:size_t		cspace_min;
Depths: 0:0
[]
The real line: +size_t		cspace_max;
Current Name Search: size_t		cspace_min; 
LINE TO PARSE FOR KEYWORD:size_t		cspace_max;
Depths: 0:0
[]
The real line: +size_t		sspace_min;
Current Name Search: size_t		cspace_max; 
LINE TO PARSE FOR KEYWORD:size_t		sspace_min;
Depths: 0:0
[]
The real line: +size_t		sspace_max;
Current Name Search: size_t		sspace_min; 
LINE TO PARSE FOR KEYWORD:size_t		sspace_max;
Depths: 0:0
[]
The real line: +
Current Name Search: size_t		sspace_max; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +size_t		lg_mspace;
Current Name Search: size_t		sspace_max;  
LINE TO PARSE FOR KEYWORD:size_t		lg_mspace;
Depths: 0:0
[]
The real line: +size_t		mspace_mask;
Current Name Search: size_t		lg_mspace; 
LINE TO PARSE FOR KEYWORD:size_t		mspace_mask;
Depths: 0:0
[]
The real line: +
Current Name Search: size_t		mspace_mask; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search: size_t		mspace_mask;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * const_small_size2bin is a static constant lookup table that in the common
The real line: + * case can be used as-is for small_size2bin.  For dynamically linked programs,
The real line: + * this avoids a page of memory overhead per process.
The real line: + */
The real line: +#define	S2B_1(i)	i,
Current Name Search: size_t		mspace_mask;   
LINE TO PARSE FOR KEYWORD:#define	s2b_1(i)	i,
Depths: 0:0
[]
The real line: +#define	S2B_2(i)	S2B_1(i) S2B_1(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, 
LINE TO PARSE FOR KEYWORD:#define	s2b_2(i)	s2b_1(i) s2b_1(i)
Depths: 0:0
[]
The real line: +#define	S2B_4(i)	S2B_2(i) S2B_2(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_4(i)	s2b_2(i) s2b_2(i)
Depths: 0:0
[]
The real line: +#define	S2B_8(i)	S2B_4(i) S2B_4(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_8(i)	s2b_4(i) s2b_4(i)
Depths: 0:0
[]
The real line: +#define	S2B_16(i)	S2B_8(i) S2B_8(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_16(i)	s2b_8(i) s2b_8(i)
Depths: 0:0
[]
The real line: +#define	S2B_32(i)	S2B_16(i) S2B_16(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_32(i)	s2b_16(i) s2b_16(i)
Depths: 0:0
[]
The real line: +#define	S2B_64(i)	S2B_32(i) S2B_32(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_64(i)	s2b_32(i) s2b_32(i)
Depths: 0:0
[]
The real line: +#define	S2B_128(i)	S2B_64(i) S2B_64(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) #define	S2B_64(i)	S2B_32(i) S2B_32(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_128(i)	s2b_64(i) s2b_64(i)
Depths: 0:0
[]
The real line: +#define	S2B_256(i)	S2B_128(i) S2B_128(i)
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) #define	S2B_64(i)	S2B_32(i) S2B_32(i) #define	S2B_128(i)	S2B_64(i) S2B_64(i) 
LINE TO PARSE FOR KEYWORD:#define	s2b_256(i)	s2b_128(i) s2b_128(i)
Depths: 0:0
[]
The real line: +/*
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) #define	S2B_64(i)	S2B_32(i) S2B_32(i) #define	S2B_128(i)	S2B_64(i) S2B_64(i) #define	S2B_256(i)	S2B_128(i) S2B_128(i) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * The number of elements in const_small_size2bin is dependent on page size
The real line: + * and on the definition for SUBPAGE.  If SUBPAGE changes, the '- 255' must also
The real line: + * change, along with the addition/removal of static lookup table element
The real line: + * definitions.
The real line: + */
The real line: +static const uint8_t	const_small_size2bin[STATIC_PAGE_SIZE - 255] = {
Current Name Search: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) #define	S2B_64(i)	S2B_32(i) S2B_32(i) #define	S2B_128(i)	S2B_64(i) S2B_64(i) #define	S2B_256(i)	S2B_128(i) S2B_128(i)  
Checking if function: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) #define	S2B_64(i)	S2B_32(i) S2B_32(i) #define	S2B_128(i)	S2B_64(i) S2B_64(i) #define	S2B_256(i)	S2B_128(i) S2B_128(i)  static const uint8_t	const_small_size2bin[STATIC_PAGE_SIZE - 255] = {
Other type of bracket: size_t		mspace_mask;   #define	S2B_1(i)	i, #define	S2B_2(i)	S2B_1(i) S2B_1(i) #define	S2B_4(i)	S2B_2(i) S2B_2(i) #define	S2B_8(i)	S2B_4(i) S2B_4(i) #define	S2B_16(i)	S2B_8(i) S2B_8(i) #define	S2B_32(i)	S2B_16(i) S2B_16(i) #define	S2B_64(i)	S2B_32(i) S2B_32(i) #define	S2B_128(i)	S2B_64(i) S2B_64(i) #define	S2B_256(i)	S2B_128(i) S2B_128(i)  static const uint8_t	const_small_size2bin[STATIC_PAGE_SIZE - 255] = {
LINE TO PARSE FOR KEYWORD:static const uint8_t	const_small_size2bin[static_page_size - 255] = {
Depths: 1:1
[]
The real line: +	S2B_1(0xffU)		/*    0 */
Current Name Search: 
LINE TO PARSE FOR KEYWORD:	s2b_1(0xffu)		
Depths: 1:1
[]
The real line: +#if (LG_QUANTUM == 4)
Current Name Search: 	S2B_1(0xffU)		 
LINE TO PARSE FOR KEYWORD:#if (lg_quantum == 4)
Depths: 1:1
[]
The real line: +/* 16-byte quantum **********************/
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4) 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#  ifdef JEMALLOC_TINY
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  
LINE TO PARSE FOR KEYWORD:#  ifdef jemalloc_tiny
Depths: 1:1
[]
The real line: +#    if (LG_TINY_MIN == 2)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY 
LINE TO PARSE FOR KEYWORD:#    if (lg_tiny_min == 2)
Depths: 1:1
[]
The real line: +       S2B_4(0)			/*    4 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2) 
LINE TO PARSE FOR KEYWORD:       s2b_4(0)			
Depths: 1:1
[]
The real line: +       S2B_4(1)			/*    8 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			 
LINE TO PARSE FOR KEYWORD:       s2b_4(1)			
Depths: 1:1
[]
The real line: +       S2B_8(2)			/*   16 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 
LINE TO PARSE FOR KEYWORD:       s2b_8(2)			
Depths: 1:1
[]
The real line: +#      define S2B_QMIN 2
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 
LINE TO PARSE FOR KEYWORD:#      define s2b_qmin 2
Depths: 1:1
[]
The real line: +#    elif (LG_TINY_MIN == 3)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 
LINE TO PARSE FOR KEYWORD:#    elif (lg_tiny_min == 3)
Depths: 1:1
[]
The real line: +       S2B_8(0)			/*    8 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3) 
LINE TO PARSE FOR KEYWORD:       s2b_8(0)			
Depths: 1:1
[]
The real line: +       S2B_8(1)			/*   16 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			 
LINE TO PARSE FOR KEYWORD:       s2b_8(1)			
Depths: 1:1
[]
The real line: +#      define S2B_QMIN 1
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 
LINE TO PARSE FOR KEYWORD:#      define s2b_qmin 1
Depths: 1:1
[]
The real line: +#    else
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 
LINE TO PARSE FOR KEYWORD:#    else
Depths: 1:1
[]
The real line: +#      error "Unsupported LG_TINY_MIN"
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else 
LINE TO PARSE FOR KEYWORD:#      error 
Depths: 1:1
[]
The real line: +#    endif
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  
LINE TO PARSE FOR KEYWORD:#    endif
Depths: 1:1
[]
The real line: +#  else
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif 
LINE TO PARSE FOR KEYWORD:#  else
Depths: 1:1
[]
The real line: +	S2B_16(0)		/*   16 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 
LINE TO PARSE FOR KEYWORD:	s2b_16(0)		
Depths: 1:1
[]
The real line: +#    define S2B_QMIN 0
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 
LINE TO PARSE FOR KEYWORD:#    define s2b_qmin 0
Depths: 1:1
[]
The real line: +#  endif
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 
LINE TO PARSE FOR KEYWORD:#  endif
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 1)	/*   32 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 1)	
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 2)	/*   48 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 2)	
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 3)	/*   64 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 3)	
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 4)	/*   80 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 4)	
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 5)	/*   96 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 5)	
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 6)	/*  112 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 6)	
Depths: 1:1
[]
The real line: +	S2B_16(S2B_QMIN + 7)	/*  128 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 
LINE TO PARSE FOR KEYWORD:	s2b_16(s2b_qmin + 7)	
Depths: 1:1
[]
The real line: +#  define S2B_CMIN (S2B_QMIN + 8)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 
LINE TO PARSE FOR KEYWORD:#  define s2b_cmin (s2b_qmin + 8)
Depths: 1:1
[]
The real line: +#else
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) 
LINE TO PARSE FOR KEYWORD:#else
Depths: 1:1
[]
The real line: +/* 8-byte quantum ***********************/
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +#  ifdef JEMALLOC_TINY
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  
LINE TO PARSE FOR KEYWORD:#  ifdef jemalloc_tiny
Depths: 1:1
[]
The real line: +#    if (LG_TINY_MIN == 2)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY 
LINE TO PARSE FOR KEYWORD:#    if (lg_tiny_min == 2)
Depths: 1:1
[]
The real line: +       S2B_4(0)			/*    4 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2) 
LINE TO PARSE FOR KEYWORD:       s2b_4(0)			
Depths: 1:1
[]
The real line: +       S2B_4(1)			/*    8 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			 
LINE TO PARSE FOR KEYWORD:       s2b_4(1)			
Depths: 1:1
[]
The real line: +#      define S2B_QMIN 1
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 
LINE TO PARSE FOR KEYWORD:#      define s2b_qmin 1
Depths: 1:1
[]
The real line: +#    else
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 
LINE TO PARSE FOR KEYWORD:#    else
Depths: 1:1
[]
The real line: +#      error "Unsupported LG_TINY_MIN"
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else 
LINE TO PARSE FOR KEYWORD:#      error 
Depths: 1:1
[]
The real line: +#    endif
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  
LINE TO PARSE FOR KEYWORD:#    endif
Depths: 1:1
[]
The real line: +#  else
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif 
LINE TO PARSE FOR KEYWORD:#  else
Depths: 1:1
[]
The real line: +	S2B_8(0)		/*    8 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 
LINE TO PARSE FOR KEYWORD:	s2b_8(0)		
Depths: 1:1
[]
The real line: +#    define S2B_QMIN 0
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 
LINE TO PARSE FOR KEYWORD:#    define s2b_qmin 0
Depths: 1:1
[]
The real line: +#  endif
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 
LINE TO PARSE FOR KEYWORD:#  endif
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 1)	/*   16 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 1)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 2)	/*   24 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 2)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 3)	/*   32 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 3)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 4)	/*   40 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 4)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 5)	/*   48 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 5)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 6)	/*   56 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 6)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 7)	/*   64 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 7)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 8)	/*   72 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 8)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 9)	/*   80 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 9)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 10)	/*   88 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 10)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 11)	/*   96 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 11)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 12)	/*  104 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 12)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 13)	/*  112 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 13)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 14)	/*  120 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 14)	
Depths: 1:1
[]
The real line: +	S2B_8(S2B_QMIN + 15)	/*  128 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 
LINE TO PARSE FOR KEYWORD:	s2b_8(s2b_qmin + 15)	
Depths: 1:1
[]
The real line: +#  define S2B_CMIN (S2B_QMIN + 16)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 
LINE TO PARSE FOR KEYWORD:#  define s2b_cmin (s2b_qmin + 16)
Depths: 1:1
[]
The real line: +#endif
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +/****************************************/
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +	S2B_64(S2B_CMIN + 0)	/*  192 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  
LINE TO PARSE FOR KEYWORD:	s2b_64(s2b_cmin + 0)	
Depths: 1:1
[]
The real line: +	S2B_64(S2B_CMIN + 1)	/*  256 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 
LINE TO PARSE FOR KEYWORD:	s2b_64(s2b_cmin + 1)	
Depths: 1:1
[]
The real line: +	S2B_64(S2B_CMIN + 2)	/*  320 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 
LINE TO PARSE FOR KEYWORD:	s2b_64(s2b_cmin + 2)	
Depths: 1:1
[]
The real line: +	S2B_64(S2B_CMIN + 3)	/*  384 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 
LINE TO PARSE FOR KEYWORD:	s2b_64(s2b_cmin + 3)	
Depths: 1:1
[]
The real line: +	S2B_64(S2B_CMIN + 4)	/*  448 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 
LINE TO PARSE FOR KEYWORD:	s2b_64(s2b_cmin + 4)	
Depths: 1:1
[]
The real line: +	S2B_64(S2B_CMIN + 5)	/*  512 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 
LINE TO PARSE FOR KEYWORD:	s2b_64(s2b_cmin + 5)	
Depths: 1:1
[]
The real line: +#  define S2B_SMIN (S2B_CMIN + 6)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 
LINE TO PARSE FOR KEYWORD:#  define s2b_smin (s2b_cmin + 6)
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 0)	/*  768 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 0)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 1)	/* 1024 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 1)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 2)	/* 1280 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 2)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 3)	/* 1536 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 3)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 4)	/* 1792 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 4)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 5)	/* 2048 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 5)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 6)	/* 2304 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 6)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 7)	/* 2560 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 7)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 8)	/* 2816 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 8)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 9)	/* 3072 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 9)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 10)	/* 3328 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 10)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 11)	/* 3584 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 11)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 12)	/* 3840 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 12)	
Depths: 1:1
[]
The real line: +#if (STATIC_PAGE_SHIFT == 13)
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 
LINE TO PARSE FOR KEYWORD:#if (static_page_shift == 13)
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 13)	/* 4096 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 13)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 14)	/* 4352 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 14)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 15)	/* 4608 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 15)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 16)	/* 4864 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 16)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 17)	/* 5120 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 17)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 18)	/* 5376 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 18)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 19)	/* 5632 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 19)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 20)	/* 5888 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 20)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 21)	/* 6144 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 21)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 22)	/* 6400 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 22)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 23)	/* 6656 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 23)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 24)	/* 6912 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 24)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 25)	/* 7168 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 	S2B_256(S2B_SMIN + 24)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 25)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 26)	/* 7424 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 	S2B_256(S2B_SMIN + 24)	 	S2B_256(S2B_SMIN + 25)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 26)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 27)	/* 7680 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 	S2B_256(S2B_SMIN + 24)	 	S2B_256(S2B_SMIN + 25)	 	S2B_256(S2B_SMIN + 26)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 27)	
Depths: 1:1
[]
The real line: +	S2B_256(S2B_SMIN + 28)	/* 7936 */
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 	S2B_256(S2B_SMIN + 24)	 	S2B_256(S2B_SMIN + 25)	 	S2B_256(S2B_SMIN + 26)	 	S2B_256(S2B_SMIN + 27)	 
LINE TO PARSE FOR KEYWORD:	s2b_256(s2b_smin + 28)	
Depths: 1:1
[]
The real line: +#endif
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 	S2B_256(S2B_SMIN + 24)	 	S2B_256(S2B_SMIN + 25)	 	S2B_256(S2B_SMIN + 26)	 	S2B_256(S2B_SMIN + 27)	 	S2B_256(S2B_SMIN + 28)	 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 1:1
[]
The real line: +};
Current Name Search: 	S2B_1(0xffU)		 #if (LG_QUANTUM == 4)  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			        S2B_8(2)			 #      define S2B_QMIN 2 #    elif (LG_TINY_MIN == 3)        S2B_8(0)			        S2B_8(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_16(0)		 #    define S2B_QMIN 0 #  endif 	S2B_16(S2B_QMIN + 1)	 	S2B_16(S2B_QMIN + 2)	 	S2B_16(S2B_QMIN + 3)	 	S2B_16(S2B_QMIN + 4)	 	S2B_16(S2B_QMIN + 5)	 	S2B_16(S2B_QMIN + 6)	 	S2B_16(S2B_QMIN + 7)	 #  define S2B_CMIN (S2B_QMIN + 8) #else  #  ifdef JEMALLOC_TINY #    if (LG_TINY_MIN == 2)        S2B_4(0)			        S2B_4(1)			 #      define S2B_QMIN 1 #    else #      error  #    endif #  else 	S2B_8(0)		 #    define S2B_QMIN 0 #  endif 	S2B_8(S2B_QMIN + 1)	 	S2B_8(S2B_QMIN + 2)	 	S2B_8(S2B_QMIN + 3)	 	S2B_8(S2B_QMIN + 4)	 	S2B_8(S2B_QMIN + 5)	 	S2B_8(S2B_QMIN + 6)	 	S2B_8(S2B_QMIN + 7)	 	S2B_8(S2B_QMIN + 8)	 	S2B_8(S2B_QMIN + 9)	 	S2B_8(S2B_QMIN + 10)	 	S2B_8(S2B_QMIN + 11)	 	S2B_8(S2B_QMIN + 12)	 	S2B_8(S2B_QMIN + 13)	 	S2B_8(S2B_QMIN + 14)	 	S2B_8(S2B_QMIN + 15)	 #  define S2B_CMIN (S2B_QMIN + 16) #endif  	S2B_64(S2B_CMIN + 0)	 	S2B_64(S2B_CMIN + 1)	 	S2B_64(S2B_CMIN + 2)	 	S2B_64(S2B_CMIN + 3)	 	S2B_64(S2B_CMIN + 4)	 	S2B_64(S2B_CMIN + 5)	 #  define S2B_SMIN (S2B_CMIN + 6) 	S2B_256(S2B_SMIN + 0)	 	S2B_256(S2B_SMIN + 1)	 	S2B_256(S2B_SMIN + 2)	 	S2B_256(S2B_SMIN + 3)	 	S2B_256(S2B_SMIN + 4)	 	S2B_256(S2B_SMIN + 5)	 	S2B_256(S2B_SMIN + 6)	 	S2B_256(S2B_SMIN + 7)	 	S2B_256(S2B_SMIN + 8)	 	S2B_256(S2B_SMIN + 9)	 	S2B_256(S2B_SMIN + 10)	 	S2B_256(S2B_SMIN + 11)	 	S2B_256(S2B_SMIN + 12)	 #if (STATIC_PAGE_SHIFT == 13) 	S2B_256(S2B_SMIN + 13)	 	S2B_256(S2B_SMIN + 14)	 	S2B_256(S2B_SMIN + 15)	 	S2B_256(S2B_SMIN + 16)	 	S2B_256(S2B_SMIN + 17)	 	S2B_256(S2B_SMIN + 18)	 	S2B_256(S2B_SMIN + 19)	 	S2B_256(S2B_SMIN + 20)	 	S2B_256(S2B_SMIN + 21)	 	S2B_256(S2B_SMIN + 22)	 	S2B_256(S2B_SMIN + 23)	 	S2B_256(S2B_SMIN + 24)	 	S2B_256(S2B_SMIN + 25)	 	S2B_256(S2B_SMIN + 26)	 	S2B_256(S2B_SMIN + 27)	 	S2B_256(S2B_SMIN + 28)	 #endif 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
[]
Adjusting depth.
The real line: +#undef S2B_1
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:#undef s2b_1
Depths: 0:0
[]
The real line: +#undef S2B_2
Current Name Search: }; #undef S2B_1 
LINE TO PARSE FOR KEYWORD:#undef s2b_2
Depths: 0:0
[]
The real line: +#undef S2B_4
Current Name Search: }; #undef S2B_1 #undef S2B_2 
LINE TO PARSE FOR KEYWORD:#undef s2b_4
Depths: 0:0
[]
The real line: +#undef S2B_8
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 
LINE TO PARSE FOR KEYWORD:#undef s2b_8
Depths: 0:0
[]
The real line: +#undef S2B_16
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 
LINE TO PARSE FOR KEYWORD:#undef s2b_16
Depths: 0:0
[]
The real line: +#undef S2B_32
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 
LINE TO PARSE FOR KEYWORD:#undef s2b_32
Depths: 0:0
[]
The real line: +#undef S2B_64
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 
LINE TO PARSE FOR KEYWORD:#undef s2b_64
Depths: 0:0
[]
The real line: +#undef S2B_128
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 
LINE TO PARSE FOR KEYWORD:#undef s2b_128
Depths: 0:0
[]
The real line: +#undef S2B_256
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 
LINE TO PARSE FOR KEYWORD:#undef s2b_256
Depths: 0:0
[]
The real line: +#undef S2B_QMIN
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 
LINE TO PARSE FOR KEYWORD:#undef s2b_qmin
Depths: 0:0
[]
The real line: +#undef S2B_CMIN
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN 
LINE TO PARSE FOR KEYWORD:#undef s2b_cmin
Depths: 0:0
[]
The real line: +#undef S2B_SMIN
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN 
LINE TO PARSE FOR KEYWORD:#undef s2b_smin
Depths: 0:0
[]
The real line: +
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN #undef S2B_SMIN 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/******************************************************************************/
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN #undef S2B_SMIN  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Function prototypes for non-inline static functions. */
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN #undef S2B_SMIN   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN #undef S2B_SMIN    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void	arena_run_split(arena_t *arena, arena_run_t *run, size_t size,
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN #undef S2B_SMIN     
LINE TO PARSE FOR KEYWORD:static void	arena_run_split(arena_t *arena, arena_run_t *run, size_t size,
Depths: 0:0
[]
The real line: +    bool large, bool zero);
Current Name Search: }; #undef S2B_1 #undef S2B_2 #undef S2B_4 #undef S2B_8 #undef S2B_16 #undef S2B_32 #undef S2B_64 #undef S2B_128 #undef S2B_256 #undef S2B_QMIN #undef S2B_CMIN #undef S2B_SMIN     static void	arena_run_split(arena_t *arena, arena_run_t *run, size_t size, 
LINE TO PARSE FOR KEYWORD:    bool large, bool zero);
Depths: 0:0
[]
The real line: +static arena_chunk_t *arena_chunk_alloc(arena_t *arena);
Current Name Search:     bool large, bool zero); 
LINE TO PARSE FOR KEYWORD:static arena_chunk_t *arena_chunk_alloc(arena_t *arena);
Depths: 0:0
[]
The real line: +static void	arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk);
Current Name Search: static arena_chunk_t *arena_chunk_alloc(arena_t *arena); 
LINE TO PARSE FOR KEYWORD:static void	arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk);
Depths: 0:0
[]
The real line: +static arena_run_t *arena_run_alloc(arena_t *arena, size_t size, bool large,
Current Name Search: static void	arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk); 
LINE TO PARSE FOR KEYWORD:static arena_run_t *arena_run_alloc(arena_t *arena, size_t size, bool large,
Depths: 0:0
[]
The real line: +    bool zero);
Current Name Search: static void	arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk); static arena_run_t *arena_run_alloc(arena_t *arena, size_t size, bool large, 
LINE TO PARSE FOR KEYWORD:    bool zero);
Depths: 0:0
[]
The real line: +static void	arena_purge(arena_t *arena);
Current Name Search:     bool zero); 
LINE TO PARSE FOR KEYWORD:static void	arena_purge(arena_t *arena);
Depths: 0:0
[]
The real line: +static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty);
Current Name Search: static void	arena_purge(arena_t *arena); 
LINE TO PARSE FOR KEYWORD:static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty);
Depths: 0:0
[]
The real line: +static void	arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk,
Current Name Search: static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty); 
LINE TO PARSE FOR KEYWORD:static void	arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk,
Depths: 0:0
[]
The real line: +    arena_run_t *run, size_t oldsize, size_t newsize);
Current Name Search: static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty); static void	arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, 
LINE TO PARSE FOR KEYWORD:    arena_run_t *run, size_t oldsize, size_t newsize);
Depths: 0:0
[]
The real line: +static void	arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk,
Current Name Search:     arena_run_t *run, size_t oldsize, size_t newsize); 
LINE TO PARSE FOR KEYWORD:static void	arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk,
Depths: 0:0
[]
The real line: +    arena_run_t *run, size_t oldsize, size_t newsize, bool dirty);
Current Name Search:     arena_run_t *run, size_t oldsize, size_t newsize); static void	arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, 
LINE TO PARSE FOR KEYWORD:    arena_run_t *run, size_t oldsize, size_t newsize, bool dirty);
Depths: 0:0
[]
The real line: +static arena_run_t *arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin);
Current Name Search:     arena_run_t *run, size_t oldsize, size_t newsize, bool dirty); 
LINE TO PARSE FOR KEYWORD:static arena_run_t *arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin);
Depths: 0:0
[]
The real line: +static void	*arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin);
Current Name Search: static arena_run_t *arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin); 
LINE TO PARSE FOR KEYWORD:static void	*arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin);
Depths: 0:0
[]
The real line: +static size_t	arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size);
Current Name Search: static void	*arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin); 
LINE TO PARSE FOR KEYWORD:static size_t	arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size);
Depths: 0:0
[]
The real line: +static void	arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk,
Current Name Search: static size_t	arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size); 
LINE TO PARSE FOR KEYWORD:static void	arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk,
Depths: 0:0
[]
The real line: +    arena_run_t *run, arena_bin_t *bin);
Current Name Search: static size_t	arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size); static void	arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, 
LINE TO PARSE FOR KEYWORD:    arena_run_t *run, arena_bin_t *bin);
Depths: 0:0
[]
The real line: +static void	arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk,
Current Name Search:     arena_run_t *run, arena_bin_t *bin); 
LINE TO PARSE FOR KEYWORD:static void	arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk,
Depths: 0:0
[]
The real line: +    void *ptr, size_t size, size_t oldsize);
Current Name Search:     arena_run_t *run, arena_bin_t *bin); static void	arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, 
LINE TO PARSE FOR KEYWORD:    void *ptr, size_t size, size_t oldsize);
Depths: 0:0
[]
The real line: +static bool	arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk,
Current Name Search:     void *ptr, size_t size, size_t oldsize); 
LINE TO PARSE FOR KEYWORD:static bool	arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk,
Depths: 0:0
[]
The real line: +    void *ptr, size_t size, size_t oldsize);
Current Name Search:     void *ptr, size_t size, size_t oldsize); static bool	arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, 
LINE TO PARSE FOR KEYWORD:    void *ptr, size_t size, size_t oldsize);
Depths: 0:0
[]
The real line: +static bool	arena_ralloc_large(void *ptr, size_t size, size_t oldsize);
Current Name Search:     void *ptr, size_t size, size_t oldsize); 
LINE TO PARSE FOR KEYWORD:static bool	arena_ralloc_large(void *ptr, size_t size, size_t oldsize);
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_TINY
Current Name Search: static bool	arena_ralloc_large(void *ptr, size_t size, size_t oldsize); 
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tiny
Depths: 0:0
[]
The real line: +static size_t	pow2_ceil(size_t x);
Current Name Search: static bool	arena_ralloc_large(void *ptr, size_t size, size_t oldsize); #ifdef JEMALLOC_TINY 
LINE TO PARSE FOR KEYWORD:static size_t	pow2_ceil(size_t x);
Depths: 0:0
[]
The real line: +#endif
Current Name Search: static size_t	pow2_ceil(size_t x); 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +static bool	small_size2bin_init(void);
Current Name Search: static size_t	pow2_ceil(size_t x); #endif 
LINE TO PARSE FOR KEYWORD:static bool	small_size2bin_init(void);
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_DEBUG
Current Name Search: static bool	small_size2bin_init(void); 
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
Depths: 0:0
[]
The real line: +static void	small_size2bin_validate(void);
Current Name Search: static bool	small_size2bin_init(void); #ifdef JEMALLOC_DEBUG 
LINE TO PARSE FOR KEYWORD:static void	small_size2bin_validate(void);
Depths: 0:0
[]
The real line: +#endif
Current Name Search: static void	small_size2bin_validate(void); 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +static bool	small_size2bin_init_hard(void);
Current Name Search: static void	small_size2bin_validate(void); #endif 
LINE TO PARSE FOR KEYWORD:static bool	small_size2bin_init_hard(void);
Depths: 0:0
[]
The real line: +
Current Name Search: static bool	small_size2bin_init_hard(void); 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/******************************************************************************/
Current Name Search: static bool	small_size2bin_init_hard(void);  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search: static bool	small_size2bin_init_hard(void);   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline int
Current Name Search: static bool	small_size2bin_init_hard(void);    
LINE TO PARSE FOR KEYWORD:static inline int
Depths: 0:0
[]
The real line: +arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
Current Name Search: static bool	small_size2bin_init_hard(void);    static inline int 
LINE TO PARSE FOR KEYWORD:arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
Depths: 0:0
[]
The real line: +{
Current Name Search: static bool	small_size2bin_init_hard(void);    static inline int arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b) 
Checking if function: static bool	small_size2bin_init_hard(void);    static inline int arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b) {
PATTERN 1
Function:  int arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	uintptr_t a_mapelm = (uintptr_t)a;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uintptr_t a_mapelm = (uintptr_t)a;
The real line: +	uintptr_t b_mapelm = (uintptr_t)b;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uintptr_t b_mapelm = (uintptr_t)b;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(a != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(a != null);
The real line: +	assert(b != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(b != null);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return ((a_mapelm > b_mapelm) - (a_mapelm < b_mapelm));
End Check: 1
LINE TO PARSE FOR KEYWORD:	return ((a_mapelm > b_mapelm) - (a_mapelm < b_mapelm));
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
197 : 205
Next: (arena_chunk_map_t *a, arena_chunk_map_t *b)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Generate red-black tree functions. */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t,
Current Name Search:   
LINE TO PARSE FOR KEYWORD:rb_gen(static jemalloc_attr(unused), arena_run_tree_, arena_run_tree_t,
Depths: 0:0
[]
The real line: +    arena_chunk_map_t, u.rb_link, arena_run_comp)
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t, 
LINE TO PARSE FOR KEYWORD:    arena_chunk_map_t, u.rb_link, arena_run_comp)
Depths: 0:0
[]
The real line: +
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t,     arena_chunk_map_t, u.rb_link, arena_run_comp) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline int
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t,     arena_chunk_map_t, u.rb_link, arena_run_comp)  
LINE TO PARSE FOR KEYWORD:static inline int
Depths: 0:0
[]
The real line: +arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t,     arena_chunk_map_t, u.rb_link, arena_run_comp)  static inline int 
LINE TO PARSE FOR KEYWORD:arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
Depths: 0:0
[]
The real line: +{
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t,     arena_chunk_map_t, u.rb_link, arena_run_comp)  static inline int arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b) 
Checking if function:   rb_gen(static JEMALLOC_ATTR(unused), arena_run_tree_, arena_run_tree_t,     arena_chunk_map_t, u.rb_link, arena_run_comp)  static inline int arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b) {
PATTERN 1
Function:  int arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	int ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	int ret;
The real line: +	size_t a_size = a->bits & ~PAGE_MASK;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t a_size = a->bits & ~page_mask;
The real line: +	size_t b_size = b->bits & ~PAGE_MASK;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t b_size = b->bits & ~page_mask;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert((a->bits & CHUNK_MAP_KEY) == CHUNK_MAP_KEY || (a->bits &
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((a->bits & chunk_map_key) == chunk_map_key || (a->bits &
The real line: +	    CHUNK_MAP_DIRTY) == (b->bits & CHUNK_MAP_DIRTY));
End Check: 1
LINE TO PARSE FOR KEYWORD:	    chunk_map_dirty) == (b->bits & chunk_map_dirty));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ret = (a_size > b_size) - (a_size < b_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = (a_size > b_size) - (a_size < b_size);
The real line: +	if (ret == 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (ret == 0) {
The real line: +		uintptr_t a_mapelm, b_mapelm;
End Check: 2
LINE TO PARSE FOR KEYWORD:		uintptr_t a_mapelm, b_mapelm;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if ((a->bits & CHUNK_MAP_KEY) != CHUNK_MAP_KEY)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if ((a->bits & chunk_map_key) != chunk_map_key)
The real line: +			a_mapelm = (uintptr_t)a;
End Check: 2
LINE TO PARSE FOR KEYWORD:			a_mapelm = (uintptr_t)a;
The real line: +		else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		else {
The real line: +			/*
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			 * Treat keys as though they are lower than anything
The real line: +			 * else.
The real line: +			 */
The real line: +			a_mapelm = 0;
End Check: 3
LINE TO PARSE FOR KEYWORD:			a_mapelm = 0;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		b_mapelm = (uintptr_t)b;
End Check: 2
LINE TO PARSE FOR KEYWORD:		b_mapelm = (uintptr_t)b;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ret = (a_mapelm > b_mapelm) - (a_mapelm < b_mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = (a_mapelm > b_mapelm) - (a_mapelm < b_mapelm);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
213 : 240
Next: (arena_chunk_map_t *a, arena_chunk_map_t *b)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Generate red-black tree functions. */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t,
Current Name Search:   
LINE TO PARSE FOR KEYWORD:rb_gen(static jemalloc_attr(unused), arena_avail_tree_, arena_avail_tree_t,
Depths: 0:0
[]
The real line: +    arena_chunk_map_t, u.rb_link, arena_avail_comp)
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t, 
LINE TO PARSE FOR KEYWORD:    arena_chunk_map_t, u.rb_link, arena_avail_comp)
Depths: 0:0
[]
The real line: +
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t,     arena_chunk_map_t, u.rb_link, arena_avail_comp) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline void *
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t,     arena_chunk_map_t, u.rb_link, arena_avail_comp)  
LINE TO PARSE FOR KEYWORD:static inline void *
Depths: 0:0
[]
The real line: +arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin)
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t,     arena_chunk_map_t, u.rb_link, arena_avail_comp)  static inline void * 
LINE TO PARSE FOR KEYWORD:arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin)
Depths: 0:0
[]
The real line: +{
Current Name Search:   rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t,     arena_chunk_map_t, u.rb_link, arena_avail_comp)  static inline void * arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin) 
Checking if function:   rb_gen(static JEMALLOC_ATTR(unused), arena_avail_tree_, arena_avail_tree_t,     arena_chunk_map_t, u.rb_link, arena_avail_comp)  static inline void * arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin) {
PATTERN 1
Function:  void * arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	void *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ret;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(run->magic == ARENA_RUN_MAGIC);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run->magic == arena_run_magic);
The real line: +	assert(run->nfree > 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run->nfree > 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	run->nfree--;
End Check: 1
LINE TO PARSE FOR KEYWORD:	run->nfree--;
The real line: +	ret = run->avail;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = run->avail;
The real line: +	if (ret != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (ret != null) {
The real line: +		run->avail = *(void **)ret;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run->avail = *(void **)ret;
The real line: +		/* Double free can cause assertion failure.*/
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		assert(ret != NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(ret != null);
The real line: +		/* Write-after free can cause assertion failure. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		assert((uintptr_t)ret >= (uintptr_t)run +
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert((uintptr_t)ret >= (uintptr_t)run +
The real line: +		    (uintptr_t)bin->reg0_offset);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)bin->reg0_offset);
The real line: +		assert((uintptr_t)ret < (uintptr_t)run->next);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert((uintptr_t)ret < (uintptr_t)run->next);
The real line: +		assert(((uintptr_t)ret - ((uintptr_t)run +
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(((uintptr_t)ret - ((uintptr_t)run +
The real line: +		    (uintptr_t)bin->reg0_offset)) % (uintptr_t)bin->reg_size ==
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)bin->reg0_offset)) % (uintptr_t)bin->reg_size ==
The real line: +		    0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    0);
The real line: +		return (ret);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (ret);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	ret = run->next;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = run->next;
The real line: +	run->next = (void *)((uintptr_t)ret + (uintptr_t)bin->reg_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	run->next = (void *)((uintptr_t)ret + (uintptr_t)bin->reg_size);
The real line: +	assert(ret != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ret != null);
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
248 : 273
Next: (arena_run_t *run, arena_bin_t *bin)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static inline void
Depths: 0:0
[]
The real line: +arena_run_reg_dalloc(arena_run_t *run, void *ptr)
Current Name Search:  static inline void 
LINE TO PARSE FOR KEYWORD:arena_run_reg_dalloc(arena_run_t *run, void *ptr)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static inline void arena_run_reg_dalloc(arena_run_t *run, void *ptr) 
Checking if function:  static inline void arena_run_reg_dalloc(arena_run_t *run, void *ptr) {
PATTERN 1
Function:  void arena_run_reg_dalloc(arena_run_t *run, void *ptr) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(run->nfree < run->bin->nregs);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run->nfree < run->bin->nregs);
The real line: +	/* Freeing an interior pointer can cause assertion failure. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	assert(((uintptr_t)ptr - ((uintptr_t)run +
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(((uintptr_t)ptr - ((uintptr_t)run +
The real line: +	    (uintptr_t)run->bin->reg0_offset)) % (uintptr_t)run->bin->reg_size
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (uintptr_t)run->bin->reg0_offset)) % (uintptr_t)run->bin->reg_size
The real line: +	    == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    == 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	*(void **)ptr = run->avail;
End Check: 1
LINE TO PARSE FOR KEYWORD:	*(void **)ptr = run->avail;
The real line: +	run->avail = ptr;
End Check: 1
LINE TO PARSE FOR KEYWORD:	run->avail = ptr;
The real line: +	run->nfree++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	run->nfree++;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
277 : 288
Next: (arena_run_t *run, void *ptr)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,
Depths: 0:0
[]
The real line: +    bool zero)
Current Name Search:  static void arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large, 
LINE TO PARSE FOR KEYWORD:    bool zero)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,     bool zero) 
Checking if function:  static void arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,     bool zero) {
PATTERN 1
Function:  void arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,     bool zero) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t old_ndirty, run_ind, total_pages, need_pages, rem_pages, i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t old_ndirty, run_ind, total_pages, need_pages, rem_pages, i;
The real line: +	size_t flag_dirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t flag_dirty;
The real line: +	arena_avail_tree_t *runs_avail;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_t *runs_avail;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(run);
The real line: +	old_ndirty = chunk->ndirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	old_ndirty = chunk->ndirty;
The real line: +	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk)
End Check: 1
LINE TO PARSE FOR KEYWORD:	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk)
The real line: +	    >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    >> page_shift);
The real line: +	flag_dirty = chunk->map[run_ind].bits & CHUNK_MAP_DIRTY;
End Check: 1
LINE TO PARSE FOR KEYWORD:	flag_dirty = chunk->map[run_ind].bits & chunk_map_dirty;
The real line: +	runs_avail = (flag_dirty != 0) ? &arena->runs_avail_dirty :
End Check: 1
LINE TO PARSE FOR KEYWORD:	runs_avail = (flag_dirty != 0) ? &arena->runs_avail_dirty :
The real line: +	    &arena->runs_avail_clean;
End Check: 1
LINE TO PARSE FOR KEYWORD:	    &arena->runs_avail_clean;
The real line: +	total_pages = (chunk->map[run_ind].bits & ~PAGE_MASK) >>
End Check: 1
LINE TO PARSE FOR KEYWORD:	total_pages = (chunk->map[run_ind].bits & ~page_mask) >>
The real line: +	    PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	    page_shift;
The real line: +	assert((chunk->map[run_ind+total_pages-1].bits & CHUNK_MAP_DIRTY) ==
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((chunk->map[run_ind+total_pages-1].bits & chunk_map_dirty) ==
The real line: +	    flag_dirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    flag_dirty);
The real line: +	need_pages = (size >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	need_pages = (size >> page_shift);
The real line: +	assert(need_pages > 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(need_pages > 0);
The real line: +	assert(need_pages <= total_pages);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(need_pages <= total_pages);
The real line: +	rem_pages = total_pages - need_pages;
End Check: 1
LINE TO PARSE FOR KEYWORD:	rem_pages = total_pages - need_pages;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena_avail_tree_remove(runs_avail, &chunk->map[run_ind]);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_remove(runs_avail, &chunk->map[run_ind]);
The real line: +	arena->nactive += need_pages;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->nactive += need_pages;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Keep track of trailing unused pages for later use. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (rem_pages > 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (rem_pages > 0) {
The real line: +		if (flag_dirty != 0) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (flag_dirty != 0) {
The real line: +			chunk->map[run_ind+need_pages].bits = (rem_pages <<
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->map[run_ind+need_pages].bits = (rem_pages <<
The real line: +			    PAGE_SHIFT) | CHUNK_MAP_DIRTY;
End Check: 3
LINE TO PARSE FOR KEYWORD:			    page_shift) | chunk_map_dirty;
The real line: +			chunk->map[run_ind+total_pages-1].bits = (rem_pages <<
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->map[run_ind+total_pages-1].bits = (rem_pages <<
The real line: +			    PAGE_SHIFT) | CHUNK_MAP_DIRTY;
End Check: 3
LINE TO PARSE FOR KEYWORD:			    page_shift) | chunk_map_dirty;
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +			chunk->map[run_ind+need_pages].bits = (rem_pages <<
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->map[run_ind+need_pages].bits = (rem_pages <<
The real line: +			    PAGE_SHIFT) | (chunk->map[run_ind+need_pages].bits &
End Check: 3
LINE TO PARSE FOR KEYWORD:			    page_shift) | (chunk->map[run_ind+need_pages].bits &
The real line: +			    CHUNK_MAP_ZEROED);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    chunk_map_zeroed);
The real line: +			chunk->map[run_ind+total_pages-1].bits = (rem_pages <<
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->map[run_ind+total_pages-1].bits = (rem_pages <<
The real line: +			    PAGE_SHIFT) |
End Check: 3
LINE TO PARSE FOR KEYWORD:			    page_shift) |
The real line: +			    (chunk->map[run_ind+total_pages-1].bits &
End Check: 3
LINE TO PARSE FOR KEYWORD:			    (chunk->map[run_ind+total_pages-1].bits &
The real line: +			    CHUNK_MAP_ZEROED);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    chunk_map_zeroed);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		arena_avail_tree_insert(runs_avail,
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_avail_tree_insert(runs_avail,
The real line: +		    &chunk->map[run_ind+need_pages]);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    &chunk->map[run_ind+need_pages]);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Update dirty page accounting. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (flag_dirty != 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (flag_dirty != 0) {
The real line: +		chunk->ndirty -= need_pages;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->ndirty -= need_pages;
The real line: +		arena->ndirty -= need_pages;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->ndirty -= need_pages;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Update the page map separately for large vs. small runs, since it is
The real line: +	 * possible to avoid iteration for large mallocs.
The real line: +	 */
The real line: +	if (large) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (large) {
The real line: +		if (zero) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (zero) {
The real line: +			if (flag_dirty == 0) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (flag_dirty == 0) {
The real line: +				/*
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				 * The run is clean, so some pages may be
The real line: +				 * zeroed (i.e. never before touched).
The real line: +				 */
The real line: +				for (i = 0; i < need_pages; i++) {
End Check: 5
LINE TO PARSE FOR KEYWORD:				for (i = 0; i < need_pages; i++) {
The real line: +					if ((chunk->map[run_ind + i].bits &
End Check: 5
LINE TO PARSE FOR KEYWORD:					if ((chunk->map[run_ind + i].bits &
The real line: +					    CHUNK_MAP_ZEROED) == 0) {
End Check: 6
LINE TO PARSE FOR KEYWORD:					    chunk_map_zeroed) == 0) {
The real line: +						memset((void *)((uintptr_t)
End Check: 6
LINE TO PARSE FOR KEYWORD:						memset((void *)((uintptr_t)
The real line: +						    chunk + ((run_ind + i) <<
End Check: 6
LINE TO PARSE FOR KEYWORD:						    chunk + ((run_ind + i) <<
The real line: +						    PAGE_SHIFT)), 0,
End Check: 6
LINE TO PARSE FOR KEYWORD:						    page_shift)), 0,
The real line: +						    PAGE_SIZE);
End Check: 6
LINE TO PARSE FOR KEYWORD:						    page_size);
The real line: +					}
End Check: 5
LINE TO PARSE FOR KEYWORD:					}
The real line: +				}
End Check: 4
LINE TO PARSE FOR KEYWORD:				}
The real line: +			} else {
End Check: 4
LINE TO PARSE FOR KEYWORD:			} else {
The real line: +				/*
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				 * The run is dirty, so all pages must be
The real line: +				 * zeroed.
The real line: +				 */
The real line: +				memset((void *)((uintptr_t)chunk + (run_ind <<
End Check: 4
LINE TO PARSE FOR KEYWORD:				memset((void *)((uintptr_t)chunk + (run_ind <<
The real line: +				    PAGE_SHIFT)), 0, (need_pages <<
End Check: 4
LINE TO PARSE FOR KEYWORD:				    page_shift)), 0, (need_pages <<
The real line: +				    PAGE_SHIFT));
End Check: 4
LINE TO PARSE FOR KEYWORD:				    page_shift));
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Set the last element first, in case the run only contains one
The real line: +		 * page (i.e. both statements set the same element).
The real line: +		 */
The real line: +		chunk->map[run_ind+need_pages-1].bits = CHUNK_MAP_LARGE |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind+need_pages-1].bits = chunk_map_large |
The real line: +		    CHUNK_MAP_ALLOCATED | flag_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_allocated | flag_dirty;
The real line: +		chunk->map[run_ind].bits = size | CHUNK_MAP_LARGE |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = size | chunk_map_large |
The real line: +#ifdef JEMALLOC_PROF
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +		    CHUNK_MAP_CLASS_MASK |
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_class_mask |
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		    CHUNK_MAP_ALLOCATED | flag_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_allocated | flag_dirty;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		assert(zero == false);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(zero == false);
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Propagate the dirty flag to the allocated small run, so that
The real line: +		 * arena_dalloc_bin_run() has the ability to conditionally trim
The real line: +		 * clean pages.
The real line: +		 */
The real line: +		chunk->map[run_ind].bits = CHUNK_MAP_ALLOCATED | flag_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = chunk_map_allocated | flag_dirty;
The real line: +		for (i = 1; i < need_pages - 1; i++) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		for (i = 1; i < need_pages - 1; i++) {
The real line: +			chunk->map[run_ind + i].bits = (i << PAGE_SHIFT)
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->map[run_ind + i].bits = (i << page_shift)
The real line: +			    | CHUNK_MAP_ALLOCATED;
End Check: 3
LINE TO PARSE FOR KEYWORD:			    | chunk_map_allocated;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		chunk->map[run_ind + need_pages - 1].bits = ((need_pages - 1) <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind + need_pages - 1].bits = ((need_pages - 1) <<
The real line: +		    PAGE_SHIFT) | CHUNK_MAP_ALLOCATED | flag_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift) | chunk_map_allocated | flag_dirty;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
293 : 401
Next: (arena_t *arena, arena_run_t *run, size_t size, bool large,     bool zero)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static arena_chunk_t *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static arena_chunk_t *
Depths: 0:0
[]
The real line: +arena_chunk_alloc(arena_t *arena)
Current Name Search:  static arena_chunk_t * 
LINE TO PARSE FOR KEYWORD:arena_chunk_alloc(arena_t *arena)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static arena_chunk_t * arena_chunk_alloc(arena_t *arena) 
Checking if function:  static arena_chunk_t * arena_chunk_alloc(arena_t *arena) {
PATTERN 1
Function:  arena_chunk_t * arena_chunk_alloc(arena_t *arena) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (arena->spare != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (arena->spare != null) {
The real line: +		arena_avail_tree_t *runs_avail;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_avail_tree_t *runs_avail;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk = arena->spare;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = arena->spare;
The real line: +		arena->spare = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->spare = null;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* Insert the run into the appropriate runs_avail_* tree. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		if ((chunk->map[arena_chunk_header_npages].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		if ((chunk->map[arena_chunk_header_npages].bits &
The real line: +		    CHUNK_MAP_DIRTY) == 0)
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_dirty) == 0)
The real line: +			runs_avail = &arena->runs_avail_clean;
End Check: 2
LINE TO PARSE FOR KEYWORD:			runs_avail = &arena->runs_avail_clean;
The real line: +		else
End Check: 2
LINE TO PARSE FOR KEYWORD:		else
The real line: +			runs_avail = &arena->runs_avail_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:			runs_avail = &arena->runs_avail_dirty;
The real line: +		arena_avail_tree_insert(runs_avail,
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_avail_tree_insert(runs_avail,
The real line: +		    &chunk->map[arena_chunk_header_npages]);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    &chunk->map[arena_chunk_header_npages]);
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		bool zero;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bool zero;
The real line: +		size_t zeroed;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t zeroed;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		zero = false;
End Check: 2
LINE TO PARSE FOR KEYWORD:		zero = false;
The real line: +		malloc_mutex_unlock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&arena->lock);
The real line: +		chunk = (arena_chunk_t *)chunk_alloc(chunksize, &zero);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = (arena_chunk_t *)chunk_alloc(chunksize, &zero);
The real line: +		malloc_mutex_lock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_lock(&arena->lock);
The real line: +		if (chunk == NULL)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (chunk == null)
The real line: +			return (NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (null);
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		arena->stats.mapped += chunksize;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.mapped += chunksize;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk->arena = arena;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->arena = arena;
The real line: +		ql_elm_new(chunk, link_dirty);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ql_elm_new(chunk, link_dirty);
The real line: +		chunk->dirtied = false;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->dirtied = false;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Claim that no pages are in use, since the header is merely
The real line: +		 * overhead.
The real line: +		 */
The real line: +		chunk->ndirty = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->ndirty = 0;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Initialize the map to contain one maximal free untouched run.
The real line: +		 * Mark the pages as zeroed iff chunk_alloc() returned a zeroed
The real line: +		 * chunk.
The real line: +		 */
The real line: +		zeroed = zero ? CHUNK_MAP_ZEROED : 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:		zeroed = zero ? chunk_map_zeroed : 0;
The real line: +		for (i = 0; i < arena_chunk_header_npages; i++)
End Check: 2
LINE TO PARSE FOR KEYWORD:		for (i = 0; i < arena_chunk_header_npages; i++)
The real line: +			chunk->map[i].bits = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:			chunk->map[i].bits = 0;
The real line: +		chunk->map[i].bits = arena_maxclass | zeroed;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[i].bits = arena_maxclass | zeroed;
The real line: +		for (i++; i < chunk_npages-1; i++)
End Check: 2
LINE TO PARSE FOR KEYWORD:		for (i++; i < chunk_npages-1; i++)
The real line: +			chunk->map[i].bits = zeroed;
End Check: 2
LINE TO PARSE FOR KEYWORD:			chunk->map[i].bits = zeroed;
The real line: +		chunk->map[chunk_npages-1].bits = arena_maxclass | zeroed;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[chunk_npages-1].bits = arena_maxclass | zeroed;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* Insert the run into the runs_avail_clean tree. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		arena_avail_tree_insert(&arena->runs_avail_clean,
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_avail_tree_insert(&arena->runs_avail_clean,
The real line: +		    &chunk->map[arena_chunk_header_npages]);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    &chunk->map[arena_chunk_header_npages]);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (chunk);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (chunk);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
405 : 466
Next: (arena_t *arena)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk)
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk) 
Checking if function:  static void arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk) {
PATTERN 1
Function:  void arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_avail_tree_t *runs_avail;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_t *runs_avail;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	while (arena->spare != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	while (arena->spare != null) {
The real line: +		arena_chunk_t *spare = arena->spare;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *spare = arena->spare;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		arena->spare = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->spare = null;
The real line: +		if (spare->dirtied) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (spare->dirtied) {
The real line: +			ql_remove(&chunk->arena->chunks_dirty, spare,
End Check: 3
LINE TO PARSE FOR KEYWORD:			ql_remove(&chunk->arena->chunks_dirty, spare,
The real line: +			    link_dirty);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    link_dirty);
The real line: +			arena->ndirty -= spare->ndirty;
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena->ndirty -= spare->ndirty;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		malloc_mutex_unlock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&arena->lock);
The real line: +		chunk_dealloc((void *)spare, chunksize);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk_dealloc((void *)spare, chunksize);
The real line: +		malloc_mutex_lock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_lock(&arena->lock);
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		arena->stats.mapped -= chunksize;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.mapped -= chunksize;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Remove run from the appropriate runs_avail_* tree, so that the arena
The real line: +	 * does not use it.
The real line: +	 */
The real line: +	if ((chunk->map[arena_chunk_header_npages].bits &
End Check: 1
LINE TO PARSE FOR KEYWORD:	if ((chunk->map[arena_chunk_header_npages].bits &
The real line: +	    CHUNK_MAP_DIRTY) == 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:	    chunk_map_dirty) == 0)
The real line: +		runs_avail = &arena->runs_avail_clean;
End Check: 1
LINE TO PARSE FOR KEYWORD:		runs_avail = &arena->runs_avail_clean;
The real line: +	else
End Check: 1
LINE TO PARSE FOR KEYWORD:	else
The real line: +		runs_avail = &arena->runs_avail_dirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:		runs_avail = &arena->runs_avail_dirty;
The real line: +	arena_avail_tree_remove(runs_avail,
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_remove(runs_avail,
The real line: +	    &chunk->map[arena_chunk_header_npages]);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    &chunk->map[arena_chunk_header_npages]);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena->spare = chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->spare = chunk;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
470 : 503
Next: (arena_t *arena, arena_chunk_t *chunk)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static arena_run_t *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static arena_run_t *
Depths: 0:0
[]
The real line: +arena_run_alloc(arena_t *arena, size_t size, bool large, bool zero)
Current Name Search:  static arena_run_t * 
LINE TO PARSE FOR KEYWORD:arena_run_alloc(arena_t *arena, size_t size, bool large, bool zero)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static arena_run_t * arena_run_alloc(arena_t *arena, size_t size, bool large, bool zero) 
Checking if function:  static arena_run_t * arena_run_alloc(arena_t *arena, size_t size, bool large, bool zero) {
PATTERN 1
Function:  arena_run_t * arena_run_alloc(arena_t *arena, size_t size, bool large, bool zero) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	arena_run_t *run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_t *run;
The real line: +	arena_chunk_map_t *mapelm, key;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_map_t *mapelm, key;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(size <= arena_maxclass);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(size <= arena_maxclass);
The real line: +	assert((size & PAGE_MASK) == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((size & page_mask) == 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Search the arena's chunks for the lowest best fit. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	key.bits = size | CHUNK_MAP_KEY;
End Check: 1
LINE TO PARSE FOR KEYWORD:	key.bits = size | chunk_map_key;
The real line: +	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_dirty, &key);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_dirty, &key);
The real line: +	if (mapelm != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mapelm != null) {
The real line: +		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *run_chunk = chunk_addr2base(mapelm);
The real line: +		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
The real line: +		    / sizeof(arena_chunk_map_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    / sizeof(arena_chunk_map_t);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
The real line: +		    PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift));
The real line: +		arena_run_split(arena, run, size, large, zero);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_split(arena, run, size, large, zero);
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_clean, &key);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_clean, &key);
The real line: +	if (mapelm != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mapelm != null) {
The real line: +		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *run_chunk = chunk_addr2base(mapelm);
The real line: +		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
The real line: +		    / sizeof(arena_chunk_map_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    / sizeof(arena_chunk_map_t);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
The real line: +		    PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift));
The real line: +		arena_run_split(arena, run, size, large, zero);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_split(arena, run, size, large, zero);
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * No usable runs.  Create a new chunk from which to allocate the run.
The real line: +	 */
The real line: +	chunk = arena_chunk_alloc(arena);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = arena_chunk_alloc(arena);
The real line: +	if (chunk != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (chunk != null) {
The real line: +		run = (arena_run_t *)((uintptr_t)chunk +
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)chunk +
The real line: +		    (arena_chunk_header_npages << PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (arena_chunk_header_npages << page_shift));
The real line: +		arena_run_split(arena, run, size, large, zero);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_split(arena, run, size, large, zero);
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * arena_chunk_alloc() failed, but another thread may have made
The real line: +	 * sufficient memory available while this one dropped arena->lock in
The real line: +	 * arena_chunk_alloc(), so search one more time.
The real line: +	 */
The real line: +	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_dirty, &key);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_dirty, &key);
The real line: +	if (mapelm != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mapelm != null) {
The real line: +		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *run_chunk = chunk_addr2base(mapelm);
The real line: +		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
The real line: +		    / sizeof(arena_chunk_map_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    / sizeof(arena_chunk_map_t);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
The real line: +		    PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift));
The real line: +		arena_run_split(arena, run, size, large, zero);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_split(arena, run, size, large, zero);
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_clean, &key);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapelm = arena_avail_tree_nsearch(&arena->runs_avail_clean, &key);
The real line: +	if (mapelm != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mapelm != null) {
The real line: +		arena_chunk_t *run_chunk = CHUNK_ADDR2BASE(mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *run_chunk = chunk_addr2base(mapelm);
The real line: +		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)run_chunk->map)
The real line: +		    / sizeof(arena_chunk_map_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    / sizeof(arena_chunk_map_t);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)run_chunk + (pageind <<
The real line: +		    PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift));
The real line: +		arena_run_split(arena, run, size, large, zero);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_split(arena, run, size, large, zero);
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (null);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
507 : 580
Next: (arena_t *arena, size_t size, bool large, bool zero)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static inline void
Depths: 0:0
[]
The real line: +arena_maybe_purge(arena_t *arena)
Current Name Search:  static inline void 
LINE TO PARSE FOR KEYWORD:arena_maybe_purge(arena_t *arena)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static inline void arena_maybe_purge(arena_t *arena) 
Checking if function:  static inline void arena_maybe_purge(arena_t *arena) {
PATTERN 1
Function:  void arena_maybe_purge(arena_t *arena) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Enforce opt_lg_dirty_mult. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (opt_lg_dirty_mult >= 0 && arena->ndirty > arena->npurgatory &&
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (opt_lg_dirty_mult >= 0 && arena->ndirty > arena->npurgatory &&
The real line: +	    (arena->ndirty - arena->npurgatory) > chunk_npages &&
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (arena->ndirty - arena->npurgatory) > chunk_npages &&
The real line: +	    (arena->nactive >> opt_lg_dirty_mult) < (arena->ndirty -
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (arena->nactive >> opt_lg_dirty_mult) < (arena->ndirty -
The real line: +	    arena->npurgatory))
End Check: 1
LINE TO PARSE FOR KEYWORD:	    arena->npurgatory))
The real line: +		arena_purge(arena);
End Check: 1
LINE TO PARSE FOR KEYWORD:		arena_purge(arena);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
584 : 592
Next: (arena_t *arena)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static inline void
Depths: 0:0
[]
The real line: +arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
Current Name Search:  static inline void 
LINE TO PARSE FOR KEYWORD:arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static inline void arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk) 
Checking if function:  static inline void arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk) {
PATTERN 1
Function:  void arena_chunk_purge(arena_t *arena, arena_chunk_t *chunk) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	ql_head(arena_chunk_map_t) mapelms;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ql_head(arena_chunk_map_t) mapelms;
The real line: +	arena_chunk_map_t *mapelm;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_map_t *mapelm;
The real line: +	size_t pageind, flag_zeroed;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind, flag_zeroed;
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	size_t ndirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t ndirty;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	size_t nmadvise;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t nmadvise;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ql_new(&mapelms);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ql_new(&mapelms);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	flag_zeroed =
End Check: 1
LINE TO PARSE FOR KEYWORD:	flag_zeroed =
The real line: +#ifdef JEMALLOC_SWAP
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_swap
The real line: +	    swap_enabled ? 0 :
End Check: 1
LINE TO PARSE FOR KEYWORD:	    swap_enabled ? 0 :
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	    CHUNK_MAP_ZEROED;
End Check: 1
LINE TO PARSE FOR KEYWORD:	    chunk_map_zeroed;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * If chunk is the spare, temporarily re-allocate it, 1) so that its
The real line: +	 * run is reinserted into runs_avail_dirty, and 2) so that it cannot be
The real line: +	 * completely discarded by another thread while arena->lock is dropped
The real line: +	 * by this thread.  Note that the arena_run_dalloc() call will
The real line: +	 * implicitly deallocate the chunk, so no explicit action is required
The real line: +	 * in this function to deallocate the chunk.
The real line: +	 *
The real line: +	 * Note that once a chunk contains dirty pages, it cannot again contain
The real line: +	 * a single run unless 1) it is a dirty run, or 2) this function purges
The real line: +	 * dirty pages and causes the transition to a single clean run.  Thus
The real line: +	 * (chunk == arena->spare) is possible, but it is not possible for
The real line: +	 * this function to be called on the spare unless it contains a dirty
The real line: +	 * run.
The real line: +	 */
The real line: +	if (chunk == arena->spare) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (chunk == arena->spare) {
The real line: +		assert((chunk->map[arena_chunk_header_npages].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert((chunk->map[arena_chunk_header_npages].bits &
The real line: +		    CHUNK_MAP_DIRTY) != 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_dirty) != 0);
The real line: +		arena_chunk_alloc(arena);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_alloc(arena);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Temporarily allocate all free dirty runs within chunk. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (pageind = arena_chunk_header_npages; pageind < chunk_npages;) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (pageind = arena_chunk_header_npages; pageind < chunk_npages;) {
The real line: +		mapelm = &chunk->map[pageind];
End Check: 2
LINE TO PARSE FOR KEYWORD:		mapelm = &chunk->map[pageind];
The real line: +		if ((mapelm->bits & CHUNK_MAP_ALLOCATED) == 0) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if ((mapelm->bits & chunk_map_allocated) == 0) {
The real line: +			size_t npages;
End Check: 3
LINE TO PARSE FOR KEYWORD:			size_t npages;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			npages = mapelm->bits >> PAGE_SHIFT;
End Check: 3
LINE TO PARSE FOR KEYWORD:			npages = mapelm->bits >> page_shift;
The real line: +			assert(pageind + npages <= chunk_npages);
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(pageind + npages <= chunk_npages);
The real line: +			if (mapelm->bits & CHUNK_MAP_DIRTY) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (mapelm->bits & chunk_map_dirty) {
The real line: +				size_t i;
End Check: 4
LINE TO PARSE FOR KEYWORD:				size_t i;
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				arena_avail_tree_remove(
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena_avail_tree_remove(
The real line: +				    &arena->runs_avail_dirty, mapelm);
End Check: 4
LINE TO PARSE FOR KEYWORD:				    &arena->runs_avail_dirty, mapelm);
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				/*
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				 * Update internal elements in the page map, so
The real line: +				 * that CHUNK_MAP_ZEROED is properly set.
The real line: +				 * madvise(..., MADV_DONTNEED) results in
The real line: +				 * zero-filled pages for anonymous mappings,
The real line: +				 * but not for file-backed mappings.
The real line: +				 */
The real line: +				mapelm->bits = (npages << PAGE_SHIFT) |
End Check: 4
LINE TO PARSE FOR KEYWORD:				mapelm->bits = (npages << page_shift) |
The real line: +				    CHUNK_MAP_LARGE | CHUNK_MAP_ALLOCATED |
End Check: 4
LINE TO PARSE FOR KEYWORD:				    chunk_map_large | chunk_map_allocated |
The real line: +				    flag_zeroed;
End Check: 4
LINE TO PARSE FOR KEYWORD:				    flag_zeroed;
The real line: +				for (i = 1; i < npages - 1; i++) {
End Check: 5
LINE TO PARSE FOR KEYWORD:				for (i = 1; i < npages - 1; i++) {
The real line: +					chunk->map[pageind + i].bits =
End Check: 5
LINE TO PARSE FOR KEYWORD:					chunk->map[pageind + i].bits =
The real line: +					    flag_zeroed;
End Check: 5
LINE TO PARSE FOR KEYWORD:					    flag_zeroed;
The real line: +				}
End Check: 4
LINE TO PARSE FOR KEYWORD:				}
The real line: +				if (npages > 1) {
End Check: 5
LINE TO PARSE FOR KEYWORD:				if (npages > 1) {
The real line: +					chunk->map[pageind + npages - 1].bits =
End Check: 5
LINE TO PARSE FOR KEYWORD:					chunk->map[pageind + npages - 1].bits =
The real line: +					(npages << PAGE_SHIFT) |
End Check: 5
LINE TO PARSE FOR KEYWORD:					(npages << page_shift) |
The real line: +					CHUNK_MAP_LARGE | CHUNK_MAP_ALLOCATED |
End Check: 5
LINE TO PARSE FOR KEYWORD:					chunk_map_large | chunk_map_allocated |
The real line: +					flag_zeroed;
End Check: 5
LINE TO PARSE FOR KEYWORD:					flag_zeroed;
The real line: +				}
End Check: 4
LINE TO PARSE FOR KEYWORD:				}
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				arena->nactive += npages;
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena->nactive += npages;
The real line: +				/* Append to list for later processing. */
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				ql_elm_new(mapelm, u.ql_link);
End Check: 4
LINE TO PARSE FOR KEYWORD:				ql_elm_new(mapelm, u.ql_link);
The real line: +				ql_tail_insert(&mapelms, mapelm, u.ql_link);
End Check: 4
LINE TO PARSE FOR KEYWORD:				ql_tail_insert(&mapelms, mapelm, u.ql_link);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			pageind += npages;
End Check: 3
LINE TO PARSE FOR KEYWORD:			pageind += npages;
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +			/* Skip allocated run. */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			if (mapelm->bits & CHUNK_MAP_LARGE)
End Check: 3
LINE TO PARSE FOR KEYWORD:			if (mapelm->bits & chunk_map_large)
The real line: +				pageind += mapelm->bits >> PAGE_SHIFT;
End Check: 3
LINE TO PARSE FOR KEYWORD:				pageind += mapelm->bits >> page_shift;
The real line: +			else {
End Check: 4
LINE TO PARSE FOR KEYWORD:			else {
The real line: +				arena_run_t *run = (arena_run_t *)((uintptr_t)
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena_run_t *run = (arena_run_t *)((uintptr_t)
The real line: +				    chunk + (uintptr_t)(pageind << PAGE_SHIFT));
End Check: 4
LINE TO PARSE FOR KEYWORD:				    chunk + (uintptr_t)(pageind << page_shift));
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				assert((mapelm->bits >> PAGE_SHIFT) == 0);
End Check: 4
LINE TO PARSE FOR KEYWORD:				assert((mapelm->bits >> page_shift) == 0);
The real line: +				assert(run->magic == ARENA_RUN_MAGIC);
End Check: 4
LINE TO PARSE FOR KEYWORD:				assert(run->magic == arena_run_magic);
The real line: +				pageind += run->bin->run_size >> PAGE_SHIFT;
End Check: 4
LINE TO PARSE FOR KEYWORD:				pageind += run->bin->run_size >> page_shift;
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	assert(pageind == chunk_npages);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(pageind == chunk_npages);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	ndirty = chunk->ndirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ndirty = chunk->ndirty;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.purged += chunk->ndirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.purged += chunk->ndirty;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	arena->ndirty -= chunk->ndirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->ndirty -= chunk->ndirty;
The real line: +	chunk->ndirty = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->ndirty = 0;
The real line: +	ql_remove(&arena->chunks_dirty, chunk, link_dirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ql_remove(&arena->chunks_dirty, chunk, link_dirty);
The real line: +	chunk->dirtied = false;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->dirtied = false;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	nmadvise = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	nmadvise = 0;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	ql_foreach(mapelm, &mapelms, u.ql_link) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	ql_foreach(mapelm, &mapelms, u.ql_link) {
The real line: +		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)chunk->map) /
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)chunk->map) /
The real line: +		    sizeof(arena_chunk_map_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    sizeof(arena_chunk_map_t);
The real line: +		size_t npages = mapelm->bits >> PAGE_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t npages = mapelm->bits >> page_shift;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		assert(pageind + npages <= chunk_npages);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(pageind + npages <= chunk_npages);
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +		assert(ndirty >= npages);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(ndirty >= npages);
The real line: +		ndirty -= npages;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ndirty -= npages;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		madvise((void *)((uintptr_t)chunk + (pageind << PAGE_SHIFT)),
End Check: 2
LINE TO PARSE FOR KEYWORD:		madvise((void *)((uintptr_t)chunk + (pageind << page_shift)),
The real line: +		    (npages << PAGE_SHIFT), MADV_DONTNEED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (npages << page_shift), madv_dontneed);
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		nmadvise++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		nmadvise++;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	assert(ndirty == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ndirty == 0);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.nmadvise += nmadvise;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nmadvise += nmadvise;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Deallocate runs. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (mapelm = ql_first(&mapelms); mapelm != NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	for (mapelm = ql_first(&mapelms); mapelm != null;
The real line: +	    mapelm = ql_first(&mapelms)) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    mapelm = ql_first(&mapelms)) {
The real line: +		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)chunk->map) /
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)mapelm - (uintptr_t)chunk->map) /
The real line: +		    sizeof(arena_chunk_map_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    sizeof(arena_chunk_map_t);
The real line: +		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
The real line: +		    (uintptr_t)(pageind << PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)(pageind << page_shift));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		ql_remove(&mapelms, mapelm, u.ql_link);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ql_remove(&mapelms, mapelm, u.ql_link);
The real line: +		arena_run_dalloc(arena, run, false);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_dalloc(arena, run, false);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
596 : 744
Next: (arena_t *arena, arena_chunk_t *chunk)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_purge(arena_t *arena)
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_purge(arena_t *arena)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_purge(arena_t *arena) 
Checking if function:  static void arena_purge(arena_t *arena) {
PATTERN 1
Function:  void arena_purge(arena_t *arena) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t npurgatory;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t npurgatory;
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	size_t ndirty = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t ndirty = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	ql_foreach(chunk, &arena->chunks_dirty, link_dirty) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	ql_foreach(chunk, &arena->chunks_dirty, link_dirty) {
The real line: +	    assert(chunk->dirtied);
End Check: 2
LINE TO PARSE FOR KEYWORD:	    assert(chunk->dirtied);
The real line: +	    ndirty += chunk->ndirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:	    ndirty += chunk->ndirty;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	assert(ndirty == arena->ndirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ndirty == arena->ndirty);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	assert(arena->ndirty > arena->npurgatory);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(arena->ndirty > arena->npurgatory);
The real line: +	assert(arena->ndirty > chunk_npages);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(arena->ndirty > chunk_npages);
The real line: +	assert((arena->nactive >> opt_lg_dirty_mult) < arena->ndirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((arena->nactive >> opt_lg_dirty_mult) < arena->ndirty);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.npurge++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.npurge++;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Compute the minimum number of pages that this thread should try to
The real line: +	 * purge, and add the result to arena->npurgatory.  This will keep
The real line: +	 * multiple threads from racing to reduce ndirty below the threshold.
The real line: +	 */
The real line: +	npurgatory = (arena->ndirty - arena->npurgatory) - (arena->nactive >>
End Check: 1
LINE TO PARSE FOR KEYWORD:	npurgatory = (arena->ndirty - arena->npurgatory) - (arena->nactive >>
The real line: +	    opt_lg_dirty_mult);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    opt_lg_dirty_mult);
The real line: +	arena->npurgatory += npurgatory;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->npurgatory += npurgatory;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	while (npurgatory > 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	while (npurgatory > 0) {
The real line: +		/* Get next chunk with dirty pages. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		chunk = ql_first(&arena->chunks_dirty);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = ql_first(&arena->chunks_dirty);
The real line: +		if (chunk == NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (chunk == null) {
The real line: +			/*
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			 * This thread was unable to purge as many pages as
The real line: +			 * originally intended, due to races with other threads
The real line: +			 * that either did some of the purging work, or re-used
The real line: +			 * dirty pages.
The real line: +			 */
The real line: +			arena->npurgatory -= npurgatory;
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena->npurgatory -= npurgatory;
The real line: +			return;
End Check: 3
LINE TO PARSE FOR KEYWORD:			return;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		while (chunk->ndirty == 0) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		while (chunk->ndirty == 0) {
The real line: +			ql_remove(&arena->chunks_dirty, chunk, link_dirty);
End Check: 3
LINE TO PARSE FOR KEYWORD:			ql_remove(&arena->chunks_dirty, chunk, link_dirty);
The real line: +			chunk->dirtied = false;
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->dirtied = false;
The real line: +			chunk = ql_first(&arena->chunks_dirty);
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk = ql_first(&arena->chunks_dirty);
The real line: +			if (chunk == NULL) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (chunk == null) {
The real line: +				/* Same logic as for above. */
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				arena->npurgatory -= npurgatory;
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena->npurgatory -= npurgatory;
The real line: +				return;
End Check: 4
LINE TO PARSE FOR KEYWORD:				return;
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (chunk->ndirty > npurgatory) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (chunk->ndirty > npurgatory) {
The real line: +			/*
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			 * This thread will, at a minimum, purge all the dirty
The real line: +			 * pages in chunk, so set npurgatory to reflect this
The real line: +			 * thread's commitment to purge the pages.  This tends
The real line: +			 * to reduce the chances of the following scenario:
The real line: +			 *
The real line: +			 * 1) This thread sets arena->npurgatory such that
The real line: +			 *    (arena->ndirty - arena->npurgatory) is at the
The real line: +			 *    threshold.
The real line: +			 * 2) This thread drops arena->lock.
The real line: +			 * 3) Another thread causes one or more pages to be
The real line: +			 *    dirtied, and immediately determines that it must
The real line: +			 *    purge dirty pages.
The real line: +			 *
The real line: +			 * If this scenario *does* play out, that's okay,
The real line: +			 * because all of the purging work being done really
The real line: +			 * needs to happen.
The real line: +			 */
The real line: +			arena->npurgatory += chunk->ndirty - npurgatory;
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena->npurgatory += chunk->ndirty - npurgatory;
The real line: +			npurgatory = chunk->ndirty;
End Check: 3
LINE TO PARSE FOR KEYWORD:			npurgatory = chunk->ndirty;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		arena->npurgatory -= chunk->ndirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->npurgatory -= chunk->ndirty;
The real line: +		npurgatory -= chunk->ndirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		npurgatory -= chunk->ndirty;
The real line: +		arena_chunk_purge(arena, chunk);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_purge(arena, chunk);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
748 : 828
Next: (arena_t *arena)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty)
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty) 
Checking if function:  static void arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty) {
PATTERN 1
Function:  void arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t size, run_ind, run_pages, flag_dirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t size, run_ind, run_pages, flag_dirty;
The real line: +	arena_avail_tree_t *runs_avail;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_t *runs_avail;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(run);
The real line: +	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk)
End Check: 1
LINE TO PARSE FOR KEYWORD:	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk)
The real line: +	    >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    >> page_shift);
The real line: +	assert(run_ind >= arena_chunk_header_npages);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run_ind >= arena_chunk_header_npages);
The real line: +	assert(run_ind < chunk_npages);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run_ind < chunk_npages);
The real line: +	if ((chunk->map[run_ind].bits & CHUNK_MAP_LARGE) != 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if ((chunk->map[run_ind].bits & chunk_map_large) != 0)
The real line: +		size = chunk->map[run_ind].bits & ~PAGE_MASK;
End Check: 1
LINE TO PARSE FOR KEYWORD:		size = chunk->map[run_ind].bits & ~page_mask;
The real line: +	else
End Check: 1
LINE TO PARSE FOR KEYWORD:	else
The real line: +		size = run->bin->run_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:		size = run->bin->run_size;
The real line: +	run_pages = (size >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	run_pages = (size >> page_shift);
The real line: +	arena->nactive -= run_pages;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->nactive -= run_pages;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * The run is dirty if the caller claims to have dirtied it, as well as
The real line: +	 * if it was already dirty before being allocated.
The real line: +	 */
The real line: +	if ((chunk->map[run_ind].bits & CHUNK_MAP_DIRTY) != 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if ((chunk->map[run_ind].bits & chunk_map_dirty) != 0)
The real line: +		dirty = true;
End Check: 1
LINE TO PARSE FOR KEYWORD:		dirty = true;
The real line: +	flag_dirty = dirty ? CHUNK_MAP_DIRTY : 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	flag_dirty = dirty ? chunk_map_dirty : 0;
The real line: +	runs_avail = dirty ? &arena->runs_avail_dirty :
End Check: 1
LINE TO PARSE FOR KEYWORD:	runs_avail = dirty ? &arena->runs_avail_dirty :
The real line: +	    &arena->runs_avail_clean;
End Check: 1
LINE TO PARSE FOR KEYWORD:	    &arena->runs_avail_clean;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Mark pages as unallocated in the chunk map. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (dirty) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (dirty) {
The real line: +		chunk->map[run_ind].bits = size | flag_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = size | flag_dirty;
The real line: +		chunk->map[run_ind+run_pages-1].bits = size | flag_dirty;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind+run_pages-1].bits = size | flag_dirty;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk->ndirty += run_pages;
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->ndirty += run_pages;
The real line: +		arena->ndirty += run_pages;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->ndirty += run_pages;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
The real line: +		    CHUNK_MAP_ZEROED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_zeroed);
The real line: +		chunk->map[run_ind+run_pages-1].bits = size |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind+run_pages-1].bits = size |
The real line: +		    (chunk->map[run_ind+run_pages-1].bits & CHUNK_MAP_ZEROED);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (chunk->map[run_ind+run_pages-1].bits & chunk_map_zeroed);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Try to coalesce forward. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (run_ind + run_pages < chunk_npages &&
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (run_ind + run_pages < chunk_npages &&
The real line: +	    (chunk->map[run_ind+run_pages].bits & CHUNK_MAP_ALLOCATED) == 0 &&
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (chunk->map[run_ind+run_pages].bits & chunk_map_allocated) == 0 &&
The real line: +	    (chunk->map[run_ind+run_pages].bits & CHUNK_MAP_DIRTY) ==
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (chunk->map[run_ind+run_pages].bits & chunk_map_dirty) ==
The real line: +	    flag_dirty) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    flag_dirty) {
The real line: +		size_t nrun_size = chunk->map[run_ind+run_pages].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t nrun_size = chunk->map[run_ind+run_pages].bits &
The real line: +		    ~PAGE_MASK;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    ~page_mask;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Remove successor from runs_avail; the coalesced run is
The real line: +		 * inserted later.
The real line: +		 */
The real line: +		arena_avail_tree_remove(runs_avail,
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_avail_tree_remove(runs_avail,
The real line: +		    &chunk->map[run_ind+run_pages]);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    &chunk->map[run_ind+run_pages]);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		size += nrun_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size += nrun_size;
The real line: +		run_pages = size >> PAGE_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run_pages = size >> page_shift;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		assert((chunk->map[run_ind+run_pages-1].bits & ~PAGE_MASK)
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert((chunk->map[run_ind+run_pages-1].bits & ~page_mask)
The real line: +		    == nrun_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    == nrun_size);
The real line: +		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
The real line: +		    CHUNK_MAP_FLAGS_MASK);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_flags_mask);
The real line: +		chunk->map[run_ind+run_pages-1].bits = size |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind+run_pages-1].bits = size |
The real line: +		    (chunk->map[run_ind+run_pages-1].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (chunk->map[run_ind+run_pages-1].bits &
The real line: +		    CHUNK_MAP_FLAGS_MASK);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_flags_mask);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Try to coalesce backward. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (run_ind > arena_chunk_header_npages && (chunk->map[run_ind-1].bits &
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (run_ind > arena_chunk_header_npages && (chunk->map[run_ind-1].bits &
The real line: +	    CHUNK_MAP_ALLOCATED) == 0 && (chunk->map[run_ind-1].bits &
End Check: 1
LINE TO PARSE FOR KEYWORD:	    chunk_map_allocated) == 0 && (chunk->map[run_ind-1].bits &
The real line: +	    CHUNK_MAP_DIRTY) == flag_dirty) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    chunk_map_dirty) == flag_dirty) {
The real line: +		size_t prun_size = chunk->map[run_ind-1].bits & ~PAGE_MASK;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t prun_size = chunk->map[run_ind-1].bits & ~page_mask;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		run_ind -= prun_size >> PAGE_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run_ind -= prun_size >> page_shift;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Remove predecessor from runs_avail; the coalesced run is
The real line: +		 * inserted later.
The real line: +		 */
The real line: +		arena_avail_tree_remove(runs_avail, &chunk->map[run_ind]);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_avail_tree_remove(runs_avail, &chunk->map[run_ind]);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		size += prun_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size += prun_size;
The real line: +		run_pages = size >> PAGE_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run_pages = size >> page_shift;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		assert((chunk->map[run_ind].bits & ~PAGE_MASK) == prun_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert((chunk->map[run_ind].bits & ~page_mask) == prun_size);
The real line: +		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
The real line: +		    CHUNK_MAP_FLAGS_MASK);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_flags_mask);
The real line: +		chunk->map[run_ind+run_pages-1].bits = size |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind+run_pages-1].bits = size |
The real line: +		    (chunk->map[run_ind+run_pages-1].bits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (chunk->map[run_ind+run_pages-1].bits &
The real line: +		    CHUNK_MAP_FLAGS_MASK);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_flags_mask);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Insert into runs_avail, now that coalescing is complete. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	arena_avail_tree_insert(runs_avail, &chunk->map[run_ind]);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_insert(runs_avail, &chunk->map[run_ind]);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Deallocate chunk if it is now completely unused.  The bit
The real line: +	 * manipulation checks whether the first run is unallocated and extends
The real line: +	 * to the end of the chunk.
The real line: +	 */
The real line: +	if ((chunk->map[arena_chunk_header_npages].bits & (~PAGE_MASK |
End Check: 1
LINE TO PARSE FOR KEYWORD:	if ((chunk->map[arena_chunk_header_npages].bits & (~page_mask |
The real line: +	    CHUNK_MAP_ALLOCATED)) == arena_maxclass)
End Check: 1
LINE TO PARSE FOR KEYWORD:	    chunk_map_allocated)) == arena_maxclass)
The real line: +		arena_chunk_dealloc(arena, chunk);
End Check: 1
LINE TO PARSE FOR KEYWORD:		arena_chunk_dealloc(arena, chunk);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * It is okay to do dirty page processing even if the chunk was
The real line: +	 * deallocated above, since in that case it is the spare.  Waiting
The real line: +	 * until after possible chunk deallocation to do dirty processing
The real line: +	 * allows for an old spare to be fully deallocated, thus decreasing the
The real line: +	 * chances of spuriously crossing the dirty page purging threshold.
The real line: +	 */
The real line: +	if (dirty) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (dirty) {
The real line: +		if (chunk->dirtied == false) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (chunk->dirtied == false) {
The real line: +			ql_tail_insert(&arena->chunks_dirty, chunk, link_dirty);
End Check: 3
LINE TO PARSE FOR KEYWORD:			ql_tail_insert(&arena->chunks_dirty, chunk, link_dirty);
The real line: +			chunk->dirtied = true;
End Check: 3
LINE TO PARSE FOR KEYWORD:			chunk->dirtied = true;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		arena_maybe_purge(arena);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_maybe_purge(arena);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
832 : 951
Next: (arena_t *arena, arena_run_t *run, bool dirty)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
Depths: 0:0
[]
The real line: +    size_t oldsize, size_t newsize)
Current Name Search:  static void arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run, 
LINE TO PARSE FOR KEYWORD:    size_t oldsize, size_t newsize)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize) 
Checking if function:  static void arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize) {
PATTERN 1
Function:  void arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> page_shift;
The real line: +	size_t head_npages = (oldsize - newsize) >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t head_npages = (oldsize - newsize) >> page_shift;
The real line: +	size_t flags = chunk->map[pageind].bits & CHUNK_MAP_FLAGS_MASK;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t flags = chunk->map[pageind].bits & chunk_map_flags_mask;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(oldsize > newsize);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(oldsize > newsize);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Update the chunk map so that arena_run_dalloc() can treat the
The real line: +	 * leading run as separately allocated.
The real line: +	 */
The real line: +	assert(chunk->map[pageind].bits & CHUNK_MAP_LARGE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk->map[pageind].bits & chunk_map_large);
The real line: +	assert(chunk->map[pageind].bits & CHUNK_MAP_ALLOCATED);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk->map[pageind].bits & chunk_map_allocated);
The real line: +	chunk->map[pageind].bits = (oldsize - newsize) | flags;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->map[pageind].bits = (oldsize - newsize) | flags;
The real line: +	chunk->map[pageind+head_npages].bits = newsize | flags;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->map[pageind+head_npages].bits = newsize | flags;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena_run_dalloc(arena, run, false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_dalloc(arena, run, false);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
956 : 973
Next: (arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
Depths: 0:0
[]
The real line: +    size_t oldsize, size_t newsize, bool dirty)
Current Name Search:  static void arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run, 
LINE TO PARSE FOR KEYWORD:    size_t oldsize, size_t newsize, bool dirty)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize, bool dirty) 
Checking if function:  static void arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize, bool dirty) {
PATTERN 1
Function:  void arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize, bool dirty) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> page_shift;
The real line: +	size_t npages = newsize >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t npages = newsize >> page_shift;
The real line: +	size_t flags = chunk->map[pageind].bits & CHUNK_MAP_FLAGS_MASK;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t flags = chunk->map[pageind].bits & chunk_map_flags_mask;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(oldsize > newsize);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(oldsize > newsize);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Update the chunk map so that arena_run_dalloc() can treat the
The real line: +	 * trailing run as separately allocated.
The real line: +	 */
The real line: +	assert(chunk->map[pageind].bits & CHUNK_MAP_LARGE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk->map[pageind].bits & chunk_map_large);
The real line: +	assert(chunk->map[pageind].bits & CHUNK_MAP_ALLOCATED);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk->map[pageind].bits & chunk_map_allocated);
The real line: +	chunk->map[pageind].bits = newsize | flags;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->map[pageind].bits = newsize | flags;
The real line: +	chunk->map[pageind+npages-1].bits = newsize | flags;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->map[pageind+npages-1].bits = newsize | flags;
The real line: +	chunk->map[pageind+npages].bits = (oldsize - newsize) | flags;
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->map[pageind+npages].bits = (oldsize - newsize) | flags;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena_run_dalloc(arena, (arena_run_t *)((uintptr_t)run + newsize),
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_dalloc(arena, (arena_run_t *)((uintptr_t)run + newsize),
The real line: +	    dirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    dirty);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
978 : 997
Next: (arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     size_t oldsize, size_t newsize, bool dirty)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static arena_run_t *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static arena_run_t *
Depths: 0:0
[]
The real line: +arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin)
Current Name Search:  static arena_run_t * 
LINE TO PARSE FOR KEYWORD:arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static arena_run_t * arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin) 
Checking if function:  static arena_run_t * arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin) {
PATTERN 1
Function:  arena_run_t * arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_map_t *mapelm;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_map_t *mapelm;
The real line: +	arena_run_t *run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_t *run;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Look for a usable run. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	mapelm = arena_run_tree_first(&bin->runs);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapelm = arena_run_tree_first(&bin->runs);
The real line: +	if (mapelm != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mapelm != null) {
The real line: +		arena_chunk_t *chunk;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *chunk;
The real line: +		size_t pageind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* run is guaranteed to have available space. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		arena_run_tree_remove(&bin->runs, mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_remove(&bin->runs, mapelm);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = (arena_chunk_t *)chunk_addr2base(mapelm);
The real line: +		pageind = (((uintptr_t)mapelm - (uintptr_t)chunk->map) /
End Check: 2
LINE TO PARSE FOR KEYWORD:		pageind = (((uintptr_t)mapelm - (uintptr_t)chunk->map) /
The real line: +		    sizeof(arena_chunk_map_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    sizeof(arena_chunk_map_t));
The real line: +		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
The real line: +		    (mapelm->bits >> PAGE_SHIFT))
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (mapelm->bits >> page_shift))
The real line: +		    << PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    << page_shift));
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		bin->stats.reruns++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->stats.reruns++;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	/* No existing runs have any space available. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Allocate a new run. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	malloc_mutex_unlock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&bin->lock);
The real line: +	/******************************/
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	run = arena_run_alloc(arena, bin->run_size, false, false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	run = arena_run_alloc(arena, bin->run_size, false, false);
The real line: +	if (run != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (run != null) {
The real line: +		/* Initialize run internals. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		run->bin = bin;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run->bin = bin;
The real line: +		run->avail = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run->avail = null;
The real line: +		run->next = (void *)(((uintptr_t)run) +
End Check: 2
LINE TO PARSE FOR KEYWORD:		run->next = (void *)(((uintptr_t)run) +
The real line: +		    (uintptr_t)bin->reg0_offset);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)bin->reg0_offset);
The real line: +		run->nfree = bin->nregs;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run->nfree = bin->nregs;
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +		run->magic = ARENA_RUN_MAGIC;
End Check: 2
LINE TO PARSE FOR KEYWORD:		run->magic = arena_run_magic;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +	/********************************/
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	malloc_mutex_lock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&bin->lock);
The real line: +	if (run != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (run != null) {
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		bin->stats.nruns++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->stats.nruns++;
The real line: +		bin->stats.curruns++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->stats.curruns++;
The real line: +		if (bin->stats.curruns > bin->stats.highruns)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (bin->stats.curruns > bin->stats.highruns)
The real line: +			bin->stats.highruns = bin->stats.curruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:			bin->stats.highruns = bin->stats.curruns;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * arena_run_alloc() failed, but another thread may have made
The real line: +	 * sufficient memory available while this one dopped bin->lock above,
The real line: +	 * so search one more time.
The real line: +	 */
The real line: +	mapelm = arena_run_tree_first(&bin->runs);
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapelm = arena_run_tree_first(&bin->runs);
The real line: +	if (mapelm != NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (mapelm != null) {
The real line: +		arena_chunk_t *chunk;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *chunk;
The real line: +		size_t pageind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* run is guaranteed to have available space. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		arena_run_tree_remove(&bin->runs, mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_remove(&bin->runs, mapelm);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = (arena_chunk_t *)chunk_addr2base(mapelm);
The real line: +		pageind = (((uintptr_t)mapelm - (uintptr_t)chunk->map) /
End Check: 2
LINE TO PARSE FOR KEYWORD:		pageind = (((uintptr_t)mapelm - (uintptr_t)chunk->map) /
The real line: +		    sizeof(arena_chunk_map_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    sizeof(arena_chunk_map_t));
The real line: +		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
End Check: 2
LINE TO PARSE FOR KEYWORD:		run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
The real line: +		    (mapelm->bits >> PAGE_SHIFT))
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (mapelm->bits >> page_shift))
The real line: +		    << PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    << page_shift));
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		bin->stats.reruns++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->stats.reruns++;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		return (run);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (run);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (null);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1001 : 1082
Next: (arena_t *arena, arena_bin_t *bin)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void *
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static void *
Depths: 0:0
[]
The real line: +arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin)
Current Name Search:   static void * 
LINE TO PARSE FOR KEYWORD:arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin)
Depths: 0:0
[]
The real line: +{
Current Name Search:   static void * arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin) 
Checking if function:   static void * arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin) {
PATTERN 1
Function:  void * arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	void *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ret;
The real line: +	arena_run_t *run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_t *run;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	bin->runcur = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->runcur = null;
The real line: +	run = arena_bin_nonfull_run_get(arena, bin);
End Check: 1
LINE TO PARSE FOR KEYWORD:	run = arena_bin_nonfull_run_get(arena, bin);
The real line: +	if (bin->runcur != NULL && bin->runcur->nfree > 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (bin->runcur != null && bin->runcur->nfree > 0) {
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Another thread updated runcur while this one ran without the
The real line: +		 * bin lock in arena_bin_nonfull_run_get().
The real line: +		 */
The real line: +		assert(bin->runcur->magic == ARENA_RUN_MAGIC);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(bin->runcur->magic == arena_run_magic);
The real line: +		assert(bin->runcur->nfree > 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(bin->runcur->nfree > 0);
The real line: +		ret = arena_run_reg_alloc(bin->runcur, bin);
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = arena_run_reg_alloc(bin->runcur, bin);
The real line: +		if (run != NULL) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (run != null) {
The real line: +			malloc_mutex_unlock(&bin->lock);
End Check: 3
LINE TO PARSE FOR KEYWORD:			malloc_mutex_unlock(&bin->lock);
The real line: +			malloc_mutex_lock(&arena->lock);
End Check: 3
LINE TO PARSE FOR KEYWORD:			malloc_mutex_lock(&arena->lock);
The real line: +			arena_run_dalloc(arena, run, false);
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_run_dalloc(arena, run, false);
The real line: +			malloc_mutex_unlock(&arena->lock);
End Check: 3
LINE TO PARSE FOR KEYWORD:			malloc_mutex_unlock(&arena->lock);
The real line: +			malloc_mutex_lock(&bin->lock);
End Check: 3
LINE TO PARSE FOR KEYWORD:			malloc_mutex_lock(&bin->lock);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		return (ret);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (ret);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (run == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (run == null)
The real line: +		return (NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (null);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	bin->runcur = run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->runcur = run;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(bin->runcur->magic == ARENA_RUN_MAGIC);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(bin->runcur->magic == arena_run_magic);
The real line: +	assert(bin->runcur->nfree > 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(bin->runcur->nfree > 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (arena_run_reg_alloc(bin->runcur, bin));
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (arena_run_reg_alloc(bin->runcur, bin));
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1087 : 1120
Next: (arena_t *arena, arena_bin_t *bin)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_PROF
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
Depths: 0:0
[]
The real line: +void
Current Name Search:  #ifdef JEMALLOC_PROF 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_prof_accum(arena_t *arena, uint64_t accumbytes)
Current Name Search:  #ifdef JEMALLOC_PROF void 
LINE TO PARSE FOR KEYWORD:arena_prof_accum(arena_t *arena, uint64_t accumbytes)
Depths: 0:0
[]
The real line: +{
Current Name Search:  #ifdef JEMALLOC_PROF void arena_prof_accum(arena_t *arena, uint64_t accumbytes) 
Checking if function:  #ifdef JEMALLOC_PROF void arena_prof_accum(arena_t *arena, uint64_t accumbytes) {
PATTERN 1
Function:  void arena_prof_accum(arena_t *arena, uint64_t accumbytes) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (prof_interval != 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (prof_interval != 0) {
The real line: +		arena->prof_accumbytes += accumbytes;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->prof_accumbytes += accumbytes;
The real line: +		if (arena->prof_accumbytes >= prof_interval) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (arena->prof_accumbytes >= prof_interval) {
The real line: +			prof_idump();
End Check: 3
LINE TO PARSE FOR KEYWORD:			prof_idump();
The real line: +			arena->prof_accumbytes -= prof_interval;
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena->prof_accumbytes -= prof_interval;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1125 : 1134
Next: (arena_t *arena, uint64_t accumbytes)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_TCACHE
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tcache
Depths: 0:0
[]
The real line: +void
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE void 
LINE TO PARSE FOR KEYWORD:arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind
Depths: 0:0
[]
The real line: +#  ifdef JEMALLOC_PROF
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind 
LINE TO PARSE FOR KEYWORD:#  ifdef jemalloc_prof
Depths: 0:0
[]
The real line: +    , uint64_t prof_accumbytes
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind #  ifdef JEMALLOC_PROF 
LINE TO PARSE FOR KEYWORD:    , uint64_t prof_accumbytes
Depths: 0:0
[]
The real line: +#  endif
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind #  ifdef JEMALLOC_PROF     , uint64_t prof_accumbytes 
LINE TO PARSE FOR KEYWORD:#  endif
Depths: 0:0
[]
The real line: +    )
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind #  ifdef JEMALLOC_PROF     , uint64_t prof_accumbytes #  endif 
LINE TO PARSE FOR KEYWORD:    )
Depths: 0:0
[]
The real line: +{
Current Name Search: #endif  #ifdef JEMALLOC_TCACHE void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind #  ifdef JEMALLOC_PROF     , uint64_t prof_accumbytes #  endif     ) 
Checking if function: #endif  #ifdef JEMALLOC_TCACHE void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind #  ifdef JEMALLOC_PROF     , uint64_t prof_accumbytes #  endif     ) {
PATTERN 1
Function:  void arena_tcache_fill_small(arena_t *arena, tcache_bin_t *tbin, size_t binind    JEMALLOC_PROF     , uint64_t prof_accumbytes   endif     ) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	unsigned i, nfill;
End Check: 1
LINE TO PARSE FOR KEYWORD:	unsigned i, nfill;
The real line: +	arena_bin_t *bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_bin_t *bin;
The real line: +	arena_run_t *run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_t *run;
The real line: +	void *ptr;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ptr;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(tbin->ncached == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(tbin->ncached == 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	arena_prof_accum(arena, prof_accumbytes);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_prof_accum(arena, prof_accumbytes);
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	bin = &arena->bins[binind];
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin = &arena->bins[binind];
The real line: +	malloc_mutex_lock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&bin->lock);
The real line: +	for (i = 0, nfill = (tbin->ncached_max >> 1); i < nfill; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0, nfill = (tbin->ncached_max >> 1); i < nfill; i++) {
The real line: +		if ((run = bin->runcur) != NULL && run->nfree > 0)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if ((run = bin->runcur) != null && run->nfree > 0)
The real line: +			ptr = arena_run_reg_alloc(run, bin);
End Check: 2
LINE TO PARSE FOR KEYWORD:			ptr = arena_run_reg_alloc(run, bin);
The real line: +		else
End Check: 2
LINE TO PARSE FOR KEYWORD:		else
The real line: +			ptr = arena_bin_malloc_hard(arena, bin);
End Check: 2
LINE TO PARSE FOR KEYWORD:			ptr = arena_bin_malloc_hard(arena, bin);
The real line: +		if (ptr == NULL)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (ptr == null)
The real line: +			break;
End Check: 2
LINE TO PARSE FOR KEYWORD:			break;
The real line: +		*(void **)ptr = tbin->avail;
End Check: 2
LINE TO PARSE FOR KEYWORD:		*(void **)ptr = tbin->avail;
The real line: +		tbin->avail = ptr;
End Check: 2
LINE TO PARSE FOR KEYWORD:		tbin->avail = ptr;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	bin->stats.allocated += (i - tbin->ncached) * bin->reg_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.allocated += (i - tbin->ncached) * bin->reg_size;
The real line: +	bin->stats.nmalloc += i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.nmalloc += i;
The real line: +	bin->stats.nrequests += tbin->tstats.nrequests;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.nrequests += tbin->tstats.nrequests;
The real line: +	bin->stats.nfills++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.nfills++;
The real line: +	tbin->tstats.nrequests = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	tbin->tstats.nrequests = 0;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	malloc_mutex_unlock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&bin->lock);
The real line: +	tbin->ncached = i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	tbin->ncached = i;
The real line: +	if (tbin->ncached > tbin->high_water)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (tbin->ncached > tbin->high_water)
The real line: +		tbin->high_water = tbin->ncached;
End Check: 1
LINE TO PARSE FOR KEYWORD:		tbin->high_water = tbin->ncached;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1144 : 1180
Next: (arena_t *arena, tcache_bin_t *tbin, size_t binind    JEMALLOC_PROF     , uint64_t prof_accumbytes   endif     )
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * Calculate bin->run_size such that it meets the following constraints:
The real line: + *
The real line: + *   *) bin->run_size >= min_run_size
The real line: + *   *) bin->run_size <= arena_maxclass
The real line: + *   *) run header overhead <= RUN_MAX_OVRHD (or header overhead relaxed).
The real line: + *   *) run header size < PAGE_SIZE
The real line: + *
The real line: + * bin->nregs and bin->reg0_offset are also calculated here, since these
The real line: + * settings are all interdependent.
The real line: + */
The real line: +static size_t
Current Name Search: #endif   
LINE TO PARSE FOR KEYWORD:static size_t
Depths: 0:0
[]
The real line: +arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size)
Current Name Search: #endif   static size_t 
LINE TO PARSE FOR KEYWORD:arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size)
Depths: 0:0
[]
The real line: +{
Current Name Search: #endif   static size_t arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size) 
Checking if function: #endif   static size_t arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size) {
PATTERN 1
Function:  size_t arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t try_run_size, good_run_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t try_run_size, good_run_size;
The real line: +	uint32_t try_nregs, good_nregs;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uint32_t try_nregs, good_nregs;
The real line: +	uint32_t try_hdr_size, good_hdr_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uint32_t try_hdr_size, good_hdr_size;
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	uint32_t try_cnt0_offset, good_cnt0_offset;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uint32_t try_cnt0_offset, good_cnt0_offset;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	uint32_t try_reg0_offset, good_reg0_offset;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uint32_t try_reg0_offset, good_reg0_offset;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(min_run_size >= PAGE_SIZE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(min_run_size >= page_size);
The real line: +	assert(min_run_size <= arena_maxclass);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(min_run_size <= arena_maxclass);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Calculate known-valid settings before entering the run_size
The real line: +	 * expansion loop, so that the first part of the loop always copies
The real line: +	 * valid settings.
The real line: +	 *
The real line: +	 * The do..while loop iteratively reduces the number of regions until
The real line: +	 * the run header and the regions no longer overlap.  A closed formula
The real line: +	 * would be quite messy, since there is an interdependency between the
The real line: +	 * header's mask length and the number of regions.
The real line: +	 */
The real line: +	try_run_size = min_run_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	try_run_size = min_run_size;
The real line: +	try_nregs = ((try_run_size - sizeof(arena_run_t)) / bin->reg_size)
End Check: 1
LINE TO PARSE FOR KEYWORD:	try_nregs = ((try_run_size - sizeof(arena_run_t)) / bin->reg_size)
The real line: +	    + 1; /* Counter-act try_nregs-- in loop. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	    + 1; 
The real line: +	do {
End Check: 2
LINE TO PARSE FOR KEYWORD:	do {
The real line: +		try_nregs--;
End Check: 2
LINE TO PARSE FOR KEYWORD:		try_nregs--;
The real line: +		try_hdr_size = sizeof(arena_run_t);
End Check: 2
LINE TO PARSE FOR KEYWORD:		try_hdr_size = sizeof(arena_run_t);
The real line: +#ifdef JEMALLOC_PROF
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +		if (opt_prof && prof_promote == false) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (opt_prof && prof_promote == false) {
The real line: +			/* Pad to a quantum boundary. */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			try_hdr_size = QUANTUM_CEILING(try_hdr_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:			try_hdr_size = quantum_ceiling(try_hdr_size);
The real line: +			try_cnt0_offset = try_hdr_size;
End Check: 3
LINE TO PARSE FOR KEYWORD:			try_cnt0_offset = try_hdr_size;
The real line: +			/* Add space for one (prof_thr_cnt_t *) per region. */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			try_hdr_size += try_nregs * sizeof(prof_thr_cnt_t *);
End Check: 3
LINE TO PARSE FOR KEYWORD:			try_hdr_size += try_nregs * sizeof(prof_thr_cnt_t *);
The real line: +		} else
End Check: 2
LINE TO PARSE FOR KEYWORD:		} else
The real line: +			try_cnt0_offset = 0;
End Check: 2
LINE TO PARSE FOR KEYWORD:			try_cnt0_offset = 0;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		try_reg0_offset = try_run_size - (try_nregs * bin->reg_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		try_reg0_offset = try_run_size - (try_nregs * bin->reg_size);
The real line: +	} while (try_hdr_size > try_reg0_offset);
End Check: 1
LINE TO PARSE FOR KEYWORD:	} while (try_hdr_size > try_reg0_offset);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* run_size expansion loop. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	do {
End Check: 2
LINE TO PARSE FOR KEYWORD:	do {
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Copy valid settings before trying more aggressive settings.
The real line: +		 */
The real line: +		good_run_size = try_run_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		good_run_size = try_run_size;
The real line: +		good_nregs = try_nregs;
End Check: 2
LINE TO PARSE FOR KEYWORD:		good_nregs = try_nregs;
The real line: +		good_hdr_size = try_hdr_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		good_hdr_size = try_hdr_size;
The real line: +#ifdef JEMALLOC_PROF
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +		good_cnt0_offset = try_cnt0_offset;
End Check: 2
LINE TO PARSE FOR KEYWORD:		good_cnt0_offset = try_cnt0_offset;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		good_reg0_offset = try_reg0_offset;
End Check: 2
LINE TO PARSE FOR KEYWORD:		good_reg0_offset = try_reg0_offset;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		/* Try more aggressive settings. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		try_run_size += PAGE_SIZE;
End Check: 2
LINE TO PARSE FOR KEYWORD:		try_run_size += page_size;
The real line: +		try_nregs = ((try_run_size - sizeof(arena_run_t)) /
End Check: 2
LINE TO PARSE FOR KEYWORD:		try_nregs = ((try_run_size - sizeof(arena_run_t)) /
The real line: +		    bin->reg_size) + 1; /* Counter-act try_nregs-- in loop. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		    bin->reg_size) + 1; 
The real line: +		do {
End Check: 3
LINE TO PARSE FOR KEYWORD:		do {
The real line: +			try_nregs--;
End Check: 3
LINE TO PARSE FOR KEYWORD:			try_nregs--;
The real line: +			try_hdr_size = sizeof(arena_run_t);
End Check: 3
LINE TO PARSE FOR KEYWORD:			try_hdr_size = sizeof(arena_run_t);
The real line: +#ifdef JEMALLOC_PROF
End Check: 3
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +			if (opt_prof && prof_promote == false) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (opt_prof && prof_promote == false) {
The real line: +				/* Pad to a quantum boundary. */
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				try_hdr_size = QUANTUM_CEILING(try_hdr_size);
End Check: 4
LINE TO PARSE FOR KEYWORD:				try_hdr_size = quantum_ceiling(try_hdr_size);
The real line: +				try_cnt0_offset = try_hdr_size;
End Check: 4
LINE TO PARSE FOR KEYWORD:				try_cnt0_offset = try_hdr_size;
The real line: +				/*
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				 * Add space for one (prof_thr_cnt_t *) per
The real line: +				 * region.
The real line: +				 */
The real line: +				try_hdr_size += try_nregs *
End Check: 4
LINE TO PARSE FOR KEYWORD:				try_hdr_size += try_nregs *
The real line: +				    sizeof(prof_thr_cnt_t *);
End Check: 4
LINE TO PARSE FOR KEYWORD:				    sizeof(prof_thr_cnt_t *);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +#endif
End Check: 3
LINE TO PARSE FOR KEYWORD:#endif
The real line: +			try_reg0_offset = try_run_size - (try_nregs *
End Check: 3
LINE TO PARSE FOR KEYWORD:			try_reg0_offset = try_run_size - (try_nregs *
The real line: +			    bin->reg_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    bin->reg_size);
The real line: +		} while (try_hdr_size > try_reg0_offset);
End Check: 2
LINE TO PARSE FOR KEYWORD:		} while (try_hdr_size > try_reg0_offset);
The real line: +	} while (try_run_size <= arena_maxclass
End Check: 1
LINE TO PARSE FOR KEYWORD:	} while (try_run_size <= arena_maxclass
The real line: +	    && try_run_size <= arena_maxclass
End Check: 1
LINE TO PARSE FOR KEYWORD:	    && try_run_size <= arena_maxclass
The real line: +	    && RUN_MAX_OVRHD * (bin->reg_size << 3) > RUN_MAX_OVRHD_RELAX
End Check: 1
LINE TO PARSE FOR KEYWORD:	    && run_max_ovrhd * (bin->reg_size << 3) > run_max_ovrhd_relax
The real line: +	    && (try_reg0_offset << RUN_BFP) > RUN_MAX_OVRHD * try_run_size
End Check: 1
LINE TO PARSE FOR KEYWORD:	    && (try_reg0_offset << run_bfp) > run_max_ovrhd * try_run_size
The real line: +	    && try_hdr_size < PAGE_SIZE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    && try_hdr_size < page_size);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(good_hdr_size <= good_reg0_offset);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(good_hdr_size <= good_reg0_offset);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Copy final settings. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	bin->run_size = good_run_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->run_size = good_run_size;
The real line: +	bin->nregs = good_nregs;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->nregs = good_nregs;
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	bin->cnt0_offset = good_cnt0_offset;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->cnt0_offset = good_cnt0_offset;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	bin->reg0_offset = good_reg0_offset;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->reg0_offset = good_reg0_offset;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (good_run_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (good_run_size);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1196 : 1290
Next: (arena_bin_t *bin, size_t min_run_size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void *
Depths: 0:0
[]
The real line: +arena_malloc_small(arena_t *arena, size_t size, bool zero)
Current Name Search:  void * 
LINE TO PARSE FOR KEYWORD:arena_malloc_small(arena_t *arena, size_t size, bool zero)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void * arena_malloc_small(arena_t *arena, size_t size, bool zero) 
Checking if function:  void * arena_malloc_small(arena_t *arena, size_t size, bool zero) {
PATTERN 4
Function: void * arena_malloc_small(arena_t *arena, size_t size, bool zero) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	void *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ret;
The real line: +	arena_bin_t *bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_bin_t *bin;
The real line: +	arena_run_t *run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_t *run;
The real line: +	size_t binind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t binind;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	binind = small_size2bin[size];
End Check: 1
LINE TO PARSE FOR KEYWORD:	binind = small_size2bin[size];
The real line: +	assert(binind < nbins);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(binind < nbins);
The real line: +	bin = &arena->bins[binind];
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin = &arena->bins[binind];
The real line: +	size = bin->reg_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size = bin->reg_size;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	malloc_mutex_lock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&bin->lock);
The real line: +	if ((run = bin->runcur) != NULL && run->nfree > 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if ((run = bin->runcur) != null && run->nfree > 0)
The real line: +		ret = arena_run_reg_alloc(run, bin);
End Check: 1
LINE TO PARSE FOR KEYWORD:		ret = arena_run_reg_alloc(run, bin);
The real line: +	else
End Check: 1
LINE TO PARSE FOR KEYWORD:	else
The real line: +		ret = arena_bin_malloc_hard(arena, bin);
End Check: 1
LINE TO PARSE FOR KEYWORD:		ret = arena_bin_malloc_hard(arena, bin);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (ret == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (ret == null) {
The real line: +		malloc_mutex_unlock(&bin->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&bin->lock);
The real line: +		return (NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (null);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	bin->stats.allocated += size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.allocated += size;
The real line: +	bin->stats.nmalloc++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.nmalloc++;
The real line: +	bin->stats.nrequests++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.nrequests++;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	malloc_mutex_unlock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&bin->lock);
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	if (isthreaded == false) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (isthreaded == false) {
The real line: +		malloc_mutex_lock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_lock(&arena->lock);
The real line: +		arena_prof_accum(arena, size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_prof_accum(arena, size);
The real line: +		malloc_mutex_unlock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&arena->lock);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (zero == false) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (zero == false) {
The real line: +#ifdef JEMALLOC_FILL
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +		if (opt_junk)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (opt_junk)
The real line: +			memset(ret, 0xa5, size);
End Check: 2
LINE TO PARSE FOR KEYWORD:			memset(ret, 0xa5, size);
The real line: +		else if (opt_zero)
End Check: 2
LINE TO PARSE FOR KEYWORD:		else if (opt_zero)
The real line: +			memset(ret, 0, size);
End Check: 2
LINE TO PARSE FOR KEYWORD:			memset(ret, 0, size);
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	} else
End Check: 1
LINE TO PARSE FOR KEYWORD:	} else
The real line: +		memset(ret, 0, size);
End Check: 1
LINE TO PARSE FOR KEYWORD:		memset(ret, 0, size);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1294 : 1341
Next: (arena_t *arena, size_t size, bool zero)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void *
Depths: 0:0
[]
The real line: +arena_malloc_large(arena_t *arena, size_t size, bool zero)
Current Name Search:  void * 
LINE TO PARSE FOR KEYWORD:arena_malloc_large(arena_t *arena, size_t size, bool zero)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void * arena_malloc_large(arena_t *arena, size_t size, bool zero) 
Checking if function:  void * arena_malloc_large(arena_t *arena, size_t size, bool zero) {
PATTERN 4
Function: void * arena_malloc_large(arena_t *arena, size_t size, bool zero) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	void *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ret;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Large allocation. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	size = PAGE_CEILING(size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	size = page_ceiling(size);
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	ret = (void *)arena_run_alloc(arena, size, true, zero);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = (void *)arena_run_alloc(arena, size, true, zero);
The real line: +	if (ret == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (ret == null) {
The real line: +		malloc_mutex_unlock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&arena->lock);
The real line: +		return (NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (null);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.nmalloc_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nmalloc_large++;
The real line: +	arena->stats.nrequests_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nrequests_large++;
The real line: +	arena->stats.allocated_large += size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.allocated_large += size;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nmalloc++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nmalloc++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nrequests++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nrequests++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].curruns++;
The real line: +	if (arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns >
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (arena->stats.lstats[(size >> page_shift) - 1].curruns >
The real line: +	    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    arena->stats.lstats[(size >> page_shift) - 1].highruns) {
The real line: +		arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns =
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.lstats[(size >> page_shift) - 1].highruns =
The real line: +		    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    arena->stats.lstats[(size >> page_shift) - 1].curruns;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	arena_prof_accum(arena, size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_prof_accum(arena, size);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (zero == false) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (zero == false) {
The real line: +#ifdef JEMALLOC_FILL
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +		if (opt_junk)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (opt_junk)
The real line: +			memset(ret, 0xa5, size);
End Check: 2
LINE TO PARSE FOR KEYWORD:			memset(ret, 0xa5, size);
The real line: +		else if (opt_zero)
End Check: 2
LINE TO PARSE FOR KEYWORD:		else if (opt_zero)
The real line: +			memset(ret, 0, size);
End Check: 2
LINE TO PARSE FOR KEYWORD:			memset(ret, 0, size);
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1345 : 1384
Next: (arena_t *arena, size_t size, bool zero)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void *
Depths: 0:0
[]
The real line: +arena_malloc(size_t size, bool zero)
Current Name Search:  void * 
LINE TO PARSE FOR KEYWORD:arena_malloc(size_t size, bool zero)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void * arena_malloc(size_t size, bool zero) 
Checking if function:  void * arena_malloc(size_t size, bool zero) {
PATTERN 4
Function: void * arena_malloc(size_t size, bool zero) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(size != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(size != 0);
The real line: +	assert(QUANTUM_CEILING(size) <= arena_maxclass);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(quantum_ceiling(size) <= arena_maxclass);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (size <= small_maxclass) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (size <= small_maxclass) {
The real line: +#ifdef JEMALLOC_TCACHE
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tcache
The real line: +		tcache_t *tcache;
End Check: 2
LINE TO PARSE FOR KEYWORD:		tcache_t *tcache;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if ((tcache = tcache_get()) != NULL)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if ((tcache = tcache_get()) != null)
The real line: +			return (tcache_alloc_small(tcache, size, zero));
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (tcache_alloc_small(tcache, size, zero));
The real line: +		else
End Check: 2
LINE TO PARSE FOR KEYWORD:		else
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +			return (arena_malloc_small(choose_arena(), size, zero));
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (arena_malloc_small(choose_arena(), size, zero));
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +#ifdef JEMALLOC_TCACHE
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tcache
The real line: +		if (size <= tcache_maxclass) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (size <= tcache_maxclass) {
The real line: +			tcache_t *tcache;
End Check: 3
LINE TO PARSE FOR KEYWORD:			tcache_t *tcache;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			if ((tcache = tcache_get()) != NULL)
End Check: 3
LINE TO PARSE FOR KEYWORD:			if ((tcache = tcache_get()) != null)
The real line: +				return (tcache_alloc_large(tcache, size, zero));
End Check: 3
LINE TO PARSE FOR KEYWORD:				return (tcache_alloc_large(tcache, size, zero));
The real line: +			else {
End Check: 4
LINE TO PARSE FOR KEYWORD:			else {
The real line: +				return (arena_malloc_large(choose_arena(),
End Check: 4
LINE TO PARSE FOR KEYWORD:				return (arena_malloc_large(choose_arena(),
The real line: +				    size, zero));
End Check: 4
LINE TO PARSE FOR KEYWORD:				    size, zero));
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		} else
End Check: 2
LINE TO PARSE FOR KEYWORD:		} else
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +			return (arena_malloc_large(choose_arena(), size, zero));
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (arena_malloc_large(choose_arena(), size, zero));
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1388 : 1418
Next: (size_t size, bool zero)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Only handles large allocations that require more than page alignment. */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void *
Current Name Search:   
LINE TO PARSE FOR KEYWORD:void *
Depths: 0:0
[]
The real line: +arena_palloc(arena_t *arena, size_t alignment, size_t size, size_t alloc_size)
Current Name Search:   void * 
LINE TO PARSE FOR KEYWORD:arena_palloc(arena_t *arena, size_t alignment, size_t size, size_t alloc_size)
Depths: 0:0
[]
The real line: +{
Current Name Search:   void * arena_palloc(arena_t *arena, size_t alignment, size_t size, size_t alloc_size) 
Checking if function:   void * arena_palloc(arena_t *arena, size_t alignment, size_t size, size_t alloc_size) {
PATTERN 4
Function: void * arena_palloc(arena_t *arena, size_t alignment, size_t size, size_t alloc_size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	void *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ret;
The real line: +	size_t offset;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t offset;
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert((size & PAGE_MASK) == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((size & page_mask) == 0);
The real line: +	assert((alignment & PAGE_MASK) == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((alignment & page_mask) == 0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	ret = (void *)arena_run_alloc(arena, alloc_size, true, false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = (void *)arena_run_alloc(arena, alloc_size, true, false);
The real line: +	if (ret == NULL) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (ret == null) {
The real line: +		malloc_mutex_unlock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&arena->lock);
The real line: +		return (NULL);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (null);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(ret);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	offset = (uintptr_t)ret & (alignment - 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:	offset = (uintptr_t)ret & (alignment - 1);
The real line: +	assert((offset & PAGE_MASK) == 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((offset & page_mask) == 0);
The real line: +	assert(offset < alloc_size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(offset < alloc_size);
The real line: +	if (offset == 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (offset == 0)
The real line: +		arena_run_trim_tail(arena, chunk, ret, alloc_size, size, false);
End Check: 1
LINE TO PARSE FOR KEYWORD:		arena_run_trim_tail(arena, chunk, ret, alloc_size, size, false);
The real line: +	else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	else {
The real line: +		size_t leadsize, trailsize;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t leadsize, trailsize;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		leadsize = alignment - offset;
End Check: 2
LINE TO PARSE FOR KEYWORD:		leadsize = alignment - offset;
The real line: +		if (leadsize > 0) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (leadsize > 0) {
The real line: +			arena_run_trim_head(arena, chunk, ret, alloc_size,
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_run_trim_head(arena, chunk, ret, alloc_size,
The real line: +			    alloc_size - leadsize);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    alloc_size - leadsize);
The real line: +			ret = (void *)((uintptr_t)ret + leadsize);
End Check: 3
LINE TO PARSE FOR KEYWORD:			ret = (void *)((uintptr_t)ret + leadsize);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		trailsize = alloc_size - leadsize - size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		trailsize = alloc_size - leadsize - size;
The real line: +		if (trailsize != 0) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (trailsize != 0) {
The real line: +			/* Trim trailing space. */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			assert(trailsize < alloc_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(trailsize < alloc_size);
The real line: +			arena_run_trim_tail(arena, chunk, ret, size + trailsize,
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_run_trim_tail(arena, chunk, ret, size + trailsize,
The real line: +			    size, false);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    size, false);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.nmalloc_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nmalloc_large++;
The real line: +	arena->stats.nrequests_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nrequests_large++;
The real line: +	arena->stats.allocated_large += size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.allocated_large += size;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nmalloc++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nmalloc++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nrequests++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nrequests++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].curruns++;
The real line: +	if (arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns >
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (arena->stats.lstats[(size >> page_shift) - 1].curruns >
The real line: +	    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    arena->stats.lstats[(size >> page_shift) - 1].highruns) {
The real line: +		arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns =
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.lstats[(size >> page_shift) - 1].highruns =
The real line: +		    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    arena->stats.lstats[(size >> page_shift) - 1].curruns;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_FILL
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +	if (opt_junk)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (opt_junk)
The real line: +		memset(ret, 0xa5, size);
End Check: 1
LINE TO PARSE FOR KEYWORD:		memset(ret, 0xa5, size);
The real line: +	else if (opt_zero)
End Check: 1
LINE TO PARSE FOR KEYWORD:	else if (opt_zero)
The real line: +		memset(ret, 0, size);
End Check: 1
LINE TO PARSE FOR KEYWORD:		memset(ret, 0, size);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1423 : 1486
Next: (arena_t *arena, size_t alignment, size_t size, size_t alloc_size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/* Return the size of the allocation pointed to by ptr. */
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +size_t
Current Name Search:   
LINE TO PARSE FOR KEYWORD:size_t
Depths: 0:0
[]
The real line: +arena_salloc(const void *ptr)
Current Name Search:   size_t 
LINE TO PARSE FOR KEYWORD:arena_salloc(const void *ptr)
Depths: 0:0
[]
The real line: +{
Current Name Search:   size_t arena_salloc(const void *ptr) 
Checking if function:   size_t arena_salloc(const void *ptr) {
PATTERN 4
Function: size_t arena_salloc(const void *ptr) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t ret;
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t pageind, mapbits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind, mapbits;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(ptr != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ptr != null);
The real line: +	assert(CHUNK_ADDR2BASE(ptr) != ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk_addr2base(ptr) != ptr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(ptr);
The real line: +	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift);
The real line: +	mapbits = chunk->map[pageind].bits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapbits = chunk->map[pageind].bits;
The real line: +	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((mapbits & chunk_map_allocated) != 0);
The real line: +	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if ((mapbits & chunk_map_large) == 0) {
The real line: +		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
The real line: +		    (uintptr_t)((pageind - (mapbits >> PAGE_SHIFT)) <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)((pageind - (mapbits >> page_shift)) <<
The real line: +		    PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift));
The real line: +		assert(run->magic == ARENA_RUN_MAGIC);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(run->magic == arena_run_magic);
The real line: +		assert(((uintptr_t)ptr - ((uintptr_t)run +
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(((uintptr_t)ptr - ((uintptr_t)run +
The real line: +		    (uintptr_t)run->bin->reg0_offset)) % run->bin->reg_size ==
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)run->bin->reg0_offset)) % run->bin->reg_size ==
The real line: +		    0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    0);
The real line: +		ret = run->bin->reg_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = run->bin->reg_size;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		assert(((uintptr_t)ptr & PAGE_MASK) == 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(((uintptr_t)ptr & page_mask) == 0);
The real line: +		ret = mapbits & ~PAGE_MASK;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = mapbits & ~page_mask;
The real line: +		assert(ret != 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(ret != 0);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1491 : 1519
Next: (const void *ptr)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_PROF
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
Depths: 0:0
[]
The real line: +void
Current Name Search:  #ifdef JEMALLOC_PROF 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_prof_promoted(const void *ptr, size_t size)
Current Name Search:  #ifdef JEMALLOC_PROF void 
LINE TO PARSE FOR KEYWORD:arena_prof_promoted(const void *ptr, size_t size)
Depths: 0:0
[]
The real line: +{
Current Name Search:  #ifdef JEMALLOC_PROF void arena_prof_promoted(const void *ptr, size_t size) 
Checking if function:  #ifdef JEMALLOC_PROF void arena_prof_promoted(const void *ptr, size_t size) {
PATTERN 1
Function:  void arena_prof_promoted(const void *ptr, size_t size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t pageind, binind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind, binind;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(ptr != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ptr != null);
The real line: +	assert(CHUNK_ADDR2BASE(ptr) != ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk_addr2base(ptr) != ptr);
The real line: +	assert(isalloc(ptr) == PAGE_SIZE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(isalloc(ptr) == page_size);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(ptr);
The real line: +	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift);
The real line: +	binind = small_size2bin[size];
End Check: 1
LINE TO PARSE FOR KEYWORD:	binind = small_size2bin[size];
The real line: +	assert(binind < nbins);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(binind < nbins);
The real line: +	chunk->map[pageind].bits = (chunk->map[pageind].bits &
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk->map[pageind].bits = (chunk->map[pageind].bits &
The real line: +	    ~CHUNK_MAP_CLASS_MASK) | (binind << CHUNK_MAP_CLASS_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    ~chunk_map_class_mask) | (binind << chunk_map_class_shift);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1524 : 1538
Next: (const void *ptr, size_t size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +size_t
Current Name Search:  
LINE TO PARSE FOR KEYWORD:size_t
Depths: 0:0
[]
The real line: +arena_salloc_demote(const void *ptr)
Current Name Search:  size_t 
LINE TO PARSE FOR KEYWORD:arena_salloc_demote(const void *ptr)
Depths: 0:0
[]
The real line: +{
Current Name Search:  size_t arena_salloc_demote(const void *ptr) 
Checking if function:  size_t arena_salloc_demote(const void *ptr) {
PATTERN 4
Function: size_t arena_salloc_demote(const void *ptr) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t ret;
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t pageind, mapbits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind, mapbits;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(ptr != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ptr != null);
The real line: +	assert(CHUNK_ADDR2BASE(ptr) != ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk_addr2base(ptr) != ptr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(ptr);
The real line: +	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift);
The real line: +	mapbits = chunk->map[pageind].bits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapbits = chunk->map[pageind].bits;
The real line: +	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((mapbits & chunk_map_allocated) != 0);
The real line: +	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if ((mapbits & chunk_map_large) == 0) {
The real line: +		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
The real line: +		    (uintptr_t)((pageind - (mapbits >> PAGE_SHIFT)) <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)((pageind - (mapbits >> page_shift)) <<
The real line: +		    PAGE_SHIFT));
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift));
The real line: +		assert(run->magic == ARENA_RUN_MAGIC);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(run->magic == arena_run_magic);
The real line: +		assert(((uintptr_t)ptr - ((uintptr_t)run +
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(((uintptr_t)ptr - ((uintptr_t)run +
The real line: +		    (uintptr_t)run->bin->reg0_offset)) % run->bin->reg_size ==
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (uintptr_t)run->bin->reg0_offset)) % run->bin->reg_size ==
The real line: +		    0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    0);
The real line: +		ret = run->bin->reg_size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = run->bin->reg_size;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		assert(((uintptr_t)ptr & PAGE_MASK) == 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(((uintptr_t)ptr & page_mask) == 0);
The real line: +		ret = mapbits & ~PAGE_MASK;
End Check: 2
LINE TO PARSE FOR KEYWORD:		ret = mapbits & ~page_mask;
The real line: +		if (prof_promote && ret == PAGE_SIZE && (mapbits &
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (prof_promote && ret == page_size && (mapbits &
The real line: +		    CHUNK_MAP_CLASS_MASK) != CHUNK_MAP_CLASS_MASK) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		    chunk_map_class_mask) != chunk_map_class_mask) {
The real line: +			size_t binind = ((mapbits & CHUNK_MAP_CLASS_MASK) >>
End Check: 3
LINE TO PARSE FOR KEYWORD:			size_t binind = ((mapbits & chunk_map_class_mask) >>
The real line: +			    CHUNK_MAP_CLASS_SHIFT);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    chunk_map_class_shift);
The real line: +			assert(binind < nbins);
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(binind < nbins);
The real line: +			ret = chunk->arena->bins[binind].reg_size;
End Check: 3
LINE TO PARSE FOR KEYWORD:			ret = chunk->arena->bins[binind].reg_size;
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +		assert(ret != 0);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(ret != 0);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1542 : 1577
Next: (const void *ptr)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static inline unsigned
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static inline unsigned
Depths: 0:0
[]
The real line: +arena_run_regind(arena_run_t *run, arena_bin_t *bin, const void *ptr,
Current Name Search:  static inline unsigned 
LINE TO PARSE FOR KEYWORD:arena_run_regind(arena_run_t *run, arena_bin_t *bin, const void *ptr,
Depths: 0:0
[]
The real line: +    size_t size)
Current Name Search:  static inline unsigned arena_run_regind(arena_run_t *run, arena_bin_t *bin, const void *ptr, 
LINE TO PARSE FOR KEYWORD:    size_t size)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static inline unsigned arena_run_regind(arena_run_t *run, arena_bin_t *bin, const void *ptr,     size_t size) 
Checking if function:  static inline unsigned arena_run_regind(arena_run_t *run, arena_bin_t *bin, const void *ptr,     size_t size) {
PATTERN 1
Function:  unsigned arena_run_regind(arena_run_t *run, arena_bin_t *bin,void *ptr,     size_t size) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	unsigned shift, diff, regind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	unsigned shift, diff, regind;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(run->magic == ARENA_RUN_MAGIC);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run->magic == arena_run_magic);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Avoid doing division with a variable divisor if possible.  Using
The real line: +	 * actual division here can reduce allocator throughput by over 20%!
The real line: +	 */
The real line: +	diff = (unsigned)((uintptr_t)ptr - (uintptr_t)run - bin->reg0_offset);
End Check: 1
LINE TO PARSE FOR KEYWORD:	diff = (unsigned)((uintptr_t)ptr - (uintptr_t)run - bin->reg0_offset);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Rescale (factor powers of 2 out of the numerator and denominator). */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	shift = ffs(size) - 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	shift = ffs(size) - 1;
The real line: +	diff >>= shift;
End Check: 1
LINE TO PARSE FOR KEYWORD:	diff >>= shift;
The real line: +	size >>= shift;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size >>= shift;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (size == 1) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (size == 1) {
The real line: +		/* The divisor was a power of 2. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		regind = diff;
End Check: 2
LINE TO PARSE FOR KEYWORD:		regind = diff;
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * To divide by a number D that is not a power of two we
The real line: +		 * multiply by (2^21 / D) and then right shift by 21 positions.
The real line: +		 *
The real line: +		 *   X / D
The real line: +		 *
The real line: +		 * becomes
The real line: +		 *
The real line: +		 *   (X * size_invs[D - 3]) >> SIZE_INV_SHIFT
The real line: +		 *
The real line: +		 * We can omit the first three elements, because we never
The real line: +		 * divide by 0, and 1 and 2 are both powers of two, which are
The real line: +		 * handled above.
The real line: +		 */
The real line: +#define	SIZE_INV_SHIFT 21
End Check: 2
LINE TO PARSE FOR KEYWORD:#define	size_inv_shift 21
The real line: +#define	SIZE_INV(s) (((1U << SIZE_INV_SHIFT) / (s)) + 1)
End Check: 2
LINE TO PARSE FOR KEYWORD:#define	size_inv(s) (((1u << size_inv_shift) / (s)) + 1)
The real line: +		static const unsigned size_invs[] = {
End Check: 3
LINE TO PARSE FOR KEYWORD:		static const unsigned size_invs[] = {
The real line: +		    SIZE_INV(3),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(3),
The real line: +		    SIZE_INV(4), SIZE_INV(5), SIZE_INV(6), SIZE_INV(7),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(4), size_inv(5), size_inv(6), size_inv(7),
The real line: +		    SIZE_INV(8), SIZE_INV(9), SIZE_INV(10), SIZE_INV(11),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(8), size_inv(9), size_inv(10), size_inv(11),
The real line: +		    SIZE_INV(12), SIZE_INV(13), SIZE_INV(14), SIZE_INV(15),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(12), size_inv(13), size_inv(14), size_inv(15),
The real line: +		    SIZE_INV(16), SIZE_INV(17), SIZE_INV(18), SIZE_INV(19),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(16), size_inv(17), size_inv(18), size_inv(19),
The real line: +		    SIZE_INV(20), SIZE_INV(21), SIZE_INV(22), SIZE_INV(23),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(20), size_inv(21), size_inv(22), size_inv(23),
The real line: +		    SIZE_INV(24), SIZE_INV(25), SIZE_INV(26), SIZE_INV(27),
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(24), size_inv(25), size_inv(26), size_inv(27),
The real line: +		    SIZE_INV(28), SIZE_INV(29), SIZE_INV(30), SIZE_INV(31)
End Check: 3
LINE TO PARSE FOR KEYWORD:		    size_inv(28), size_inv(29), size_inv(30), size_inv(31)
The real line: +		};
End Check: 2
LINE TO PARSE FOR KEYWORD:		};
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (size <= ((sizeof(size_invs) / sizeof(unsigned)) + 2))
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (size <= ((sizeof(size_invs) / sizeof(unsigned)) + 2))
The real line: +			regind = (diff * size_invs[size - 3]) >> SIZE_INV_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:			regind = (diff * size_invs[size - 3]) >> size_inv_shift;
The real line: +		else
End Check: 2
LINE TO PARSE FOR KEYWORD:		else
The real line: +			regind = diff / size;
End Check: 2
LINE TO PARSE FOR KEYWORD:			regind = diff / size;
The real line: +#undef SIZE_INV
End Check: 2
LINE TO PARSE FOR KEYWORD:#undef size_inv
The real line: +#undef SIZE_INV_SHIFT
End Check: 2
LINE TO PARSE FOR KEYWORD:#undef size_inv_shift
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	assert(diff == regind * size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(diff == regind * size);
The real line: +	assert(regind < bin->nregs);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(regind < bin->nregs);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (regind);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (regind);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1582 : 1640
Next: (arena_run_t *run, arena_bin_t *bin,void *ptr,     size_t size)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +prof_thr_cnt_t *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:prof_thr_cnt_t *
Depths: 0:0
[]
The real line: +arena_prof_cnt_get(const void *ptr)
Current Name Search:  prof_thr_cnt_t * 
LINE TO PARSE FOR KEYWORD:arena_prof_cnt_get(const void *ptr)
Depths: 0:0
[]
The real line: +{
Current Name Search:  prof_thr_cnt_t * arena_prof_cnt_get(const void *ptr) 
Checking if function:  prof_thr_cnt_t * arena_prof_cnt_get(const void *ptr) {
PATTERN 4
Function: prof_thr_cnt_t * arena_prof_cnt_get(const void *ptr) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	prof_thr_cnt_t *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	prof_thr_cnt_t *ret;
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t pageind, mapbits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind, mapbits;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(ptr != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ptr != null);
The real line: +	assert(CHUNK_ADDR2BASE(ptr) != ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk_addr2base(ptr) != ptr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(ptr);
The real line: +	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift);
The real line: +	mapbits = chunk->map[pageind].bits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapbits = chunk->map[pageind].bits;
The real line: +	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((mapbits & chunk_map_allocated) != 0);
The real line: +	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if ((mapbits & chunk_map_large) == 0) {
The real line: +		if (prof_promote)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (prof_promote)
The real line: +			ret = (prof_thr_cnt_t *)(uintptr_t)1U;
End Check: 2
LINE TO PARSE FOR KEYWORD:			ret = (prof_thr_cnt_t *)(uintptr_t)1u;
The real line: +		else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		else {
The real line: +			arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
The real line: +			    (uintptr_t)((pageind - (mapbits >> PAGE_SHIFT)) <<
End Check: 3
LINE TO PARSE FOR KEYWORD:			    (uintptr_t)((pageind - (mapbits >> page_shift)) <<
The real line: +			    PAGE_SHIFT));
End Check: 3
LINE TO PARSE FOR KEYWORD:			    page_shift));
The real line: +			arena_bin_t *bin = run->bin;
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_bin_t *bin = run->bin;
The real line: +			unsigned regind;
End Check: 3
LINE TO PARSE FOR KEYWORD:			unsigned regind;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			assert(run->magic == ARENA_RUN_MAGIC);
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(run->magic == arena_run_magic);
The real line: +			regind = arena_run_regind(run, bin, ptr, bin->reg_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:			regind = arena_run_regind(run, bin, ptr, bin->reg_size);
The real line: +			ret = *(prof_thr_cnt_t **)((uintptr_t)run +
End Check: 3
LINE TO PARSE FOR KEYWORD:			ret = *(prof_thr_cnt_t **)((uintptr_t)run +
The real line: +			    bin->cnt0_offset + (regind *
End Check: 3
LINE TO PARSE FOR KEYWORD:			    bin->cnt0_offset + (regind *
The real line: +			    sizeof(prof_thr_cnt_t *)));
End Check: 3
LINE TO PARSE FOR KEYWORD:			    sizeof(prof_thr_cnt_t *)));
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	} else
End Check: 1
LINE TO PARSE FOR KEYWORD:	} else
The real line: +		ret = chunk->map[pageind].prof_cnt;
End Check: 1
LINE TO PARSE FOR KEYWORD:		ret = chunk->map[pageind].prof_cnt;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1644 : 1676
Next: (const void *ptr)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_prof_cnt_set(const void *ptr, prof_thr_cnt_t *cnt)
Current Name Search:  void 
LINE TO PARSE FOR KEYWORD:arena_prof_cnt_set(const void *ptr, prof_thr_cnt_t *cnt)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void arena_prof_cnt_set(const void *ptr, prof_thr_cnt_t *cnt) 
Checking if function:  void arena_prof_cnt_set(const void *ptr, prof_thr_cnt_t *cnt) {
PATTERN 4
Function: void arena_prof_cnt_set(const void *ptr, prof_thr_cnt_t *cnt) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	arena_chunk_t *chunk;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_t *chunk;
The real line: +	size_t pageind, mapbits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind, mapbits;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(ptr != NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ptr != null);
The real line: +	assert(CHUNK_ADDR2BASE(ptr) != ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(chunk_addr2base(ptr) != ptr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	chunk = (arena_chunk_t *)chunk_addr2base(ptr);
The real line: +	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift);
The real line: +	mapbits = chunk->map[pageind].bits;
End Check: 1
LINE TO PARSE FOR KEYWORD:	mapbits = chunk->map[pageind].bits;
The real line: +	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert((mapbits & chunk_map_allocated) != 0);
The real line: +	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if ((mapbits & chunk_map_large) == 0) {
The real line: +		if (prof_promote == false) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (prof_promote == false) {
The real line: +			arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_run_t *run = (arena_run_t *)((uintptr_t)chunk +
The real line: +			    (uintptr_t)((pageind - (mapbits >> PAGE_SHIFT)) <<
End Check: 3
LINE TO PARSE FOR KEYWORD:			    (uintptr_t)((pageind - (mapbits >> page_shift)) <<
The real line: +			    PAGE_SHIFT));
End Check: 3
LINE TO PARSE FOR KEYWORD:			    page_shift));
The real line: +			arena_bin_t *bin = run->bin;
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_bin_t *bin = run->bin;
The real line: +			unsigned regind;
End Check: 3
LINE TO PARSE FOR KEYWORD:			unsigned regind;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			assert(run->magic == ARENA_RUN_MAGIC);
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(run->magic == arena_run_magic);
The real line: +			regind = arena_run_regind(run, bin, ptr, bin->reg_size);
End Check: 3
LINE TO PARSE FOR KEYWORD:			regind = arena_run_regind(run, bin, ptr, bin->reg_size);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			*((prof_thr_cnt_t **)((uintptr_t)run + bin->cnt0_offset
End Check: 3
LINE TO PARSE FOR KEYWORD:			*((prof_thr_cnt_t **)((uintptr_t)run + bin->cnt0_offset
The real line: +			    + (regind * sizeof(prof_thr_cnt_t *)))) = cnt;
End Check: 3
LINE TO PARSE FOR KEYWORD:			    + (regind * sizeof(prof_thr_cnt_t *)))) = cnt;
The real line: +		} else
End Check: 2
LINE TO PARSE FOR KEYWORD:		} else
The real line: +			assert((uintptr_t)cnt == (uintptr_t)1U);
End Check: 2
LINE TO PARSE FOR KEYWORD:			assert((uintptr_t)cnt == (uintptr_t)1u);
The real line: +	} else
End Check: 1
LINE TO PARSE FOR KEYWORD:	} else
The real line: +		chunk->map[pageind].prof_cnt = cnt;
End Check: 1
LINE TO PARSE FOR KEYWORD:		chunk->map[pageind].prof_cnt = cnt;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1680 : 1708
Next: (const void *ptr, prof_thr_cnt_t *cnt)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
Current Name Search: #endif  static void 
LINE TO PARSE FOR KEYWORD:arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
Depths: 0:0
[]
The real line: +    arena_bin_t *bin)
Current Name Search: #endif  static void arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run, 
LINE TO PARSE FOR KEYWORD:    arena_bin_t *bin)
Depths: 0:0
[]
The real line: +{
Current Name Search: #endif  static void arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     arena_bin_t *bin) 
Checking if function: #endif  static void arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     arena_bin_t *bin) {
PATTERN 1
Function:  void arena_dalloc_bin_run(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     arena_bin_t *bin) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t npages, run_ind, past;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t npages, run_ind, past;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Dissociate run from bin. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (run == bin->runcur)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (run == bin->runcur)
The real line: +		bin->runcur = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:		bin->runcur = null;
The real line: +	else if (bin->nregs != 1) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	else if (bin->nregs != 1) {
The real line: +		size_t run_pageind = (((uintptr_t)run - (uintptr_t)chunk)) >>
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t run_pageind = (((uintptr_t)run - (uintptr_t)chunk)) >>
The real line: +		    PAGE_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift;
The real line: +		arena_chunk_map_t *run_mapelm = &chunk->map[run_pageind];
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_map_t *run_mapelm = &chunk->map[run_pageind];
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * This block's conditional is necessary because if the run
The real line: +		 * only contains one region, then it never gets inserted into
The real line: +		 * the non-full runs tree.
The real line: +		 */
The real line: +		arena_run_tree_remove(&bin->runs, run_mapelm);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_remove(&bin->runs, run_mapelm);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	malloc_mutex_unlock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&bin->lock);
The real line: +	/******************************/
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	npages = bin->run_size >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	npages = bin->run_size >> page_shift;
The real line: +	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk) >> page_shift);
The real line: +	past = (size_t)(((uintptr_t)run->next - (uintptr_t)1U -
End Check: 1
LINE TO PARSE FOR KEYWORD:	past = (size_t)(((uintptr_t)run->next - (uintptr_t)1u -
The real line: +	    (uintptr_t)chunk) >> PAGE_SHIFT) + 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (uintptr_t)chunk) >> page_shift) + 1;
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * If the run was originally clean, and some pages were never touched,
The real line: +	 * trim the clean pages before deallocating the dirty portion of the
The real line: +	 * run.
The real line: +	 */
The real line: +	if ((chunk->map[run_ind].bits & CHUNK_MAP_DIRTY) == 0 && past - run_ind
End Check: 1
LINE TO PARSE FOR KEYWORD:	if ((chunk->map[run_ind].bits & chunk_map_dirty) == 0 && past - run_ind
The real line: +	    < npages) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    < npages) {
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Trim clean pages.  Convert to large run beforehand.  Set the
The real line: +		 * last map element first, in case this is a one-page run.
The real line: +		 */
The real line: +		chunk->map[run_ind+npages-1].bits = CHUNK_MAP_LARGE |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind+npages-1].bits = chunk_map_large |
The real line: +		    (chunk->map[run_ind].bits & CHUNK_MAP_FLAGS_MASK);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (chunk->map[run_ind].bits & chunk_map_flags_mask);
The real line: +		chunk->map[run_ind].bits = bin->run_size | CHUNK_MAP_LARGE |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[run_ind].bits = bin->run_size | chunk_map_large |
The real line: +		    (chunk->map[run_ind].bits & CHUNK_MAP_FLAGS_MASK);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    (chunk->map[run_ind].bits & chunk_map_flags_mask);
The real line: +		arena_run_trim_tail(arena, chunk, run, (npages << PAGE_SHIFT),
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_trim_tail(arena, chunk, run, (npages << page_shift),
The real line: +		    ((npages - (past - run_ind)) << PAGE_SHIFT), false);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    ((npages - (past - run_ind)) << page_shift), false);
The real line: +		npages = past - run_ind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		npages = past - run_ind;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	run->magic = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	run->magic = 0;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	arena_run_dalloc(arena, run, true);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_dalloc(arena, run, true);
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +	/****************************/
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	malloc_mutex_lock(&bin->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&bin->lock);
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	bin->stats.curruns--;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.curruns--;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1714 : 1769
Next: (arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,     arena_bin_t *bin)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
Current Name Search:  void 
LINE TO PARSE FOR KEYWORD:arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,
Depths: 0:0
[]
The real line: +    arena_chunk_map_t *mapelm)
Current Name Search:  void arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr, 
LINE TO PARSE FOR KEYWORD:    arena_chunk_map_t *mapelm)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,     arena_chunk_map_t *mapelm) 
Checking if function:  void arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,     arena_chunk_map_t *mapelm) {
PATTERN 4
Function: void arena_dalloc_bin(arena_t *arena, arena_chunk_t *chunk, void *ptr,     arena_chunk_map_t *mapelm) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t pageind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind;
The real line: +	arena_run_t *run;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_t *run;
The real line: +	arena_bin_t *bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_bin_t *bin;
The real line: +#if (defined(JEMALLOC_FILL) || defined(JEMALLOC_STATS))
End Check: 1
LINE TO PARSE FOR KEYWORD:#if (defined(jemalloc_fill) || defined(jemalloc_stats))
The real line: +	size_t size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t size;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift);
The real line: +	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
End Check: 1
LINE TO PARSE FOR KEYWORD:	run = (arena_run_t *)((uintptr_t)chunk + (uintptr_t)((pageind -
The real line: +	    (mapelm->bits >> PAGE_SHIFT)) << PAGE_SHIFT));
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (mapelm->bits >> page_shift)) << page_shift));
The real line: +	assert(run->magic == ARENA_RUN_MAGIC);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(run->magic == arena_run_magic);
The real line: +	bin = run->bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin = run->bin;
The real line: +#if (defined(JEMALLOC_FILL) || defined(JEMALLOC_STATS))
End Check: 1
LINE TO PARSE FOR KEYWORD:#if (defined(jemalloc_fill) || defined(jemalloc_stats))
The real line: +	size = bin->reg_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size = bin->reg_size;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_FILL
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +	if (opt_junk)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (opt_junk)
The real line: +		memset(ptr, 0x5a, size);
End Check: 1
LINE TO PARSE FOR KEYWORD:		memset(ptr, 0x5a, size);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena_run_reg_dalloc(run, ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_reg_dalloc(run, ptr);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (run->nfree == bin->nregs)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (run->nfree == bin->nregs)
The real line: +		arena_dalloc_bin_run(arena, chunk, run, bin);
End Check: 1
LINE TO PARSE FOR KEYWORD:		arena_dalloc_bin_run(arena, chunk, run, bin);
The real line: +	else if (run->nfree == 1 && run != bin->runcur) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	else if (run->nfree == 1 && run != bin->runcur) {
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * Make sure that bin->runcur always refers to the lowest
The real line: +		 * non-full run, if one exists.
The real line: +		 */
The real line: +		if (bin->runcur == NULL)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (bin->runcur == null)
The real line: +			bin->runcur = run;
End Check: 2
LINE TO PARSE FOR KEYWORD:			bin->runcur = run;
The real line: +		else if ((uintptr_t)run < (uintptr_t)bin->runcur) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		else if ((uintptr_t)run < (uintptr_t)bin->runcur) {
The real line: +			/* Switch runcur. */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			if (bin->runcur->nfree > 0) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (bin->runcur->nfree > 0) {
The real line: +				arena_chunk_t *runcur_chunk =
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena_chunk_t *runcur_chunk =
The real line: +				    CHUNK_ADDR2BASE(bin->runcur);
End Check: 4
LINE TO PARSE FOR KEYWORD:				    chunk_addr2base(bin->runcur);
The real line: +				size_t runcur_pageind =
End Check: 4
LINE TO PARSE FOR KEYWORD:				size_t runcur_pageind =
The real line: +				    (((uintptr_t)bin->runcur -
End Check: 4
LINE TO PARSE FOR KEYWORD:				    (((uintptr_t)bin->runcur -
The real line: +				    (uintptr_t)runcur_chunk)) >> PAGE_SHIFT;
End Check: 4
LINE TO PARSE FOR KEYWORD:				    (uintptr_t)runcur_chunk)) >> page_shift;
The real line: +				arena_chunk_map_t *runcur_mapelm =
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena_chunk_map_t *runcur_mapelm =
The real line: +				    &runcur_chunk->map[runcur_pageind];
End Check: 4
LINE TO PARSE FOR KEYWORD:				    &runcur_chunk->map[runcur_pageind];
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +				/* Insert runcur. */
End Check: 4
LINE TO PARSE FOR KEYWORD:				
The real line: +				arena_run_tree_insert(&bin->runs,
End Check: 4
LINE TO PARSE FOR KEYWORD:				arena_run_tree_insert(&bin->runs,
The real line: +				    runcur_mapelm);
End Check: 4
LINE TO PARSE FOR KEYWORD:				    runcur_mapelm);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +			bin->runcur = run;
End Check: 3
LINE TO PARSE FOR KEYWORD:			bin->runcur = run;
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +			size_t run_pageind = (((uintptr_t)run -
End Check: 3
LINE TO PARSE FOR KEYWORD:			size_t run_pageind = (((uintptr_t)run -
The real line: +			    (uintptr_t)chunk)) >> PAGE_SHIFT;
End Check: 3
LINE TO PARSE FOR KEYWORD:			    (uintptr_t)chunk)) >> page_shift;
The real line: +			arena_chunk_map_t *run_mapelm =
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_chunk_map_t *run_mapelm =
The real line: +			    &chunk->map[run_pageind];
End Check: 3
LINE TO PARSE FOR KEYWORD:			    &chunk->map[run_pageind];
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +			assert(arena_run_tree_search(&bin->runs, run_mapelm) ==
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(arena_run_tree_search(&bin->runs, run_mapelm) ==
The real line: +			    NULL);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    null);
The real line: +			arena_run_tree_insert(&bin->runs, run_mapelm);
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_run_tree_insert(&bin->runs, run_mapelm);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	bin->stats.allocated -= size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.allocated -= size;
The real line: +	bin->stats.ndalloc++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	bin->stats.ndalloc++;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1774 : 1839
Next: (arena_t *arena, arena_chunk_t *chunk, void *ptr,     arena_chunk_map_t *mapelm)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_STATS
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
Depths: 0:0
[]
The real line: +void
Current Name Search:  #ifdef JEMALLOC_STATS 
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty,
Current Name Search:  #ifdef JEMALLOC_STATS void 
LINE TO PARSE FOR KEYWORD:arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty,
Depths: 0:0
[]
The real line: +    arena_stats_t *astats, malloc_bin_stats_t *bstats,
Current Name Search:  #ifdef JEMALLOC_STATS void arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty, 
LINE TO PARSE FOR KEYWORD:    arena_stats_t *astats, malloc_bin_stats_t *bstats,
Depths: 0:0
[]
The real line: +    malloc_large_stats_t *lstats)
Current Name Search:  #ifdef JEMALLOC_STATS void arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty,     arena_stats_t *astats, malloc_bin_stats_t *bstats, 
LINE TO PARSE FOR KEYWORD:    malloc_large_stats_t *lstats)
Depths: 0:0
[]
The real line: +{
Current Name Search:  #ifdef JEMALLOC_STATS void arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty,     arena_stats_t *astats, malloc_bin_stats_t *bstats,     malloc_large_stats_t *lstats) 
Checking if function:  #ifdef JEMALLOC_STATS void arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty,     arena_stats_t *astats, malloc_bin_stats_t *bstats,     malloc_large_stats_t *lstats) {
PATTERN 1
Function:  void arena_stats_merge(arena_t *arena, size_t *nactive, size_t *ndirty,     arena_stats_t *astats, malloc_bin_stats_t *bstats,     malloc_large_stats_t *lstats) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	unsigned i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	unsigned i;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	*nactive += arena->nactive;
End Check: 1
LINE TO PARSE FOR KEYWORD:	*nactive += arena->nactive;
The real line: +	*ndirty += arena->ndirty;
End Check: 1
LINE TO PARSE FOR KEYWORD:	*ndirty += arena->ndirty;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	astats->mapped += arena->stats.mapped;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->mapped += arena->stats.mapped;
The real line: +	astats->npurge += arena->stats.npurge;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->npurge += arena->stats.npurge;
The real line: +	astats->nmadvise += arena->stats.nmadvise;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->nmadvise += arena->stats.nmadvise;
The real line: +	astats->purged += arena->stats.purged;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->purged += arena->stats.purged;
The real line: +	astats->allocated_large += arena->stats.allocated_large;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->allocated_large += arena->stats.allocated_large;
The real line: +	astats->nmalloc_large += arena->stats.nmalloc_large;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->nmalloc_large += arena->stats.nmalloc_large;
The real line: +	astats->ndalloc_large += arena->stats.ndalloc_large;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->ndalloc_large += arena->stats.ndalloc_large;
The real line: +	astats->nrequests_large += arena->stats.nrequests_large;
End Check: 1
LINE TO PARSE FOR KEYWORD:	astats->nrequests_large += arena->stats.nrequests_large;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < nlclasses; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < nlclasses; i++) {
The real line: +		lstats[i].nmalloc += arena->stats.lstats[i].nmalloc;
End Check: 2
LINE TO PARSE FOR KEYWORD:		lstats[i].nmalloc += arena->stats.lstats[i].nmalloc;
The real line: +		lstats[i].ndalloc += arena->stats.lstats[i].ndalloc;
End Check: 2
LINE TO PARSE FOR KEYWORD:		lstats[i].ndalloc += arena->stats.lstats[i].ndalloc;
The real line: +		lstats[i].nrequests += arena->stats.lstats[i].nrequests;
End Check: 2
LINE TO PARSE FOR KEYWORD:		lstats[i].nrequests += arena->stats.lstats[i].nrequests;
The real line: +		lstats[i].highruns += arena->stats.lstats[i].highruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		lstats[i].highruns += arena->stats.lstats[i].highruns;
The real line: +		lstats[i].curruns += arena->stats.lstats[i].curruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		lstats[i].curruns += arena->stats.lstats[i].curruns;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	for (i = 0; i < nbins; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (i = 0; i < nbins; i++) {
The real line: +		arena_bin_t *bin = &arena->bins[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_bin_t *bin = &arena->bins[i];
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		malloc_mutex_lock(&bin->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_lock(&bin->lock);
The real line: +		bstats[i].allocated += bin->stats.allocated;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].allocated += bin->stats.allocated;
The real line: +		bstats[i].nmalloc += bin->stats.nmalloc;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].nmalloc += bin->stats.nmalloc;
The real line: +		bstats[i].ndalloc += bin->stats.ndalloc;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].ndalloc += bin->stats.ndalloc;
The real line: +		bstats[i].nrequests += bin->stats.nrequests;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].nrequests += bin->stats.nrequests;
The real line: +#ifdef JEMALLOC_TCACHE
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tcache
The real line: +		bstats[i].nfills += bin->stats.nfills;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].nfills += bin->stats.nfills;
The real line: +		bstats[i].nflushes += bin->stats.nflushes;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].nflushes += bin->stats.nflushes;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		bstats[i].nruns += bin->stats.nruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].nruns += bin->stats.nruns;
The real line: +		bstats[i].reruns += bin->stats.reruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].reruns += bin->stats.reruns;
The real line: +		bstats[i].highruns += bin->stats.highruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].highruns += bin->stats.highruns;
The real line: +		bstats[i].curruns += bin->stats.curruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bstats[i].curruns += bin->stats.curruns;
The real line: +		malloc_mutex_unlock(&bin->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&bin->lock);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1846 : 1889
Next: (arena_t *arena, size_t *nactive, size_t *ndirty,     arena_stats_t *astats, malloc_bin_stats_t *bstats,     malloc_large_stats_t *lstats)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:void
Depths: 0:0
[]
The real line: +arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
Current Name Search: #endif  void 
LINE TO PARSE FOR KEYWORD:arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
Depths: 0:0
[]
The real line: +{
Current Name Search: #endif  void arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr) 
Checking if function: #endif  void arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr) {
PATTERN 1
Function:  void arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Large allocation. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +#ifdef JEMALLOC_FILL
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +#  ifndef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#  ifndef jemalloc_stats
The real line: +	if (opt_junk)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (opt_junk)
The real line: +#  endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#  endif
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	{
End Check: 2
LINE TO PARSE FOR KEYWORD:	{
The real line: +#if (defined(JEMALLOC_FILL) || defined(JEMALLOC_STATS))
End Check: 2
LINE TO PARSE FOR KEYWORD:#if (defined(jemalloc_fill) || defined(jemalloc_stats))
The real line: +		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
The real line: +		    PAGE_SHIFT;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    page_shift;
The real line: +		size_t size = chunk->map[pageind].bits & ~PAGE_MASK;
End Check: 2
LINE TO PARSE FOR KEYWORD:		size_t size = chunk->map[pageind].bits & ~page_mask;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_FILL
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +#  ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#  ifdef jemalloc_stats
The real line: +		if (opt_junk)
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (opt_junk)
The real line: +#  endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#  endif
The real line: +			memset(ptr, 0x5a, size);
End Check: 2
LINE TO PARSE FOR KEYWORD:			memset(ptr, 0x5a, size);
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		arena->stats.ndalloc_large++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.ndalloc_large++;
The real line: +		arena->stats.allocated_large -= size;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.allocated_large -= size;
The real line: +		arena->stats.lstats[(size >> PAGE_SHIFT) - 1].ndalloc++;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.lstats[(size >> page_shift) - 1].ndalloc++;
The real line: +		arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns--;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.lstats[(size >> page_shift) - 1].curruns--;
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena_run_dalloc(arena, (arena_run_t *)ptr, true);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_dalloc(arena, (arena_run_t *)ptr, true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1894 : 1924
Next: (arena_t *arena, arena_chunk_t *chunk, void *ptr)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static void
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,
Current Name Search:  static void 
LINE TO PARSE FOR KEYWORD:arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,
Depths: 0:0
[]
The real line: +    size_t size, size_t oldsize)
Current Name Search:  static void arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr, 
LINE TO PARSE FOR KEYWORD:    size_t size, size_t oldsize)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static void arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize) 
Checking if function:  static void arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize) {
PATTERN 1
Function:  void arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(size < oldsize);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(size < oldsize);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Shrink the run, and make trailing pages available for other
The real line: +	 * allocations.
The real line: +	 */
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	arena_run_trim_tail(arena, chunk, (arena_run_t *)ptr, oldsize, size,
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_run_trim_tail(arena, chunk, (arena_run_t *)ptr, oldsize, size,
The real line: +	    true);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    true);
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.ndalloc_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.ndalloc_large++;
The real line: +	arena->stats.allocated_large -= oldsize;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.allocated_large -= oldsize;
The real line: +	arena->stats.lstats[(oldsize >> PAGE_SHIFT) - 1].ndalloc++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(oldsize >> page_shift) - 1].ndalloc++;
The real line: +	arena->stats.lstats[(oldsize >> PAGE_SHIFT) - 1].curruns--;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(oldsize >> page_shift) - 1].curruns--;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena->stats.nmalloc_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nmalloc_large++;
The real line: +	arena->stats.nrequests_large++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.nrequests_large++;
The real line: +	arena->stats.allocated_large += size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.allocated_large += size;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nmalloc++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nmalloc++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nrequests++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nrequests++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].curruns++;
The real line: +	if (arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns >
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (arena->stats.lstats[(size >> page_shift) - 1].curruns >
The real line: +	    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    arena->stats.lstats[(size >> page_shift) - 1].highruns) {
The real line: +		arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns =
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena->stats.lstats[(size >> page_shift) - 1].highruns =
The real line: +		    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    arena->stats.lstats[(size >> page_shift) - 1].curruns;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1929 : 1959
Next: (arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static bool
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static bool
Depths: 0:0
[]
The real line: +arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,
Current Name Search:  static bool 
LINE TO PARSE FOR KEYWORD:arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,
Depths: 0:0
[]
The real line: +    size_t size, size_t oldsize)
Current Name Search:  static bool arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr, 
LINE TO PARSE FOR KEYWORD:    size_t size, size_t oldsize)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static bool arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize) 
Checking if function:  static bool arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize) {
PATTERN 1
Function:  bool arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> page_shift;
The real line: +	size_t npages = oldsize >> PAGE_SHIFT;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t npages = oldsize >> page_shift;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(oldsize == (chunk->map[pageind].bits & ~PAGE_MASK));
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(oldsize == (chunk->map[pageind].bits & ~page_mask));
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Try to extend the run. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	assert(size > oldsize);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(size > oldsize);
The real line: +	malloc_mutex_lock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_lock(&arena->lock);
The real line: +	if (pageind + npages < chunk_npages && (chunk->map[pageind+npages].bits
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (pageind + npages < chunk_npages && (chunk->map[pageind+npages].bits
The real line: +	    & CHUNK_MAP_ALLOCATED) == 0 && (chunk->map[pageind+npages].bits &
End Check: 1
LINE TO PARSE FOR KEYWORD:	    & chunk_map_allocated) == 0 && (chunk->map[pageind+npages].bits &
The real line: +	    ~PAGE_MASK) >= size - oldsize) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	    ~page_mask) >= size - oldsize) {
The real line: +		/*
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +		 * The next run is available and sufficiently large.  Split the
The real line: +		 * following run, then merge the first part with the existing
The real line: +		 * allocation.
The real line: +		 */
The real line: +		arena_run_split(arena, (arena_run_t *)((uintptr_t)chunk +
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_split(arena, (arena_run_t *)((uintptr_t)chunk +
The real line: +		    ((pageind+npages) << PAGE_SHIFT)), size - oldsize, true,
End Check: 2
LINE TO PARSE FOR KEYWORD:		    ((pageind+npages) << page_shift)), size - oldsize, true,
The real line: +		    false);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    false);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk->map[pageind].bits = size | CHUNK_MAP_LARGE |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[pageind].bits = size | chunk_map_large |
The real line: +		    CHUNK_MAP_ALLOCATED;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_allocated;
The real line: +		chunk->map[pageind+npages].bits = CHUNK_MAP_LARGE |
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk->map[pageind+npages].bits = chunk_map_large |
The real line: +		    CHUNK_MAP_ALLOCATED;
End Check: 2
LINE TO PARSE FOR KEYWORD:		    chunk_map_allocated;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	arena->stats.ndalloc_large++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.ndalloc_large++;
The real line: +	arena->stats.allocated_large -= oldsize;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.allocated_large -= oldsize;
The real line: +	arena->stats.lstats[(oldsize >> PAGE_SHIFT) - 1].ndalloc++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(oldsize >> page_shift) - 1].ndalloc++;
The real line: +	arena->stats.lstats[(oldsize >> PAGE_SHIFT) - 1].curruns--;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(oldsize >> page_shift) - 1].curruns--;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +	arena->stats.nmalloc_large++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.nmalloc_large++;
The real line: +	arena->stats.nrequests_large++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.nrequests_large++;
The real line: +	arena->stats.allocated_large += size;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.allocated_large += size;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nmalloc++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nmalloc++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].nrequests++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].nrequests++;
The real line: +	arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns++;
End Check: 2
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats[(size >> page_shift) - 1].curruns++;
The real line: +	if (arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns >
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (arena->stats.lstats[(size >> page_shift) - 1].curruns >
The real line: +	    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns) {
End Check: 3
LINE TO PARSE FOR KEYWORD:	    arena->stats.lstats[(size >> page_shift) - 1].highruns) {
The real line: +		arena->stats.lstats[(size >> PAGE_SHIFT) - 1].highruns =
End Check: 3
LINE TO PARSE FOR KEYWORD:		arena->stats.lstats[(size >> page_shift) - 1].highruns =
The real line: +		    arena->stats.lstats[(size >> PAGE_SHIFT) - 1].curruns;
End Check: 3
LINE TO PARSE FOR KEYWORD:		    arena->stats.lstats[(size >> page_shift) - 1].curruns;
The real line: +	}
End Check: 2
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		malloc_mutex_unlock(&arena->lock);
End Check: 2
LINE TO PARSE FOR KEYWORD:		malloc_mutex_unlock(&arena->lock);
The real line: +		return (false);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (false);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	malloc_mutex_unlock(&arena->lock);
End Check: 1
LINE TO PARSE FOR KEYWORD:	malloc_mutex_unlock(&arena->lock);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (true);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (true);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
1964 : 2014
Next: (arena_t *arena, arena_chunk_t *chunk, void *ptr,     size_t size, size_t oldsize)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +/*
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * Try to resize a large allocation, in order to avoid copying.  This will
The real line: + * always fail if growing an object, and the following run is already in use.
The real line: + */
The real line: +static bool
Current Name Search:   
LINE TO PARSE FOR KEYWORD:static bool
Depths: 0:0
[]
The real line: +arena_ralloc_large(void *ptr, size_t size, size_t oldsize)
Current Name Search:   static bool 
LINE TO PARSE FOR KEYWORD:arena_ralloc_large(void *ptr, size_t size, size_t oldsize)
Depths: 0:0
[]
The real line: +{
Current Name Search:   static bool arena_ralloc_large(void *ptr, size_t size, size_t oldsize) 
Checking if function:   static bool arena_ralloc_large(void *ptr, size_t size, size_t oldsize) {
PATTERN 1
Function:  bool arena_ralloc_large(void *ptr, size_t size, size_t oldsize) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t psize;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t psize;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	psize = PAGE_CEILING(size);
End Check: 1
LINE TO PARSE FOR KEYWORD:	psize = page_ceiling(size);
The real line: +	if (psize == oldsize) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (psize == oldsize) {
The real line: +		/* Same size class. */
End Check: 2
LINE TO PARSE FOR KEYWORD:		
The real line: +#ifdef JEMALLOC_FILL
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +		if (opt_junk && size < oldsize) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (opt_junk && size < oldsize) {
The real line: +			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize -
End Check: 3
LINE TO PARSE FOR KEYWORD:			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize -
The real line: +			    size);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    size);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +		return (false);
End Check: 2
LINE TO PARSE FOR KEYWORD:		return (false);
The real line: +	} else {
End Check: 2
LINE TO PARSE FOR KEYWORD:	} else {
The real line: +		arena_chunk_t *chunk;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_chunk_t *chunk;
The real line: +		arena_t *arena;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_t *arena;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
End Check: 2
LINE TO PARSE FOR KEYWORD:		chunk = (arena_chunk_t *)chunk_addr2base(ptr);
The real line: +		arena = chunk->arena;
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena = chunk->arena;
The real line: +		assert(arena->magic == ARENA_MAGIC);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(arena->magic == arena_magic);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		if (psize < oldsize) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (psize < oldsize) {
The real line: +#ifdef JEMALLOC_FILL
End Check: 3
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +			/* Fill before shrinking in order avoid a race. */
End Check: 3
LINE TO PARSE FOR KEYWORD:			
The real line: +			if (opt_junk) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (opt_junk) {
The real line: +				memset((void *)((uintptr_t)ptr + size), 0x5a,
End Check: 4
LINE TO PARSE FOR KEYWORD:				memset((void *)((uintptr_t)ptr + size), 0x5a,
The real line: +				    oldsize - size);
End Check: 4
LINE TO PARSE FOR KEYWORD:				    oldsize - size);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +#endif
End Check: 3
LINE TO PARSE FOR KEYWORD:#endif
The real line: +			arena_ralloc_large_shrink(arena, chunk, ptr, psize,
End Check: 3
LINE TO PARSE FOR KEYWORD:			arena_ralloc_large_shrink(arena, chunk, ptr, psize,
The real line: +			    oldsize);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    oldsize);
The real line: +			return (false);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return (false);
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +			bool ret = arena_ralloc_large_grow(arena, chunk, ptr,
End Check: 3
LINE TO PARSE FOR KEYWORD:			bool ret = arena_ralloc_large_grow(arena, chunk, ptr,
The real line: +			    psize, oldsize);
End Check: 3
LINE TO PARSE FOR KEYWORD:			    psize, oldsize);
The real line: +#ifdef JEMALLOC_FILL
End Check: 3
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +			if (ret == false && opt_zero) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (ret == false && opt_zero) {
The real line: +				memset((void *)((uintptr_t)ptr + oldsize), 0,
End Check: 4
LINE TO PARSE FOR KEYWORD:				memset((void *)((uintptr_t)ptr + oldsize), 0,
The real line: +				    size - oldsize);
End Check: 4
LINE TO PARSE FOR KEYWORD:				    size - oldsize);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +#endif
End Check: 3
LINE TO PARSE FOR KEYWORD:#endif
The real line: +			return (ret);
End Check: 3
LINE TO PARSE FOR KEYWORD:			return (ret);
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2022 : 2066
Next: (void *ptr, size_t size, size_t oldsize)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void *
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void *
Depths: 0:0
[]
The real line: +arena_ralloc(void *ptr, size_t size, size_t oldsize)
Current Name Search:  void * 
LINE TO PARSE FOR KEYWORD:arena_ralloc(void *ptr, size_t size, size_t oldsize)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void * arena_ralloc(void *ptr, size_t size, size_t oldsize) 
Checking if function:  void * arena_ralloc(void *ptr, size_t size, size_t oldsize) {
PATTERN 4
Function: void * arena_ralloc(void *ptr, size_t size, size_t oldsize) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	void *ret;
End Check: 1
LINE TO PARSE FOR KEYWORD:	void *ret;
The real line: +	size_t copysize;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t copysize;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Try to avoid moving the allocation. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	if (oldsize <= arena_maxclass) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (oldsize <= arena_maxclass) {
The real line: +		if (oldsize <= small_maxclass) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (oldsize <= small_maxclass) {
The real line: +			if (size <= small_maxclass && small_size2bin[size] ==
End Check: 3
LINE TO PARSE FOR KEYWORD:			if (size <= small_maxclass && small_size2bin[size] ==
The real line: +			    small_size2bin[oldsize])
End Check: 3
LINE TO PARSE FOR KEYWORD:			    small_size2bin[oldsize])
The real line: +				goto IN_PLACE;
End Check: 3
LINE TO PARSE FOR KEYWORD:				goto in_place;
The real line: +		} else {
End Check: 3
LINE TO PARSE FOR KEYWORD:		} else {
The real line: +			assert(size <= arena_maxclass);
End Check: 3
LINE TO PARSE FOR KEYWORD:			assert(size <= arena_maxclass);
The real line: +			if (size > small_maxclass) {
End Check: 4
LINE TO PARSE FOR KEYWORD:			if (size > small_maxclass) {
The real line: +				if (arena_ralloc_large(ptr, size, oldsize) ==
End Check: 4
LINE TO PARSE FOR KEYWORD:				if (arena_ralloc_large(ptr, size, oldsize) ==
The real line: +				    false)
End Check: 4
LINE TO PARSE FOR KEYWORD:				    false)
The real line: +					return (ptr);
End Check: 4
LINE TO PARSE FOR KEYWORD:					return (ptr);
The real line: +			}
End Check: 3
LINE TO PARSE FOR KEYWORD:			}
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * If we get here, then size and oldsize are different enough that we
The real line: +	 * need to move the object.  In that case, fall back to allocating new
The real line: +	 * space and copying.
The real line: +	 */
The real line: +	ret = arena_malloc(size, false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ret = arena_malloc(size, false);
The real line: +	if (ret == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (ret == null)
The real line: +		return (NULL);
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (null);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Junk/zero-filling were already done by arena_malloc(). */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	copysize = (size < oldsize) ? size : oldsize;
End Check: 1
LINE TO PARSE FOR KEYWORD:	copysize = (size < oldsize) ? size : oldsize;
The real line: +	memcpy(ret, ptr, copysize);
End Check: 1
LINE TO PARSE FOR KEYWORD:	memcpy(ret, ptr, copysize);
The real line: +	idalloc(ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	idalloc(ptr);
The real line: +	return (ret);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ret);
The real line: +IN_PLACE:
End Check: 1
LINE TO PARSE FOR KEYWORD:in_place:
The real line: +#ifdef JEMALLOC_FILL
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_fill
The real line: +	if (opt_junk && size < oldsize)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (opt_junk && size < oldsize)
The real line: +		memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize - size);
End Check: 1
LINE TO PARSE FOR KEYWORD:		memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize - size);
The real line: +	else if (opt_zero && size > oldsize)
End Check: 1
LINE TO PARSE FOR KEYWORD:	else if (opt_zero && size > oldsize)
The real line: +		memset((void *)((uintptr_t)ptr + oldsize), 0, size - oldsize);
End Check: 1
LINE TO PARSE FOR KEYWORD:		memset((void *)((uintptr_t)ptr + oldsize), 0, size - oldsize);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	return (ptr);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (ptr);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2070 : 2112
Next: (void *ptr, size_t size, size_t oldsize)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool
Current Name Search:  
LINE TO PARSE FOR KEYWORD:bool
Depths: 0:0
[]
The real line: +arena_new(arena_t *arena, unsigned ind)
Current Name Search:  bool 
LINE TO PARSE FOR KEYWORD:arena_new(arena_t *arena, unsigned ind)
Depths: 0:0
[]
The real line: +{
Current Name Search:  bool arena_new(arena_t *arena, unsigned ind) 
Checking if function:  bool arena_new(arena_t *arena, unsigned ind) {
PATTERN 4
Function: bool arena_new(arena_t *arena, unsigned ind) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	unsigned i;
End Check: 1
LINE TO PARSE FOR KEYWORD:	unsigned i;
The real line: +	arena_bin_t *bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_bin_t *bin;
The real line: +	size_t prev_run_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t prev_run_size;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena->ind = ind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->ind = ind;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (malloc_mutex_init(&arena->lock))
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (malloc_mutex_init(&arena->lock))
The real line: +		return (true);
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (true);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +	memset(&arena->stats, 0, sizeof(arena_stats_t));
End Check: 1
LINE TO PARSE FOR KEYWORD:	memset(&arena->stats, 0, sizeof(arena_stats_t));
The real line: +	arena->stats.lstats = (malloc_large_stats_t *)base_alloc(nlclasses *
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->stats.lstats = (malloc_large_stats_t *)base_alloc(nlclasses *
The real line: +	    sizeof(malloc_large_stats_t));
End Check: 1
LINE TO PARSE FOR KEYWORD:	    sizeof(malloc_large_stats_t));
The real line: +	if (arena->stats.lstats == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (arena->stats.lstats == null)
The real line: +		return (true);
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (true);
The real line: +	memset(arena->stats.lstats, 0, nlclasses *
End Check: 1
LINE TO PARSE FOR KEYWORD:	memset(arena->stats.lstats, 0, nlclasses *
The real line: +	    sizeof(malloc_large_stats_t));
End Check: 1
LINE TO PARSE FOR KEYWORD:	    sizeof(malloc_large_stats_t));
The real line: +#  ifdef JEMALLOC_TCACHE
End Check: 1
LINE TO PARSE FOR KEYWORD:#  ifdef jemalloc_tcache
The real line: +	ql_new(&arena->tcache_ql);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ql_new(&arena->tcache_ql);
The real line: +#  endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#  endif
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	arena->prof_accumbytes = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->prof_accumbytes = 0;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Initialize chunks. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	ql_new(&arena->chunks_dirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	ql_new(&arena->chunks_dirty);
The real line: +	arena->spare = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->spare = null;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena->nactive = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->nactive = 0;
The real line: +	arena->ndirty = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->ndirty = 0;
The real line: +	arena->npurgatory = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->npurgatory = 0;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	arena_avail_tree_new(&arena->runs_avail_clean);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_new(&arena->runs_avail_clean);
The real line: +	arena_avail_tree_new(&arena->runs_avail_dirty);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_avail_tree_new(&arena->runs_avail_dirty);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Initialize bins. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	prev_run_size = PAGE_SIZE;
End Check: 1
LINE TO PARSE FOR KEYWORD:	prev_run_size = page_size;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	i = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i = 0;
The real line: +#ifdef JEMALLOC_TINY
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tiny
The real line: +	/* (2^n)-spaced tiny bins. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i < ntbins; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < ntbins; i++) {
The real line: +		bin = &arena->bins[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin = &arena->bins[i];
The real line: +		if (malloc_mutex_init(&bin->lock))
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (malloc_mutex_init(&bin->lock))
The real line: +			return (true);
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (true);
The real line: +		bin->runcur = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->runcur = null;
The real line: +		arena_run_tree_new(&bin->runs);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_new(&bin->runs);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		bin->reg_size = (1U << (LG_TINY_MIN + i));
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->reg_size = (1u << (lg_tiny_min + i));
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Quantum-spaced bins. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i < ntbins + nqbins; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < ntbins + nqbins; i++) {
The real line: +		bin = &arena->bins[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin = &arena->bins[i];
The real line: +		if (malloc_mutex_init(&bin->lock))
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (malloc_mutex_init(&bin->lock))
The real line: +			return (true);
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (true);
The real line: +		bin->runcur = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->runcur = null;
The real line: +		arena_run_tree_new(&bin->runs);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_new(&bin->runs);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		bin->reg_size = (i - ntbins + 1) << LG_QUANTUM;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->reg_size = (i - ntbins + 1) << lg_quantum;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Cacheline-spaced bins. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i < ntbins + nqbins + ncbins; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < ntbins + nqbins + ncbins; i++) {
The real line: +		bin = &arena->bins[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin = &arena->bins[i];
The real line: +		if (malloc_mutex_init(&bin->lock))
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (malloc_mutex_init(&bin->lock))
The real line: +			return (true);
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (true);
The real line: +		bin->runcur = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->runcur = null;
The real line: +		arena_run_tree_new(&bin->runs);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_new(&bin->runs);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		bin->reg_size = cspace_min + ((i - (ntbins + nqbins)) <<
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->reg_size = cspace_min + ((i - (ntbins + nqbins)) <<
The real line: +		    LG_CACHELINE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    lg_cacheline);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Subpage-spaced bins. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i < nbins; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < nbins; i++) {
The real line: +		bin = &arena->bins[i];
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin = &arena->bins[i];
The real line: +		if (malloc_mutex_init(&bin->lock))
End Check: 2
LINE TO PARSE FOR KEYWORD:		if (malloc_mutex_init(&bin->lock))
The real line: +			return (true);
End Check: 2
LINE TO PARSE FOR KEYWORD:			return (true);
The real line: +		bin->runcur = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->runcur = null;
The real line: +		arena_run_tree_new(&bin->runs);
End Check: 2
LINE TO PARSE FOR KEYWORD:		arena_run_tree_new(&bin->runs);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		bin->reg_size = sspace_min + ((i - (ntbins + nqbins + ncbins))
End Check: 2
LINE TO PARSE FOR KEYWORD:		bin->reg_size = sspace_min + ((i - (ntbins + nqbins + ncbins))
The real line: +		    << LG_SUBPAGE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    << lg_subpage);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
End Check: 2
LINE TO PARSE FOR KEYWORD:		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_STATS
End Check: 2
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_stats
The real line: +		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
End Check: 2
LINE TO PARSE FOR KEYWORD:		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
The real line: +#endif
End Check: 2
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	arena->magic = ARENA_MAGIC;
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena->magic = arena_magic;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (false);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2116 : 2235
Next: (arena_t *arena, unsigned ind)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_TINY
Current Name Search:  
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tiny
Depths: 0:0
[]
The real line: +/* Compute the smallest power of 2 that is >= x. */
Current Name Search:  #ifdef JEMALLOC_TINY 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static size_t
Current Name Search:  #ifdef JEMALLOC_TINY  
LINE TO PARSE FOR KEYWORD:static size_t
Depths: 0:0
[]
The real line: +pow2_ceil(size_t x)
Current Name Search:  #ifdef JEMALLOC_TINY  static size_t 
LINE TO PARSE FOR KEYWORD:pow2_ceil(size_t x)
Depths: 0:0
[]
The real line: +{
Current Name Search:  #ifdef JEMALLOC_TINY  static size_t pow2_ceil(size_t x) 
Checking if function:  #ifdef JEMALLOC_TINY  static size_t pow2_ceil(size_t x) {
PATTERN 1
Function:  size_t pow2_ceil(size_t x) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	x--;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x--;
The real line: +	x |= x >> 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x |= x >> 1;
The real line: +	x |= x >> 2;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x |= x >> 2;
The real line: +	x |= x >> 4;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x |= x >> 4;
The real line: +	x |= x >> 8;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x |= x >> 8;
The real line: +	x |= x >> 16;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x |= x >> 16;
The real line: +#if (SIZEOF_PTR == 8)
End Check: 1
LINE TO PARSE FOR KEYWORD:#if (sizeof_ptr == 8)
The real line: +	x |= x >> 32;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x |= x >> 32;
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	x++;
End Check: 1
LINE TO PARSE FOR KEYWORD:	x++;
The real line: +	return (x);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (x);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2241 : 2254
Next: (size_t x)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#ifdef JEMALLOC_DEBUG
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
Depths: 0:0
[]
The real line: +static void
Current Name Search: #endif  #ifdef JEMALLOC_DEBUG 
LINE TO PARSE FOR KEYWORD:static void
Depths: 0:0
[]
The real line: +small_size2bin_validate(void)
Current Name Search: #endif  #ifdef JEMALLOC_DEBUG static void 
LINE TO PARSE FOR KEYWORD:small_size2bin_validate(void)
Depths: 0:0
[]
The real line: +{
Current Name Search: #endif  #ifdef JEMALLOC_DEBUG static void small_size2bin_validate(void) 
Checking if function: #endif  #ifdef JEMALLOC_DEBUG static void small_size2bin_validate(void) {
PATTERN 1
Function:  void small_size2bin_validate(void) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t i, size, binind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t i, size, binind;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(small_size2bin[0] == 0xffU);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(small_size2bin[0] == 0xffu);
The real line: +	i = 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i = 1;
The real line: +#  ifdef JEMALLOC_TINY
End Check: 1
LINE TO PARSE FOR KEYWORD:#  ifdef jemalloc_tiny
The real line: +	/* Tiny. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i < (1U << LG_TINY_MIN); i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < (1u << lg_tiny_min); i++) {
The real line: +		size = pow2_ceil(1U << LG_TINY_MIN);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = pow2_ceil(1u << lg_tiny_min);
The real line: +		binind = ffs((int)(size >> (LG_TINY_MIN + 1)));
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ffs((int)(size >> (lg_tiny_min + 1)));
The real line: +		assert(small_size2bin[i] == binind);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(small_size2bin[i] == binind);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	for (; i < qspace_min; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < qspace_min; i++) {
The real line: +		size = pow2_ceil(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = pow2_ceil(i);
The real line: +		binind = ffs((int)(size >> (LG_TINY_MIN + 1)));
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ffs((int)(size >> (lg_tiny_min + 1)));
The real line: +		assert(small_size2bin[i] == binind);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(small_size2bin[i] == binind);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#  endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#  endif
The real line: +	/* Quantum-spaced. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i <= qspace_max; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i <= qspace_max; i++) {
The real line: +		size = QUANTUM_CEILING(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = quantum_ceiling(i);
The real line: +		binind = ntbins + (size >> LG_QUANTUM) - 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ntbins + (size >> lg_quantum) - 1;
The real line: +		assert(small_size2bin[i] == binind);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(small_size2bin[i] == binind);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	/* Cacheline-spaced. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i <= cspace_max; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i <= cspace_max; i++) {
The real line: +		size = CACHELINE_CEILING(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = cacheline_ceiling(i);
The real line: +		binind = ntbins + nqbins + ((size - cspace_min) >>
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ntbins + nqbins + ((size - cspace_min) >>
The real line: +		    LG_CACHELINE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    lg_cacheline);
The real line: +		assert(small_size2bin[i] == binind);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(small_size2bin[i] == binind);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	/* Sub-page. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i <= sspace_max; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i <= sspace_max; i++) {
The real line: +		size = SUBPAGE_CEILING(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = subpage_ceiling(i);
The real line: +		binind = ntbins + nqbins + ncbins + ((size - sspace_min)
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ntbins + nqbins + ncbins + ((size - sspace_min)
The real line: +		    >> LG_SUBPAGE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    >> lg_subpage);
The real line: +		assert(small_size2bin[i] == binind);
End Check: 2
LINE TO PARSE FOR KEYWORD:		assert(small_size2bin[i] == binind);
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2260 : 2298
Next: (void)
The real line: +#endif
Current Name Search: 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: +
Current Name Search: #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static bool
Current Name Search: #endif  
LINE TO PARSE FOR KEYWORD:static bool
Depths: 0:0
[]
The real line: +small_size2bin_init(void)
Current Name Search: #endif  static bool 
LINE TO PARSE FOR KEYWORD:small_size2bin_init(void)
Depths: 0:0
[]
The real line: +{
Current Name Search: #endif  static bool small_size2bin_init(void) 
Checking if function: #endif  static bool small_size2bin_init(void) {
PATTERN 1
Function:  bool small_size2bin_init(void) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (opt_lg_qspace_max != LG_QSPACE_MAX_DEFAULT
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (opt_lg_qspace_max != lg_qspace_max_default
The real line: +	    || opt_lg_cspace_max != LG_CSPACE_MAX_DEFAULT
End Check: 1
LINE TO PARSE FOR KEYWORD:	    || opt_lg_cspace_max != lg_cspace_max_default
The real line: +	    || sizeof(const_small_size2bin) != small_maxclass + 1)
End Check: 1
LINE TO PARSE FOR KEYWORD:	    || sizeof(const_small_size2bin) != small_maxclass + 1)
The real line: +		return (small_size2bin_init_hard());
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (small_size2bin_init_hard());
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	small_size2bin = const_small_size2bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	small_size2bin = const_small_size2bin;
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	assert(sizeof(const_small_size2bin) == small_maxclass + 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(sizeof(const_small_size2bin) == small_maxclass + 1);
The real line: +	small_size2bin_validate();
End Check: 1
LINE TO PARSE FOR KEYWORD:	small_size2bin_validate();
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	return (false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (false);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2303 : 2316
Next: (void)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +static bool
Current Name Search:  
LINE TO PARSE FOR KEYWORD:static bool
Depths: 0:0
[]
The real line: +small_size2bin_init_hard(void)
Current Name Search:  static bool 
LINE TO PARSE FOR KEYWORD:small_size2bin_init_hard(void)
Depths: 0:0
[]
The real line: +{
Current Name Search:  static bool small_size2bin_init_hard(void) 
Checking if function:  static bool small_size2bin_init_hard(void) {
PATTERN 1
Function:  bool small_size2bin_init_hard(void) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t i, size, binind;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t i, size, binind;
The real line: +	uint8_t *custom_small_size2bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	uint8_t *custom_small_size2bin;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	assert(opt_lg_qspace_max != LG_QSPACE_MAX_DEFAULT
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(opt_lg_qspace_max != lg_qspace_max_default
The real line: +	    || opt_lg_cspace_max != LG_CSPACE_MAX_DEFAULT
End Check: 1
LINE TO PARSE FOR KEYWORD:	    || opt_lg_cspace_max != lg_cspace_max_default
The real line: +	    || sizeof(const_small_size2bin) != small_maxclass + 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    || sizeof(const_small_size2bin) != small_maxclass + 1);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	custom_small_size2bin = (uint8_t *)base_alloc(small_maxclass + 1);
End Check: 1
LINE TO PARSE FOR KEYWORD:	custom_small_size2bin = (uint8_t *)base_alloc(small_maxclass + 1);
The real line: +	if (custom_small_size2bin == NULL)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (custom_small_size2bin == null)
The real line: +		return (true);
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (true);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	custom_small_size2bin[0] = 0xffU;
End Check: 1
LINE TO PARSE FOR KEYWORD:	custom_small_size2bin[0] = 0xffu;
The real line: +	i = 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	i = 1;
The real line: +#ifdef JEMALLOC_TINY
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tiny
The real line: +	/* Tiny. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i < (1U << LG_TINY_MIN); i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < (1u << lg_tiny_min); i++) {
The real line: +		size = pow2_ceil(1U << LG_TINY_MIN);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = pow2_ceil(1u << lg_tiny_min);
The real line: +		binind = ffs((int)(size >> (LG_TINY_MIN + 1)));
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ffs((int)(size >> (lg_tiny_min + 1)));
The real line: +		custom_small_size2bin[i] = binind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		custom_small_size2bin[i] = binind;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	for (; i < qspace_min; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i < qspace_min; i++) {
The real line: +		size = pow2_ceil(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = pow2_ceil(i);
The real line: +		binind = ffs((int)(size >> (LG_TINY_MIN + 1)));
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ffs((int)(size >> (lg_tiny_min + 1)));
The real line: +		custom_small_size2bin[i] = binind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		custom_small_size2bin[i] = binind;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	/* Quantum-spaced. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i <= qspace_max; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i <= qspace_max; i++) {
The real line: +		size = QUANTUM_CEILING(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = quantum_ceiling(i);
The real line: +		binind = ntbins + (size >> LG_QUANTUM) - 1;
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ntbins + (size >> lg_quantum) - 1;
The real line: +		custom_small_size2bin[i] = binind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		custom_small_size2bin[i] = binind;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	/* Cacheline-spaced. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i <= cspace_max; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i <= cspace_max; i++) {
The real line: +		size = CACHELINE_CEILING(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = cacheline_ceiling(i);
The real line: +		binind = ntbins + nqbins + ((size - cspace_min) >>
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ntbins + nqbins + ((size - cspace_min) >>
The real line: +		    LG_CACHELINE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    lg_cacheline);
The real line: +		custom_small_size2bin[i] = binind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		custom_small_size2bin[i] = binind;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +	/* Sub-page. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	for (; i <= sspace_max; i++) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	for (; i <= sspace_max; i++) {
The real line: +		size = SUBPAGE_CEILING(i);
End Check: 2
LINE TO PARSE FOR KEYWORD:		size = subpage_ceiling(i);
The real line: +		binind = ntbins + nqbins + ncbins + ((size - sspace_min) >>
End Check: 2
LINE TO PARSE FOR KEYWORD:		binind = ntbins + nqbins + ncbins + ((size - sspace_min) >>
The real line: +		    LG_SUBPAGE);
End Check: 2
LINE TO PARSE FOR KEYWORD:		    lg_subpage);
The real line: +		custom_small_size2bin[i] = binind;
End Check: 2
LINE TO PARSE FOR KEYWORD:		custom_small_size2bin[i] = binind;
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	small_size2bin = custom_small_size2bin;
End Check: 1
LINE TO PARSE FOR KEYWORD:	small_size2bin = custom_small_size2bin;
The real line: +#ifdef JEMALLOC_DEBUG
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_debug
The real line: +	small_size2bin_validate();
End Check: 1
LINE TO PARSE FOR KEYWORD:	small_size2bin_validate();
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	return (false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (false);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2320 : 2373
Next: (void)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool
Current Name Search:  
LINE TO PARSE FOR KEYWORD:bool
Depths: 0:0
[]
The real line: +arena_boot(void)
Current Name Search:  bool 
LINE TO PARSE FOR KEYWORD:arena_boot(void)
Depths: 0:0
[]
The real line: +{
Current Name Search:  bool arena_boot(void) 
Checking if function:  bool arena_boot(void) {
PATTERN 4
Function: bool arena_boot(void) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +	size_t header_size;
End Check: 1
LINE TO PARSE FOR KEYWORD:	size_t header_size;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/* Set variables according to the value of opt_lg_[qc]space_max. */
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	qspace_max = (1U << opt_lg_qspace_max);
End Check: 1
LINE TO PARSE FOR KEYWORD:	qspace_max = (1u << opt_lg_qspace_max);
The real line: +	cspace_min = CACHELINE_CEILING(qspace_max);
End Check: 1
LINE TO PARSE FOR KEYWORD:	cspace_min = cacheline_ceiling(qspace_max);
The real line: +	if (cspace_min == qspace_max)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (cspace_min == qspace_max)
The real line: +		cspace_min += CACHELINE;
End Check: 1
LINE TO PARSE FOR KEYWORD:		cspace_min += cacheline;
The real line: +	cspace_max = (1U << opt_lg_cspace_max);
End Check: 1
LINE TO PARSE FOR KEYWORD:	cspace_max = (1u << opt_lg_cspace_max);
The real line: +	sspace_min = SUBPAGE_CEILING(cspace_max);
End Check: 1
LINE TO PARSE FOR KEYWORD:	sspace_min = subpage_ceiling(cspace_max);
The real line: +	if (sspace_min == cspace_max)
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (sspace_min == cspace_max)
The real line: +		sspace_min += SUBPAGE;
End Check: 1
LINE TO PARSE FOR KEYWORD:		sspace_min += subpage;
The real line: +	assert(sspace_min < PAGE_SIZE);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(sspace_min < page_size);
The real line: +	sspace_max = PAGE_SIZE - SUBPAGE;
End Check: 1
LINE TO PARSE FOR KEYWORD:	sspace_max = page_size - subpage;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +#ifdef JEMALLOC_TINY
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_tiny
The real line: +	assert(LG_QUANTUM >= LG_TINY_MIN);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(lg_quantum >= lg_tiny_min);
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	assert(ntbins <= LG_QUANTUM);
End Check: 1
LINE TO PARSE FOR KEYWORD:	assert(ntbins <= lg_quantum);
The real line: +	nqbins = qspace_max >> LG_QUANTUM;
End Check: 1
LINE TO PARSE FOR KEYWORD:	nqbins = qspace_max >> lg_quantum;
The real line: +	ncbins = ((cspace_max - cspace_min) >> LG_CACHELINE) + 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	ncbins = ((cspace_max - cspace_min) >> lg_cacheline) + 1;
The real line: +	nsbins = ((sspace_max - sspace_min) >> LG_SUBPAGE) + 1;
End Check: 1
LINE TO PARSE FOR KEYWORD:	nsbins = ((sspace_max - sspace_min) >> lg_subpage) + 1;
The real line: +	nbins = ntbins + nqbins + ncbins + nsbins;
End Check: 1
LINE TO PARSE FOR KEYWORD:	nbins = ntbins + nqbins + ncbins + nsbins;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * The small_size2bin lookup table uses uint8_t to encode each bin
The real line: +	 * index, so we cannot support more than 256 small size classes.  This
The real line: +	 * limit is difficult to exceed (not even possible with 16B quantum and
The real line: +	 * 4KiB pages), and such configurations are impractical, but
The real line: +	 * nonetheless we need to protect against this case in order to avoid
The real line: +	 * undefined behavior.
The real line: +	 *
The real line: +	 * Further constrain nbins to 255 if prof_promote is true, since all
The real line: +	 * small size classes, plus a "not small" size class must be stored in
The real line: +	 * 8 bits of arena_chunk_map_t's bits field.
The real line: +	 */
The real line: +#ifdef JEMALLOC_PROF
End Check: 1
LINE TO PARSE FOR KEYWORD:#ifdef jemalloc_prof
The real line: +	if (opt_prof && prof_promote) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (opt_prof && prof_promote) {
The real line: +		if (nbins > 255) {
End Check: 3
LINE TO PARSE FOR KEYWORD:		if (nbins > 255) {
The real line: +		    char line_buf[UMAX2S_BUFSIZE];
End Check: 3
LINE TO PARSE FOR KEYWORD:		    char line_buf[umax2s_bufsize];
The real line: +		    malloc_write("<jemalloc>: Too many small size classes (");
End Check: 3
LINE TO PARSE FOR KEYWORD:		    malloc_write();
The real line: +		    malloc_write(umax2s(nbins, 10, line_buf));
End Check: 3
LINE TO PARSE FOR KEYWORD:		    malloc_write(umax2s(nbins, 10, line_buf));
The real line: +		    malloc_write(" > max 255)\n");
End Check: 3
LINE TO PARSE FOR KEYWORD:		    malloc_write();
The real line: +		    abort();
End Check: 3
LINE TO PARSE FOR KEYWORD:		    abort();
The real line: +		}
End Check: 2
LINE TO PARSE FOR KEYWORD:		}
The real line: +	} else
End Check: 1
LINE TO PARSE FOR KEYWORD:	} else
The real line: +#endif
End Check: 1
LINE TO PARSE FOR KEYWORD:#endif
The real line: +	if (nbins > 256) {
End Check: 2
LINE TO PARSE FOR KEYWORD:	if (nbins > 256) {
The real line: +	    char line_buf[UMAX2S_BUFSIZE];
End Check: 2
LINE TO PARSE FOR KEYWORD:	    char line_buf[umax2s_bufsize];
The real line: +	    malloc_write("<jemalloc>: Too many small size classes (");
End Check: 2
LINE TO PARSE FOR KEYWORD:	    malloc_write();
The real line: +	    malloc_write(umax2s(nbins, 10, line_buf));
End Check: 2
LINE TO PARSE FOR KEYWORD:	    malloc_write(umax2s(nbins, 10, line_buf));
The real line: +	    malloc_write(" > max 256)\n");
End Check: 2
LINE TO PARSE FOR KEYWORD:	    malloc_write();
The real line: +	    abort();
End Check: 2
LINE TO PARSE FOR KEYWORD:	    abort();
The real line: +	}
End Check: 1
LINE TO PARSE FOR KEYWORD:	}
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	if (small_size2bin_init())
End Check: 1
LINE TO PARSE FOR KEYWORD:	if (small_size2bin_init())
The real line: +		return (true);
End Check: 1
LINE TO PARSE FOR KEYWORD:		return (true);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	/*
End Check: 1
LINE TO PARSE FOR KEYWORD:	
The real line: +	 * Compute the header size such that it is large enough to contain the
The real line: +	 * page map.
The real line: +	 */
The real line: +	header_size = sizeof(arena_chunk_t) +
End Check: 1
LINE TO PARSE FOR KEYWORD:	header_size = sizeof(arena_chunk_t) +
The real line: +	    (sizeof(arena_chunk_map_t) * (chunk_npages - 1));
End Check: 1
LINE TO PARSE FOR KEYWORD:	    (sizeof(arena_chunk_map_t) * (chunk_npages - 1));
The real line: +	arena_chunk_header_npages = (header_size >> PAGE_SHIFT) +
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_chunk_header_npages = (header_size >> page_shift) +
The real line: +	    ((header_size & PAGE_MASK) != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:	    ((header_size & page_mask) != 0);
The real line: +	arena_maxclass = chunksize -. (arena_chunk_header_npages << PAGE_SHIFT);
End Check: 1
LINE TO PARSE FOR KEYWORD:	arena_maxclass = chunksize - (arena_chunk_header_npages << page_shift);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +	return (false);
End Check: 1
LINE TO PARSE FOR KEYWORD:	return (false);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
2377 : 2446
Next: (void)
Chunk End.
The real line: -/* Copyright (c) 2007, Google Inc.
Current Name Search: 
LINE TO PARSE FOR KEYWORD:/* copyright (c) 2007, google inc.
Depths: 0:0
[]
The real line: - * All rights reserved.
Current Name Search: /* Copyright (c) 2007, Google Inc. 
LINE TO PARSE FOR KEYWORD: * all rights reserved.
Depths: 0:0
[]
The real line: - * 
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved. 
LINE TO PARSE FOR KEYWORD: * 
Depths: 0:0
[]
The real line: - * Redistribution and use in source and binary forms, with or without
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *  
LINE TO PARSE FOR KEYWORD: * redistribution and use in source and binary forms, with or without
Depths: 0:0
[]
The real line: - * modification, are permitted provided that the following conditions are
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without 
LINE TO PARSE FOR KEYWORD: * modification, are permitted provided that the following conditions are
Depths: 0:0
[]
The real line: - * met:
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are 
LINE TO PARSE FOR KEYWORD: * met:
Depths: 0:0
[]
The real line: - * 
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 
LINE TO PARSE FOR KEYWORD: * 
Depths: 0:0
[]
The real line: - *     * Redistributions of source code must retain the above copyright
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  
LINE TO PARSE FOR KEYWORD: *     * redistributions of source code must retain the above copyright
Depths: 0:0
[]
The real line: - * notice, this list of conditions and the following disclaimer.
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright 
LINE TO PARSE FOR KEYWORD: * notice, this list of conditions and the following disclaimer.
Depths: 0:0
[]
The real line: - *     * Redistributions in binary form must reproduce the above
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 
LINE TO PARSE FOR KEYWORD: *     * redistributions in binary form must reproduce the above
Depths: 0:0
[]
The real line: - * copyright notice, this list of conditions and the following disclaimer
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above 
LINE TO PARSE FOR KEYWORD: * copyright notice, this list of conditions and the following disclaimer
Depths: 0:0
[]
The real line: - * in the documentation and/or other materials provided with the
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer 
LINE TO PARSE FOR KEYWORD: * in the documentation and/or other materials provided with the
Depths: 0:0
[]
The real line: - * distribution.
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the 
LINE TO PARSE FOR KEYWORD: * distribution.
Depths: 0:0
[]
The real line: - *     * Neither the name of Google Inc. nor the names of its
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution. 
LINE TO PARSE FOR KEYWORD: *     * neither the name of google inc. nor the names of its
Depths: 0:0
[]
The real line: - * contributors may be used to endorse or promote products derived from
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its 
LINE TO PARSE FOR KEYWORD: * contributors may be used to endorse or promote products derived from
Depths: 0:0
[]
The real line: - * this software without specific prior written permission.
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from 
LINE TO PARSE FOR KEYWORD: * this software without specific prior written permission.
Depths: 0:0
[]
The real line: - * 
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission. 
LINE TO PARSE FOR KEYWORD: * 
Depths: 0:0
[]
The real line: - * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *  
LINE TO PARSE FOR KEYWORD: * this software is provided by the copyright holders and contributors
Depths: 0:0
[]
The real line: - * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
LINE TO PARSE FOR KEYWORD: *  and any express or implied warranties, including, but not
Depths: 0:0
[]
The real line: - * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LINE TO PARSE FOR KEYWORD: * limited to, the implied warranties of merchantability and fitness for
Depths: 0:0
[]
The real line: - * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
LINE TO PARSE FOR KEYWORD: * a particular purpose are disclaimed. in no event shall the copyright
Depths: 0:0
[]
The real line: - * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
LINE TO PARSE FOR KEYWORD: * owner or contributors be liable for any direct, indirect, incidental,
Depths: 0:0
[]
The real line: - * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
LINE TO PARSE FOR KEYWORD: * special, exemplary, or consequential damages (including, but not
Depths: 0:0
[]
The real line: - * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
LINE TO PARSE FOR KEYWORD: * limited to, procurement of substitute goods or services; loss of use,
Depths: 0:0
[]
The real line: - * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
LINE TO PARSE FOR KEYWORD: * data, or profits; or business interruption) however caused and on any
Depths: 0:0
[]
The real line: - * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
LINE TO PARSE FOR KEYWORD: * theory of liability, whether in contract, strict liability, or tort
Depths: 0:0
[]
The real line: - * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
LINE TO PARSE FOR KEYWORD: * (including negligence or otherwise) arising in any way out of the use
Depths: 0:0
[]
The real line: - * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
LINE TO PARSE FOR KEYWORD: * of this software, even if advised of the possibility of such damage.
Depths: 0:0
[]
The real line: - *
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
LINE TO PARSE FOR KEYWORD: *
Depths: 0:0
[]
The real line: - * ---
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  * 
LINE TO PARSE FOR KEYWORD: * ---
Depths: 0:0
[]
The real line: - * Author: Joi Sigurdsson
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * --- 
LINE TO PARSE FOR KEYWORD: * author: joi sigurdsson
Depths: 0:0
[]
The real line: - * Author: Scott Francis
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson 
LINE TO PARSE FOR KEYWORD: * author: scott francis
Depths: 0:0
[]
The real line: - *
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis 
LINE TO PARSE FOR KEYWORD: *
Depths: 0:0
[]
The real line: - * Definition of PreamblePatcher
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  * 
LINE TO PARSE FOR KEYWORD: * definition of preamblepatcher
Depths: 0:0
[]
The real line: - */
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher 
LINE TO PARSE FOR KEYWORD: */
Depths: 0:0
[]
The real line: -
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  
LINE TO PARSE FOR KEYWORD:#ifndef google_perftools_preamble_patcher_h_
Depths: 0:0
[]
The real line: -#define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ 
LINE TO PARSE FOR KEYWORD:#define google_perftools_preamble_patcher_h_
Depths: 0:0
[]
The real line: -
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#include "config.h"
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: -#include <windows.h>
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  
LINE TO PARSE FOR KEYWORD:#include <windows.h>
Depths: 0:0
[]
The real line: -
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// compatibility shim
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#include "base/logging.h"
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: -#define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond)
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  
LINE TO PARSE FOR KEYWORD:#define sidestep_assert(cond)  raw_dcheck(cond, #cond)
Depths: 0:0
[]
The real line: -#define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) 
LINE TO PARSE FOR KEYWORD:#define sidestep_log(msg)      raw_vlog(1, msg)
Depths: 0:0
[]
The real line: -
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// Maximum size of the preamble stub. We overwrite at least the first 5
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// bytes of the function. Considering the worst case scenario, we need 4
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// bytes + the max instruction size + 5 more bytes for our jump back to
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// the original code. With that in mind, 32 is a good number :)
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#ifdef _M_X64
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      
LINE TO PARSE FOR KEYWORD:#ifdef _m_x64
Depths: 0:0
[]
The real line: -// In 64-bit mode we may need more room.  In 64-bit mode all jumps must be
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// within +/-2GB of RIP.  Because of this limitation we may need to use a
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// trampoline to jump to the replacement function if it is further than 2GB
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// away from the target. The trampoline is 14 bytes.
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// So 4 bytes + max instruction size (17 bytes) + 5 bytes to jump back to the
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// original code + trampoline size.  64 bytes is a nice number :-)
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#define MAX_PREAMBLE_STUB_SIZE    (64)
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        
LINE TO PARSE FOR KEYWORD:#define max_preamble_stub_size    (64)
Depths: 0:0
[]
The real line: -#else
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) 
LINE TO PARSE FOR KEYWORD:#else
Depths: 0:0
[]
The real line: -#define MAX_PREAMBLE_STUB_SIZE    (32)
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) #else 
LINE TO PARSE FOR KEYWORD:#define max_preamble_stub_size    (32)
Depths: 0:0
[]
The real line: -#endif
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) #else #define MAX_PREAMBLE_STUB_SIZE    (32) 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: -
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) #else #define MAX_PREAMBLE_STUB_SIZE    (32) #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// Determines if this is a 64-bit binary.
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) #else #define MAX_PREAMBLE_STUB_SIZE    (32) #endif  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#ifdef _M_X64
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) #else #define MAX_PREAMBLE_STUB_SIZE    (32) #endif   
LINE TO PARSE FOR KEYWORD:#ifdef _m_x64
Depths: 0:0
[]
The real line: -static const bool kIs64BitBinary = true;
Current Name Search: /* Copyright (c) 2007, Google Inc.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *   *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *     * Neither the name of Google Inc. nor the names of its  * contributors may be used to endorse or promote products derived from  * this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * ---  * Author: Joi Sigurdsson  * Author: Scott Francis  *  * Definition of PreamblePatcher  */  #ifndef GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_ #define GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_  #include  #include <windows.h>   #include  #define SIDESTEP_ASSERT(cond)  RAW_DCHECK(cond, #cond) #define SIDESTEP_LOG(msg)      RAW_VLOG(1, msg)      #ifdef _M_X64        #define MAX_PREAMBLE_STUB_SIZE    (64) #else #define MAX_PREAMBLE_STUB_SIZE    (32) #endif   #ifdef _M_X64 
LINE TO PARSE FOR KEYWORD:static const bool kis64bitbinary = true;
Depths: 0:0
[]
The real line: -#else
Current Name Search: static const bool kIs64BitBinary = true; 
LINE TO PARSE FOR KEYWORD:#else
Depths: 0:0
[]
The real line: -static const bool kIs64BitBinary = false;
Current Name Search: static const bool kIs64BitBinary = true; #else 
LINE TO PARSE FOR KEYWORD:static const bool kis64bitbinary = false;
Depths: 0:0
[]
The real line: -#endif
Current Name Search: static const bool kIs64BitBinary = false; 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
[]
The real line: -
Current Name Search: static const bool kIs64BitBinary = false; #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -namespace sidestep {
Current Name Search: static const bool kIs64BitBinary = false; #endif  
LINE TO PARSE FOR KEYWORD:namespace sidestep {
Depths: 0:0
[]
The real line: -
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep { 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// Possible results of patching/unpatching
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -enum SideStepError {
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   
LINE TO PARSE FOR KEYWORD:enum sidesteperror {
Depths: 0:0
[]
The real line: -  SIDESTEP_SUCCESS = 0,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError { 
LINE TO PARSE FOR KEYWORD:  sidestep_success = 0,
Depths: 0:0
[]
The real line: -  SIDESTEP_INVALID_PARAMETER,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0, 
LINE TO PARSE FOR KEYWORD:  sidestep_invalid_parameter,
Depths: 0:0
[]
The real line: -  SIDESTEP_INSUFFICIENT_BUFFER,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER, 
LINE TO PARSE FOR KEYWORD:  sidestep_insufficient_buffer,
Depths: 0:0
[]
The real line: -  SIDESTEP_JUMP_INSTRUCTION,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER, 
LINE TO PARSE FOR KEYWORD:  sidestep_jump_instruction,
Depths: 0:0
[]
The real line: -  SIDESTEP_FUNCTION_TOO_SMALL,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION, 
LINE TO PARSE FOR KEYWORD:  sidestep_function_too_small,
Depths: 0:0
[]
The real line: -  SIDESTEP_UNSUPPORTED_INSTRUCTION,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION,   SIDESTEP_FUNCTION_TOO_SMALL, 
LINE TO PARSE FOR KEYWORD:  sidestep_unsupported_instruction,
Depths: 0:0
[]
The real line: -  SIDESTEP_NO_SUCH_MODULE,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION,   SIDESTEP_FUNCTION_TOO_SMALL,   SIDESTEP_UNSUPPORTED_INSTRUCTION, 
LINE TO PARSE FOR KEYWORD:  sidestep_no_such_module,
Depths: 0:0
[]
The real line: -  SIDESTEP_NO_SUCH_FUNCTION,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION,   SIDESTEP_FUNCTION_TOO_SMALL,   SIDESTEP_UNSUPPORTED_INSTRUCTION,   SIDESTEP_NO_SUCH_MODULE, 
LINE TO PARSE FOR KEYWORD:  sidestep_no_such_function,
Depths: 0:0
[]
The real line: -  SIDESTEP_ACCESS_DENIED,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION,   SIDESTEP_FUNCTION_TOO_SMALL,   SIDESTEP_UNSUPPORTED_INSTRUCTION,   SIDESTEP_NO_SUCH_MODULE,   SIDESTEP_NO_SUCH_FUNCTION, 
LINE TO PARSE FOR KEYWORD:  sidestep_access_denied,
Depths: 0:0
[]
The real line: -  SIDESTEP_UNEXPECTED,
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION,   SIDESTEP_FUNCTION_TOO_SMALL,   SIDESTEP_UNSUPPORTED_INSTRUCTION,   SIDESTEP_NO_SUCH_MODULE,   SIDESTEP_NO_SUCH_FUNCTION,   SIDESTEP_ACCESS_DENIED, 
LINE TO PARSE FOR KEYWORD:  sidestep_unexpected,
Depths: 0:0
[]
The real line: -};
Current Name Search: static const bool kIs64BitBinary = false; #endif  namespace sidestep {   enum SideStepError {   SIDESTEP_SUCCESS = 0,   SIDESTEP_INVALID_PARAMETER,   SIDESTEP_INSUFFICIENT_BUFFER,   SIDESTEP_JUMP_INSTRUCTION,   SIDESTEP_FUNCTION_TOO_SMALL,   SIDESTEP_UNSUPPORTED_INSTRUCTION,   SIDESTEP_NO_SUCH_MODULE,   SIDESTEP_NO_SUCH_FUNCTION,   SIDESTEP_ACCESS_DENIED,   SIDESTEP_UNEXPECTED, 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:0
[]
The real line: -
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#define SIDESTEP_TO_HRESULT(error)                      \
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:#define sidestep_to_hresult(error)                      \
Depths: 0:0
[]
The real line: -  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NULL, error)
Current Name Search: };  #define SIDESTEP_TO_HRESULT(error)                      \ 
LINE TO PARSE FOR KEYWORD:  make_hresult(severity_error, facility_null, error)
Depths: 0:0
[]
The real line: -
Current Name Search: };  #define SIDESTEP_TO_HRESULT(error)                      \   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NULL, error) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -class DeleteUnsignedCharArray;
Current Name Search: };  #define SIDESTEP_TO_HRESULT(error)                      \   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NULL, error)  
LINE TO PARSE FOR KEYWORD:class deleteunsignedchararray;
Depths: 0:0
[]
The real line: -
Current Name Search: class DeleteUnsignedCharArray; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// Implements a patching mechanism that overwrites the first few bytes of
Current Name Search: class DeleteUnsignedCharArray;  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// a function preamble with a jump to our hook function, which is then
Current Name Search: class DeleteUnsignedCharArray;   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// able to call the original function via a specially-made preamble-stub
Current Name Search: class DeleteUnsignedCharArray;    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// that imitates the action of the original preamble.
Current Name Search: class DeleteUnsignedCharArray;     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// NOTE:  This patching mechanism should currently only be used for
Current Name Search: class DeleteUnsignedCharArray;       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// non-production code, e.g. unit tests, because it is not threadsafe.
Current Name Search: class DeleteUnsignedCharArray;        
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// See the TODO in preamble_patcher_with_stub.cc for instructions on what
Current Name Search: class DeleteUnsignedCharArray;         
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// we need to do before using it in production code; it's fairly simple
Current Name Search: class DeleteUnsignedCharArray;          
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// but unnecessary for now since we only intend to use it in unit tests.
Current Name Search: class DeleteUnsignedCharArray;           
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;            
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// To patch a function, use either of the typesafe Patch() methods.  You
Current Name Search: class DeleteUnsignedCharArray;             
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// can unpatch a function using Unpatch().
Current Name Search: class DeleteUnsignedCharArray;              
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;               
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// Typical usage goes something like this:
Current Name Search: class DeleteUnsignedCharArray;                
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// @code
Current Name Search: class DeleteUnsignedCharArray;                 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// typedef int (*MyTypesafeFuncPtr)(int x);
Current Name Search: class DeleteUnsignedCharArray;                  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// MyTypesafeFuncPtr original_func_stub;
Current Name Search: class DeleteUnsignedCharArray;                   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// int MyTypesafeFunc(int x) { return x + 1; }
Current Name Search: class DeleteUnsignedCharArray;                    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// int HookMyTypesafeFunc(int x) { return 1 + original_func_stub(x); }
Current Name Search: class DeleteUnsignedCharArray;                     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// 
Current Name Search: class DeleteUnsignedCharArray;                      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// void MyPatchInitializingFunction() {
Current Name Search: class DeleteUnsignedCharArray;                       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//   original_func_stub = PreamblePatcher::Patch(
Current Name Search: class DeleteUnsignedCharArray;                        
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//              MyTypesafeFunc, HookMyTypesafeFunc);
Current Name Search: class DeleteUnsignedCharArray;                         
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//   if (!original_func_stub) {
Current Name Search: class DeleteUnsignedCharArray;                          
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//     // ... error handling ...
Current Name Search: class DeleteUnsignedCharArray;                           
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//   }
Current Name Search: class DeleteUnsignedCharArray;                            
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;                             
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//   // ... continue - you have patched the function successfully ...
Current Name Search: class DeleteUnsignedCharArray;                              
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// }
Current Name Search: class DeleteUnsignedCharArray;                               
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// @endcode
Current Name Search: class DeleteUnsignedCharArray;                                
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;                                 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// Note that there are a number of ways that this method of patching can
Current Name Search: class DeleteUnsignedCharArray;                                  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// fail.  The most common are:
Current Name Search: class DeleteUnsignedCharArray;                                   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    - If there is a jump (jxx) instruction in the first 5 bytes of
Current Name Search: class DeleteUnsignedCharArray;                                    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    the function being patched, we cannot patch it because in the
Current Name Search: class DeleteUnsignedCharArray;                                     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    current implementation we do not know how to rewrite relative
Current Name Search: class DeleteUnsignedCharArray;                                      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    jumps after relocating them to the preamble-stub.  Note that
Current Name Search: class DeleteUnsignedCharArray;                                       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    if you really really need to patch a function like this, it
Current Name Search: class DeleteUnsignedCharArray;                                        
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    would be possible to add this functionality (but at some cost).
Current Name Search: class DeleteUnsignedCharArray;                                         
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    - If there is a return (ret) instruction in the first 5 bytes
Current Name Search: class DeleteUnsignedCharArray;                                          
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    we cannot patch the function because it may not be long enough
Current Name Search: class DeleteUnsignedCharArray;                                           
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    for the jmp instruction we use to inject our patch.
Current Name Search: class DeleteUnsignedCharArray;                                            
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    - If there is another thread currently executing within the bytes
Current Name Search: class DeleteUnsignedCharArray;                                             
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    that are copied to the preamble stub, it will crash in an undefined
Current Name Search: class DeleteUnsignedCharArray;                                              
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//    way.
Current Name Search: class DeleteUnsignedCharArray;                                               
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;                                                
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// If you get any other error than the above, you're either pointing the
Current Name Search: class DeleteUnsignedCharArray;                                                 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// patcher at an invalid instruction (e.g. into the middle of a multi-
Current Name Search: class DeleteUnsignedCharArray;                                                  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// byte instruction, or not at memory containing executable instructions)
Current Name Search: class DeleteUnsignedCharArray;                                                   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// or, there may be a bug in the disassembler we use to find
Current Name Search: class DeleteUnsignedCharArray;                                                    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// instruction boundaries.
Current Name Search: class DeleteUnsignedCharArray;                                                     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -//
Current Name Search: class DeleteUnsignedCharArray;                                                      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// NOTE:  In optimized builds, when you have very trivial functions that
Current Name Search: class DeleteUnsignedCharArray;                                                       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// the compiler can reason do not have side effects, the compiler may
Current Name Search: class DeleteUnsignedCharArray;                                                        
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// reuse the result of calling the function with a given parameter, which
Current Name Search: class DeleteUnsignedCharArray;                                                         
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// may mean if you patch the function in between your patch will never get
Current Name Search: class DeleteUnsignedCharArray;                                                          
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -// invoked.  See preamble_patcher_test.cc for an example.
Current Name Search: class DeleteUnsignedCharArray;                                                           
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -class PERFTOOLS_DLL_DECL PreamblePatcher {
Current Name Search: class DeleteUnsignedCharArray;                                                            
LINE TO PARSE FOR KEYWORD:class perftools_dll_decl preamblepatcher {
Depths: 0:0
[]
The real line: - public:
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher { 
LINE TO PARSE FOR KEYWORD: public:
Depths: 0:0
[]
The real line: -
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -  // This is a typesafe version of RawPatch(), identical in all other
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:  
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // ways than it takes a template parameter indicating the type of the
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:     
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // function being patched.
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:        
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:           
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @param T The type of the function you are patching. Usually
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:              
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // you will establish this type using a typedef, as in the following
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                 
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // example:
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                    
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @code
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                       
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // typedef BOOL (WINAPI *MessageBoxPtr)(HWND, LPCTSTR, LPCTSTR, UINT);
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                          
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // MessageBoxPtr original = NULL;
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                             
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // PreamblePatcher::Patch(MessageBox, Hook_MessageBox, &original);
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @endcode
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                   
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  template <class T>
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                      
LINE TO PARSE FOR KEYWORD:  template <class t>
Depths: 0:0
[]
The real line: -  static SideStepError Patch(T target_function,
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T> 
LINE TO PARSE FOR KEYWORD:  static sidesteperror patch(t target_function,
Depths: 0:0
[]
The real line: -                             T replacement_function,
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function, 
LINE TO PARSE FOR KEYWORD:                             t replacement_function,
Depths: 0:0
[]
The real line: -                             T* original_function_stub) {
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function, 
LINE TO PARSE FOR KEYWORD:                             t* original_function_stub) {
Depths: 0:0
[]
The real line: -    // NOTE: casting from a function to a pointer is contra the C++
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function,                              T* original_function_stub) { 
LINE TO PARSE FOR KEYWORD:    
Depths: 0:0
[]
The real line: -    //       spec.  It's not safe on IA64, but is on i386.  We use
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function,                              T* original_function_stub) {      
LINE TO PARSE FOR KEYWORD:    
Depths: 0:0
[]
The real line: -    //       a C-style cast here to emphasize this is not legal C++.
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function,                              T* original_function_stub) {           
LINE TO PARSE FOR KEYWORD:    
Depths: 0:0
[]
The real line: -    return RawPatch((void*)(target_function),
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function,                              T* original_function_stub) {                
LINE TO PARSE FOR KEYWORD:    return rawpatch((void*)(target_function),
Depths: 0:0
[]
The real line: -                    (void*)(replacement_function),
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function,                              T* original_function_stub) {                    return RawPatch((void*)(target_function), 
LINE TO PARSE FOR KEYWORD:                    (void*)(replacement_function),
Depths: 0:0
[]
The real line: -                    (void**)(original_function_stub));
Current Name Search: class DeleteUnsignedCharArray;                                                            class PERFTOOLS_DLL_DECL PreamblePatcher {  public:                                        template <class T>   static SideStepError Patch(T target_function,                              T replacement_function,                              T* original_function_stub) {                    return RawPatch((void*)(target_function),                     (void*)(replacement_function), 
LINE TO PARSE FOR KEYWORD:                    (void**)(original_function_stub));
Depths: 0:0
[]
The real line: -  }
Current Name Search:                     (void**)(original_function_stub)); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 0:0
[]
The real line: -
Current Name Search:                     (void**)(original_function_stub));   } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -  // Patches a named function imported from the named module using
Current Name Search:                     (void**)(original_function_stub));   }  
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // preamble patching.  Uses RawPatch() to do the actual patching
Current Name Search:                     (void**)(original_function_stub));   }     
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // work.
Current Name Search:                     (void**)(original_function_stub));   }        
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search:                     (void**)(original_function_stub));   }           
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @param T The type of the function you are patching.  Must
Current Name Search:                     (void**)(original_function_stub));   }              
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // exactly match the function you specify using module_name and
Current Name Search:                     (void**)(original_function_stub));   }                 
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // function_name.
Current Name Search:                     (void**)(original_function_stub));   }                    
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search:                     (void**)(original_function_stub));   }                       
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @param module_name The name of the module from which the function
Current Name Search:                     (void**)(original_function_stub));   }                          
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // is being imported.  Note that the patch will fail if this module
Current Name Search:                     (void**)(original_function_stub));   }                             
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // has not already been loaded into the current process.
Current Name Search:                     (void**)(original_function_stub));   }                                
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search:                     (void**)(original_function_stub));   }                                   
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @param function_name The name of the function you wish to patch.
Current Name Search:                     (void**)(original_function_stub));   }                                      
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search:                     (void**)(original_function_stub));   }                                         
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @param replacement_function Your replacement function which
Current Name Search:                     (void**)(original_function_stub));   }                                            
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // will be called whenever code tries to call the original function.
Current Name Search:                     (void**)(original_function_stub));   }                                               
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search:                     (void**)(original_function_stub));   }                                                  
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @param original_function_stub Pointer to memory that should receive a
Current Name Search:                     (void**)(original_function_stub));   }                                                     
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // pointer that can be used (e.g. in the replacement function) to call the
Current Name Search:                     (void**)(original_function_stub));   }                                                        
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // original function, or NULL to indicate failure.
Current Name Search:                     (void**)(original_function_stub));   }                                                           
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  //
Current Name Search:                     (void**)(original_function_stub));   }                                                              
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // @return One of the EnSideStepError error codes; only SIDESTEP_SUCCESS
Current Name Search:                     (void**)(original_function_stub));   }                                                                 
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  // indicates success.
Current Name Search:                     (void**)(original_function_stub));   }                                                                    
LINE TO PARSE FOR KEYWORD:  
Depths: 0:0
[]
The real line: -  template <class T>
Current Name Search:                     (void**)(original_function_stub));   }                                                                       
LINE TO PARSE FOR KEYWORD:  template <class t>
Depths: 0:0
[]
The real line: -  static SideStepError Patch(LPCTSTR module_name,
Current Name Search:                     (void**)(original_function_stub));   }                                                                         template <class T> 
LINE TO PARSE FOR KEYWORD:  static sidesteperror patch(lpctstr module_name,
Depths: 0:0
[]
The real line: -                             LPCSTR function_name,
Current Name Search:                     (void**)(original_function_stub));   }                                                                         template <class T>   static SideStepError Patch(LPCTSTR module_name, 
LINE TO PARSE FOR KEYWORD:                             lpcstr function_name,
Depths: 0:0
[]
The real line: -                             T replacement_function,
Current Name Search:                     (void**)(original_function_stub));   }                                                                         template <class T>   static SideStepError Patch(LPCTSTR module_name,                              LPCSTR function_name, 
LINE TO PARSE FOR KEYWORD:                             t replacement_function,
Depths: 0:0
[]
The real line: -                             T* original_function_stub) {
Current Name Search:                     (void**)(original_function_stub));   }                                                                         template <class T>   static SideStepError Patch(LPCTSTR module_name,                              LPCSTR function_name,                              T replacement_function, 
LINE TO PARSE FOR KEYWORD:                             t* original_function_stub) {
Depths: 0:0
[]
The real line: -    SIDESTEP_ASSERT(module_name && function_name);
Current Name Search:                     (void**)(original_function_stub));   }                                                                         template <class T>   static SideStepError Patch(LPCTSTR module_name,                              LPCSTR function_name,                              T replacement_function,                              T* original_function_stub) { 
LINE TO PARSE FOR KEYWORD:    sidestep_assert(module_name && function_name);
Depths: 0:0
[]
The real line: -    if (!module_name || !function_name) {
Current Name Search:     SIDESTEP_ASSERT(module_name && function_name); 
LINE TO PARSE FOR KEYWORD:    if (!module_name || !function_name) {
Depths: 0:0
[]
The real line: -      SIDESTEP_ASSERT(false &&
Current Name Search:     SIDESTEP_ASSERT(module_name && function_name);     if (!module_name || !function_name) { 
LINE TO PARSE FOR KEYWORD:      sidestep_assert(false &&
Depths: 0:0
[]
The real line: -                      "You must specify a module name and function name.");
Current Name Search:     SIDESTEP_ASSERT(module_name && function_name);     if (!module_name || !function_name) {       SIDESTEP_ASSERT(false && 
LINE TO PARSE FOR KEYWORD:                      );
Depths: 0:0
[]
The real line: -      return SIDESTEP_INVALID_PARAMETER;
Current Name Search:                       ); 
LINE TO PARSE FOR KEYWORD:      return sidestep_invalid_parameter;
Depths: 0:0
[]
The real line: -    }
Current Name Search:       return SIDESTEP_INVALID_PARAMETER; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 0:0
[]
The real line: -    HMODULE module = ::GetModuleHandle(module_name);
Current Name Search:       return SIDESTEP_INVALID_PARAMETER;     } 
LINE TO PARSE FOR KEYWORD:    hmodule module = ::getmodulehandle(module_name);
Depths: 0:0
[]
The real line: -    SIDESTEP_ASSERT(module != NULL);
Current Name Search:     HMODULE module = ::GetModuleHandle(module_name); 
LINE TO PARSE FOR KEYWORD:    sidestep_assert(module != null);
Depths: 0:0
[]
The real line: -    if (!module) {
Current Name Search:     SIDESTEP_ASSERT(module != NULL); 
LINE TO PARSE FOR KEYWORD:    if (!module) {
Depths: 0:0
[]
The real line: -      SIDESTEP_ASSERT(false && "Invalid module name.");
Current Name Search:     SIDESTEP_ASSERT(module != NULL);     if (!module) { 
LINE TO PARSE FOR KEYWORD:      sidestep_assert(false && );
Depths: 0:0
[]
The real line: -      return SIDESTEP_NO_SUCH_MODULE;
Current Name Search:       SIDESTEP_ASSERT(false && ); 
LINE TO PARSE FOR KEYWORD:      return sidestep_no_such_module;
Depths: 0:0
[]
The real line: -    }
Current Name Search:       return SIDESTEP_NO_SUCH_MODULE; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 0:0
[]
The real line: -    FARPROC existing_function = ::GetProcAddress(module, function_name);
Current Name Search:       return SIDESTEP_NO_SUCH_MODULE;     } 
LINE TO PARSE FOR KEYWORD:    farproc existing_function = ::getprocaddress(module, function_name);
Depths: 0:0
[]
The real line: -    if (!existing_function) {
Current Name Search:     FARPROC existing_function = ::GetProcAddress(module, function_name); 
LINE TO PARSE FOR KEYWORD:    if (!existing_function) {
Depths: 0:0
[]
The real line: -      SIDESTEP_ASSERT(
Current Name Search:     FARPROC existing_function = ::GetProcAddress(module, function_name);     if (!existing_function) { 
LINE TO PARSE FOR KEYWORD:      sidestep_assert(
Depths: 0:0
[]
The real line: -          false && "Did not find any function with that name in the module.");
Current Name Search:     FARPROC existing_function = ::GetProcAddress(module, function_name);     if (!existing_function) {       SIDESTEP_ASSERT( 
LINE TO PARSE FOR KEYWORD:          false && );
Depths: 0:0
[]
The real line: -      return SIDESTEP_NO_SUCH_FUNCTION;
Current Name Search:           false && ); 
LINE TO PARSE FOR KEYWORD:      return sidestep_no_such_function;
Depths: 0:0
[]
The real line: -    }
Current Name Search:       return SIDESTEP_NO_SUCH_FUNCTION; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 0:0
[]
The real line: -    // NOTE: casting from a function to a pointer is contra the C++
Current Name Search:       return SIDESTEP_NO_SUCH_FUNCTION;     } 
LINE TO PARSE FOR KEYWORD:    
Depths: 0:0
[]
The real line: -    //       spec.  It's not safe on IA64, but is on i386.  We use
Current Name Search:       return SIDESTEP_NO_SUCH_FUNCTION;     }      
LINE TO PARSE FOR KEYWORD:    
Depths: 0:0
[]
The real line: -    //       a C-style cast here to emphasize this is not legal C++.
Current Name Search:       return SIDESTEP_NO_SUCH_FUNCTION;     }           
LINE TO PARSE FOR KEYWORD:    
Depths: 0:0
[]
The real line: -    return RawPatch((void*)existing_function, (void*)replacement_function,
Current Name Search:       return SIDESTEP_NO_SUCH_FUNCTION;     }                
LINE TO PARSE FOR KEYWORD:    return rawpatch((void*)existing_function, (void*)replacement_function,
Depths: 0:0
[]
The real line: -                    (void**)(original_function_stub));
Current Name Search:       return SIDESTEP_NO_SUCH_FUNCTION;     }                    return RawPatch((void*)existing_function, (void*)replacement_function, 
LINE TO PARSE FOR KEYWORD:                    (void**)(original_function_stub));
Depths: 0:0
[]
The real line: -  }
Current Name Search:                     (void**)(original_function_stub)); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 0:0
[]
The real line: -
Current Name Search:                     (void**)(original_function_stub));   } F
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -};
Current Name Search:                     (void**)(original_function_stub));   }  
LINE TO PARSE FOR KEYWORD:};
Depths: 0:0
[]
The real line: -
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -};  // namespace sidestep
Current Name Search: };  
LINE TO PARSE FOR KEYWORD:};  
Depths: 0:0
[]
The real line: -
Current Name Search: };   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: -#endif  // GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_
Current Name Search: };    
LINE TO PARSE FOR KEYWORD:#endif  
Depths: 0:0
[]
Chunk End.
The real line:  namespace mongo {
Current Name Search: 
Checking if function:  namespace mongo {
Namespace: namespace mongo {
Depths: 1:1
[]
The real line:      BSONObj idKeyPattern = fromjson("{\"_id\":1}");
Current Name Search: 
Depths: 1:1
[]
The real line:      /* deleted lists -- linked lists of deleted records -- are placed in 'buckets' of various sizes
Current Name Search:      BSONObj idKeyPattern = fromjson(_id\); 
Depths: 1:1
[]
The real line:         so you can look for a deleterecord about the right size.
The real line:      */
The real line:      int bucketSizes[] = {
Current Name Search:      BSONObj idKeyPattern = fromjson(_id\);       
Checking if function:      BSONObj idKeyPattern = fromjson(_id\);            int bucketSizes[] = {
Other type of bracket:      BSONObj idKeyPattern = fromjson(_id\);            int bucketSizes[] = {
Depths: 2:2
[]
The real line:          32, 64, 128, 256, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000,
Current Name Search: 
Depths: 2:2
[]
The real line:          0x8000, 0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000,
Current Name Search:          32, 64, 128, 256, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 
Depths: 2:2
[]
The real line:          0x400000, 0x800000
Current Name Search:          32, 64, 128, 256, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000,          0x8000, 0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000, 
Depths: 2:2
[]
The real line:      };
Current Name Search:          32, 64, 128, 256, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000,          0x8000, 0x10000, 0x20000, 0x40000, 0x80000, 0x100000, 0x200000,          0x400000, 0x800000 
Depths: 1:2
[]
Adjusting depth.
The real line:      bool NamespaceIndex::exists() const {
Current Name Search:      }; 
Checking if function:      };      bool NamespaceIndex::exists() const {
PATTERN 1
Function:  bool NamespaceIndex::exists(){
Depths: 2:1
[]
The real line:          return !boost::filesystem::exists(path());
End Check: 2
The real line:      }
End Check: 1
14 : 16
Next: ()
The real line:      boost::filesystem::path NamespaceIndex::path() const {
Current Name Search: 
Checking if function:      boost::filesystem::path NamespaceIndex::path() const {
PATTERN 4
Function: boost::filesystem::path NamespaceIndex::path(){
Depths: 2:1
[]
The real line:          boost::filesystem::path ret( dir_ );
End Check: 2
The real line:          if ( directoryperdb )
End Check: 2
The real line:              ret /= database_;
End Check: 2
The real line:          ret /= ( database_ + ".ns" );
End Check: 2
The real line:          return ret;
End Check: 2
The real line:      }
End Check: 1
18 : 24
Next: ()
The real line:      void NamespaceIndex::maybeMkdir() const {
Current Name Search: 
Checking if function:      void NamespaceIndex::maybeMkdir() const {
PATTERN 4
Function: void NamespaceIndex::maybeMkdir(){
Depths: 2:1
[]
The real line:          if ( !directoryperdb )
End Check: 2
The real line:              return;
End Check: 2
The real line:          boost::filesystem::path dir( dir_ );
End Check: 2
The real line:          dir /= database_;
End Check: 2
The real line:          if ( !boost::filesystem::exists( dir ) )
End Check: 2
The real line:              BOOST_CHECK_EXCEPTION( boost::filesystem::create_directory( dir ) );
End Check: 2
The real line:      }
End Check: 1
26 : 33
Next: ()
The real line:  	int lenForNewNsFiles = 16 * 1024 * 1024;
Current Name Search: 
Depths: 1:1
[]
The real line:      void NamespaceDetails::onLoad(const Namespace& k) { 
Current Name Search:  	int lenForNewNsFiles = 16 * 1024 * 1024; 
Checking if function:  	int lenForNewNsFiles = 16 * 1024 * 1024;      void NamespaceDetails::onLoad(const Namespace& k) {
PATTERN 1
Function:  void NamespaceDetails::onLoad(const Namespace& k) {
Depths: 2:1
[]
The real line:          if( k.isExtra() ) { 
End Check: 3
The real line:              /* overflow storage for indexes - so don't treat as a NamespaceDetails object. */
End Check: 3
The real line:              return;
End Check: 3
The real line:          }
End Check: 2
The real line:          assertInWriteLock();
End Check: 2
The real line:          if( backgroundIndexBuildInProgress ) { 
End Check: 3
The real line:              log() << "backgroundIndexBuildInProgress was " << backgroundIndexBuildInProgress << " for " << k << ", indicating an abnormal db shutdown" << endl;
End Check: 3
The real line:              backgroundIndexBuildInProgress = 0;
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
37 : 48
Next: (const Namespace& k)
The real line:      static void callback(const Namespace& k, NamespaceDetails& v) { 
Current Name Search: 
Checking if function:      static void callback(const Namespace& k, NamespaceDetails& v) {
PATTERN 1
Function:  void callback(const Namespace& k, NamespaceDetails& v) {
Depths: 2:1
[]
The real line:          v.onLoad(k);
End Check: 2
The real line:      }
End Check: 1
50 : 52
Next: (const Namespace& k, NamespaceDetails& v)
The real line:      bool checkNsFilesOnLoad = true;
Current Name Search: 
Depths: 1:1
[]
The real line:      void NamespaceIndex::init() {
Current Name Search:      bool checkNsFilesOnLoad = true; 
Checking if function:      bool checkNsFilesOnLoad = true;      void NamespaceIndex::init() {
PATTERN 1
Function:  void NamespaceIndex::init() {
Depths: 2:1
[]
The real line:          if ( ht )
End Check: 2
The real line:              return;
End Check: 2
The real line:          /* if someone manually deleted the datafiles for a database,
End Check: 2
The real line:             we need to be sure to clear any cached info for the database in
The real line:             local.*.
The real line:          */
The real line:  		/*
End Check: 2
The real line:          if ( "local" != database_ ) {
The real line:              DBInfo i(database_.c_str());
The real line:              i.dbDropped();
The real line:          }
The real line:  		*/
The real line:  		int len = -1;
End Check: 2
The real line:          boost::filesystem::path nsPath = path();
End Check: 2
The real line:          string pathString = nsPath.string();
End Check: 2
The real line:  		void *p;
End Check: 2
The real line:          if( boost::filesystem::exists(nsPath) ) { 
End Check: 3
The real line:  			p = f.map(pathString.c_str());
End Check: 3
The real line:              if( p ) {
End Check: 4
The real line:                  len = f.length();
End Check: 4
The real line:                  if ( len % (1024*1024) != 0 ){
End Check: 5
The real line:                      log() << "bad .ns file: " << pathString << endl;
End Check: 5
The real line:                      uassert( 10079 ,  "bad .ns file length, cannot open database", len % (1024*1024) == 0 );
End Check: 5
The real line:                  }
End Check: 4
The real line:              }
End Check: 3
The real line:  		}
End Check: 2
The real line:  		else {
End Check: 3
The real line:  			// use lenForNewNsFiles, we are making a new database
End Check: 3
The real line:  			massert( 10343 ,  "bad lenForNewNsFiles", lenForNewNsFiles >= 1024*1024 );
End Check: 3
The real line:              maybeMkdir();
End Check: 3
The real line:  			long l = lenForNewNsFiles;
End Check: 3
The real line:  			p = f.map(pathString.c_str(), l);
End Check: 3
The real line:              if( p ) { 
End Check: 4
The real line:                  len = (int) l;
End Check: 4
The real line:                  assert( len == lenForNewNsFiles );
End Check: 4
The real line:              }
End Check: 3
The real line:  		}
End Check: 2
The real line:          if ( p == 0 ) {
End Check: 3
The real line:              problem() << "couldn't open file " << pathString << " terminating" << endl;
End Check: 3
The real line:              dbexit( EXIT_FS );
End Check: 3
The real line:          }
End Check: 2
The real line:          ht = new HashTable<Namespace,NamespaceDetails>(p, len, "namespace index");
End Check: 2
The real line:          if( checkNsFilesOnLoad )
End Check: 2
The real line:              ht->iterAll(callback);
End Check: 2
The real line:      }
End Check: 1
56 : 102
Next: ()
The real line:      void NamespaceDetails::addDeletedRec(DeletedRecord *d, DiskLoc dloc) {
Current Name Search: 
Checking if function:      void NamespaceDetails::addDeletedRec(DeletedRecord *d, DiskLoc dloc) {
PATTERN 4
Function: void NamespaceDetails::addDeletedRec(DeletedRecord *d, DiskLoc dloc) {
Depths: 2:1
[]
The real line:          {
End Check: 3
The real line:              // defensive code: try to make us notice if we reference a deleted record
End Check: 3
The real line:              (unsigned&) (((Record *) d)->data) = 0xeeeeeeee;
End Check: 3
The real line:          }
End Check: 2
The real line:          dassert( dloc.drec() == d );
End Check: 2
The real line:          DEBUGGING out() << "TEMP: add deleted rec " << dloc.toString() << ' ' << hex << d->extentOfs << endl;
End Check: 2
The real line:          if ( capped ) {
End Check: 3
The real line:              if ( !deletedList[ 1 ].isValid() ) {
End Check: 4
The real line:                  // Initial extent allocation.  Insert at end.
End Check: 4
The real line:                  d->nextDeleted = DiskLoc();
End Check: 4
The real line:                  if ( deletedList[ 0 ].isNull() )
End Check: 4
The real line:                      deletedList[ 0 ] = dloc;
End Check: 4
The real line:                  else {
End Check: 5
The real line:                      DiskLoc i = deletedList[ 0 ];
End Check: 5
The real line:                      for (; !i.drec()->nextDeleted.isNull(); i = i.drec()->nextDeleted );
End Check: 5
The real line:                      i.drec()->nextDeleted = dloc;
End Check: 5
The real line:                  }
End Check: 4
The real line:              } else {
End Check: 4
The real line:                  d->nextDeleted = firstDeletedInCapExtent();
End Check: 4
The real line:                  firstDeletedInCapExtent() = dloc;
End Check: 4
The real line:              }
End Check: 3
The real line:          } else {
End Check: 3
The real line:              int b = bucket(d->lengthWithHeaders);
End Check: 3
The real line:              DiskLoc& list = deletedList[b];
End Check: 3
The real line:              DiskLoc oldHead = list;
End Check: 3
The real line:              list = dloc;
End Check: 3
The real line:              d->nextDeleted = oldHead;
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
104 : 133
Next: (DeletedRecord *d, DiskLoc dloc)
The real line:      /*
Current Name Search: 
Depths: 1:1
[]
The real line:         lenToAlloc is WITH header
The real line:      */
The real line:      DiskLoc NamespaceDetails::alloc(const char *ns, int lenToAlloc, DiskLoc& extentLoc) {
Current Name Search:       
Checking if function:            DiskLoc NamespaceDetails::alloc(const char *ns, int lenToAlloc, DiskLoc& extentLoc) {
PATTERN 4
Function: DiskLoc NamespaceDetails::alloc(const char *ns, int lenToAlloc, DiskLoc& extentLoc) {
Depths: 2:1
[]
The real line:          lenToAlloc = (lenToAlloc + 3) & 0xfffffffc;
End Check: 2
The real line:          DiskLoc loc = _alloc(ns, lenToAlloc);
End Check: 2
The real line:          if ( loc.isNull() )
End Check: 2
The real line:              return loc;
End Check: 2
The real line:          DeletedRecord *r = loc.drec();
End Check: 2
The real line:          /* note we want to grab from the front so our next pointers on disk tend
End Check: 2
The real line:          to go in a forward direction which is important for performance. */
The real line:          int regionlen = r->lengthWithHeaders;
End Check: 2
The real line:          extentLoc.set(loc.a(), r->extentOfs);
End Check: 2
The real line:          assert( r->extentOfs < loc.getOfs() );
End Check: 2
The real line:          DEBUGGING out() << "TEMP: alloc() returns " << loc.toString() << ' ' << ns << " lentoalloc:" << lenToAlloc << " ext:" << extentLoc.toString() << endl;
End Check: 2
The real line:          int left = regionlen - lenToAlloc;
End Check: 2
The real line:          if ( capped == 0 ) {
End Check: 3
The real line:              if ( left < 24 || left < (lenToAlloc >> 3) ) {
End Check: 4
The real line:                  // you get the whole thing.
End Check: 4
The real line:                  return loc;
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:          /* split off some for further use. */
End Check: 2
The real line:          r->lengthWithHeaders = lenToAlloc;
End Check: 2
The real line:          DiskLoc newDelLoc = loc;
End Check: 2
The real line:          newDelLoc.inc(lenToAlloc);
End Check: 2
The real line:          DeletedRecord *newDel = newDelLoc.drec();
End Check: 2
The real line:          newDel->extentOfs = r->extentOfs;
End Check: 2
The real line:          newDel->lengthWithHeaders = left;
End Check: 2
The real line:          newDel->nextDeleted.Null();
End Check: 2
The real line:          addDeletedRec(newDel, newDelLoc);
End Check: 2
The real line:          return loc;
End Check: 2
The real line:      }
End Check: 1
138 : 174
Next: (const char *ns, int lenToAlloc, DiskLoc& extentLoc)
The real line:      /* for non-capped collections.
Current Name Search: 
Depths: 1:1
[]
The real line:         returned item is out of the deleted list upon return
The real line:      */
The real line:      DiskLoc NamespaceDetails::__stdAlloc(int len) {
Current Name Search:       
Checking if function:            DiskLoc NamespaceDetails::__stdAlloc(int len) {
PATTERN 4
Function: DiskLoc NamespaceDetails::__stdAlloc(int len) {
Depths: 2:1
[]
The real line:          DiskLoc *prev;
End Check: 2
The real line:          DiskLoc *bestprev = 0;
End Check: 2
The real line:          DiskLoc bestmatch;
End Check: 2
The real line:          int bestmatchlen = 0x7fffffff;
End Check: 2
The real line:          int b = bucket(len);
End Check: 2
The real line:          DiskLoc cur = deletedList[b];
End Check: 2
The real line:          prev = &deletedList[b];
End Check: 2
The real line:          int extra = 5; // look for a better fit, a little.
End Check: 2
The real line:          int chain = 0;
End Check: 2
The real line:          while ( 1 ) {
End Check: 3
The real line:              {
End Check: 4
The real line:                  int a = cur.a();
End Check: 4
The real line:                  if ( a < -1 || a >= 100000 ) {
End Check: 5
The real line:                      problem() << "~~ Assertion - cur out of range in _alloc() " << cur.toString() <<
End Check: 5
The real line:                      " a:" << a << " b:" << b << " chain:" << chain << '\n';
End Check: 5
The real line:                      sayDbContext();
End Check: 5
The real line:                      if ( cur == *prev )
End Check: 5
The real line:                          prev->Null();
End Check: 5
The real line:                      cur.Null();
End Check: 5
The real line:                  }
End Check: 4
The real line:              }
End Check: 3
The real line:              if ( cur.isNull() ) {
End Check: 4
The real line:                  // move to next bucket.  if we were doing "extra", just break
End Check: 4
The real line:                  if ( bestmatchlen < 0x7fffffff )
End Check: 4
The real line:                      break;
End Check: 4
The real line:                  b++;
End Check: 4
The real line:                  if ( b > MaxBucket ) {
End Check: 5
The real line:                      // out of space. alloc a new extent.
End Check: 5
The real line:                      return DiskLoc();
End Check: 5
The real line:                  }
End Check: 4
The real line:                  cur = deletedList[b];
End Check: 4
The real line:                  prev = &deletedList[b];
End Check: 4
The real line:                  continue;
End Check: 4
The real line:              }
End Check: 3
The real line:              DeletedRecord *r = cur.drec();
End Check: 3
The real line:              if ( r->lengthWithHeaders >= len &&
End Check: 3
The real line:                      r->lengthWithHeaders < bestmatchlen ) {
End Check: 4
The real line:                  bestmatchlen = r->lengthWithHeaders;
End Check: 4
The real line:                  bestmatch = cur;
End Check: 4
The real line:                  bestprev = prev;
End Check: 4
The real line:              }
End Check: 3
The real line:              if ( bestmatchlen < 0x7fffffff && --extra <= 0 )
End Check: 3
The real line:                  break;
End Check: 3
The real line:              if ( ++chain > 30 && b < MaxBucket ) {
End Check: 4
The real line:                  // too slow, force move to next bucket to grab a big chunk
End Check: 4
The real line:                  //b++;
End Check: 4
The real line:                  chain = 0;
End Check: 4
The real line:                  cur.Null();
End Check: 4
The real line:              }
End Check: 3
The real line:              else {
End Check: 4
The real line:                  /*this defensive check only made sense for the mmap storage engine: 
End Check: 4
The real line:                    if ( r->nextDeleted.getOfs() == 0 ) {
The real line:                      problem() << "~~ Assertion - bad nextDeleted " << r->nextDeleted.toString() <<
The real line:                      " b:" << b << " chain:" << chain << ", fixing.\n";
The real line:                      r->nextDeleted.Null();
The real line:                  }*/
The real line:                  cur = r->nextDeleted;
End Check: 4
The real line:                  prev = &r->nextDeleted;
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:          /* unlink ourself from the deleted list */
End Check: 2
The real line:          {
End Check: 3
The real line:              DeletedRecord *bmr = bestmatch.drec();
End Check: 3
The real line:              *bestprev = bmr->nextDeleted;
End Check: 3
The real line:              bmr->nextDeleted.setInvalid(); // defensive.
End Check: 3
The real line:              assert(bmr->extentOfs < bestmatch.getOfs());
End Check: 3
The real line:          }
End Check: 2
The real line:          return bestmatch;
End Check: 2
The real line:      }
End Check: 1
179 : 250
Next: (int len)
The real line:      void NamespaceDetails::dumpDeleted(set<DiskLoc> *extents) {
Current Name Search: 
Checking if function:      void NamespaceDetails::dumpDeleted(set<DiskLoc> *extents) {
PATTERN 4
Function: void NamespaceDetails::dumpDeleted(set<DiskLoc> *extents) {
Depths: 2:1
[]
The real line:          for ( int i = 0; i < Buckets; i++ ) {
End Check: 3
The real line:              DiskLoc dl = deletedList[i];
End Check: 3
The real line:              while ( !dl.isNull() ) {
End Check: 4
The real line:                  DeletedRecord *r = dl.drec();
End Check: 4
The real line:                  DiskLoc extLoc(dl.a(), r->extentOfs);
End Check: 4
The real line:                  if ( extents == 0 || extents->count(extLoc) <= 0 ) {
End Check: 5
The real line:                      out() << "  bucket " << i << endl;
End Check: 5
The real line:                      out() << "   " << dl.toString() << " ext:" << extLoc.toString();
End Check: 5
The real line:                      if ( extents && extents->count(extLoc) <= 0 )
End Check: 5
The real line:                          out() << '?';
End Check: 5
The real line:                      out() << " len:" << r->lengthWithHeaders << endl;
End Check: 5
The real line:                  }
End Check: 4
The real line:                  dl = r->nextDeleted;
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
252 : 268
Next: (set<DiskLoc> *extents)
The real line:      /* combine adjacent deleted records
Current Name Search: 
Depths: 1:1
[]
The real line:         this is O(n^2) but we call it for capped tables where typically n==1 or 2!
The real line:         (or 3...there will be a little unused sliver at the end of the extent.)
The real line:      */
The real line:      void NamespaceDetails::compact() {
Current Name Search:       
Checking if function:            void NamespaceDetails::compact() {
PATTERN 4
Function: void NamespaceDetails::compact() {
Depths: 2:1
[]
The real line:          assert(capped);
End Check: 2
The real line:          list<DiskLoc> drecs;
End Check: 2
The real line:          // Pull out capExtent's DRs from deletedList
End Check: 2
The real line:          DiskLoc i = firstDeletedInCapExtent();
End Check: 2
The real line:          for (; !i.isNull() && inCapExtent( i ); i = i.drec()->nextDeleted )
End Check: 2
The real line:              drecs.push_back( i );
End Check: 2
The real line:          firstDeletedInCapExtent() = i;
End Check: 2
The real line:          // This is the O(n^2) part.
End Check: 2
The real line:          drecs.sort();
End Check: 2
The real line:          list<DiskLoc>::iterator j = drecs.begin();
End Check: 2
The real line:          assert( j != drecs.end() );
End Check: 2
The real line:          DiskLoc a = *j;
End Check: 2
The real line:          while ( 1 ) {
End Check: 3
The real line:              j++;
End Check: 3
The real line:              if ( j == drecs.end() ) {
End Check: 4
The real line:                  DEBUGGING out() << "TEMP: compact adddelrec\n";
End Check: 4
The real line:                  addDeletedRec(a.drec(), a);
End Check: 4
The real line:                  break;
End Check: 4
The real line:              }
End Check: 3
The real line:              DiskLoc b = *j;
End Check: 3
The real line:              while ( a.a() == b.a() && a.getOfs() + a.drec()->lengthWithHeaders == b.getOfs() ) {
End Check: 4
The real line:                  // a & b are adjacent.  merge.
End Check: 4
The real line:                  a.drec()->lengthWithHeaders += b.drec()->lengthWithHeaders;
End Check: 4
The real line:                  j++;
End Check: 4
The real line:                  if ( j == drecs.end() ) {
End Check: 5
The real line:                      DEBUGGING out() << "temp: compact adddelrec2\n";
End Check: 5
The real line:                      addDeletedRec(a.drec(), a);
End Check: 5
The real line:                      return;
End Check: 5
The real line:                  }
End Check: 4
The real line:                  b = *j;
End Check: 4
The real line:              }
End Check: 3
The real line:              DEBUGGING out() << "temp: compact adddelrec3\n";
End Check: 3
The real line:              addDeletedRec(a.drec(), a);
End Check: 3
The real line:              a = b;
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
275 : 315
Next: ()
The real line:      DiskLoc NamespaceDetails::firstRecord( const DiskLoc &startExtent ) const {
Current Name Search: 
Checking if function:      DiskLoc NamespaceDetails::firstRecord( const DiskLoc &startExtent ) const {
PATTERN 4
Function: DiskLoc NamespaceDetails::firstRecord(DiskLoc &startExtent ){
Depths: 2:1
[]
The real line:          for (DiskLoc i = startExtent.isNull() ? firstExtent : startExtent;
End Check: 2
The real line:                  !i.isNull(); i = i.ext()->xnext ) {
End Check: 3
The real line:              if ( !i.ext()->firstRecord.isNull() )
End Check: 3
The real line:                  return i.ext()->firstRecord;
End Check: 3
The real line:          }
End Check: 2
The real line:          return DiskLoc();
End Check: 2
The real line:      }
End Check: 1
317 : 324
Next: (DiskLoc &startExtent )
The real line:      DiskLoc NamespaceDetails::lastRecord( const DiskLoc &startExtent ) const {
Current Name Search: 
Checking if function:      DiskLoc NamespaceDetails::lastRecord( const DiskLoc &startExtent ) const {
PATTERN 4
Function: DiskLoc NamespaceDetails::lastRecord(DiskLoc &startExtent ){
Depths: 2:1
[]
The real line:          for (DiskLoc i = startExtent.isNull() ? lastExtent : startExtent;
End Check: 2
The real line:                  !i.isNull(); i = i.ext()->xprev ) {
End Check: 3
The real line:              if ( !i.ext()->lastRecord.isNull() )
End Check: 3
The real line:                  return i.ext()->lastRecord;
End Check: 3
The real line:          }
End Check: 2
The real line:          return DiskLoc();
End Check: 2
The real line:      }
End Check: 1
326 : 333
Next: (DiskLoc &startExtent )
The real line:      DiskLoc &NamespaceDetails::firstDeletedInCapExtent() {
Current Name Search: 
Checking if function:      DiskLoc &NamespaceDetails::firstDeletedInCapExtent() {
Namespace:     DiskLoc &NamespaceDetails::firstDeletedInCapExtent() {
Depths: 2:2
[]
The real line:          if ( deletedList[ 1 ].isNull() )
Current Name Search: 
Depths: 2:2
[]
The real line:              return deletedList[ 0 ];
Current Name Search:          if ( deletedList[ 1 ].isNull() ) 
Depths: 2:2
[]
The real line:          else
Current Name Search:              return deletedList[ 0 ]; 
Depths: 2:2
[]
The real line:              return deletedList[ 1 ].drec()->nextDeleted;
Current Name Search:              return deletedList[ 0 ];          else 
Depths: 2:2
[]
The real line:      }
Current Name Search:              return deletedList[ 1 ].drec()->nextDeleted; 
Depths: 1:2
[]
Adjusting depth.
The real line:      bool NamespaceDetails::inCapExtent( const DiskLoc &dl ) const {
Current Name Search:              return deletedList[ 1 ].drec()->nextDeleted;      } 
Checking if function:              return deletedList[ 1 ].drec()->nextDeleted;      }      bool NamespaceDetails::inCapExtent( const DiskLoc &dl ) const {
PATTERN 1
Function:  bool NamespaceDetails::inCapExtent(DiskLoc &dl ){
Depths: 2:1
[]
The real line:          assert( !dl.isNull() );
End Check: 2
The real line:          // We could have a rec or drec, doesn't matter.
End Check: 2
The real line:          return dl.drec()->myExtent( dl ) == capExtent.ext();
End Check: 2
The real line:      }
End Check: 1
342 : 346
Next: (DiskLoc &dl )
The real line:      bool NamespaceDetails::nextIsInCapExtent( const DiskLoc &dl ) const {
Current Name Search: 
Checking if function:      bool NamespaceDetails::nextIsInCapExtent( const DiskLoc &dl ) const {
PATTERN 4
Function: bool NamespaceDetails::nextIsInCapExtent(DiskLoc &dl ){
Depths: 2:1
[]
The real line:          assert( !dl.isNull() );
End Check: 2
The real line:          DiskLoc next = dl.drec()->nextDeleted;
End Check: 2
The real line:          if ( next.isNull() )
End Check: 2
The real line:              return false;
End Check: 2
The real line:          return inCapExtent( next );
End Check: 2
The real line:      }
End Check: 1
348 : 354
Next: (DiskLoc &dl )
The real line:      void NamespaceDetails::advanceCapExtent( const char *ns ) {
Current Name Search: 
Checking if function:      void NamespaceDetails::advanceCapExtent( const char *ns ) {
PATTERN 4
Function: void NamespaceDetails::advanceCapExtent(char *ns ) {
Depths: 2:1
[]
The real line:          // We want deletedList[ 1 ] to be the last DeletedRecord of the prev cap extent
End Check: 2
The real line:          // (or DiskLoc() if new capExtent == firstExtent)
End Check: 2
The real line:          if ( capExtent == lastExtent )
End Check: 2
The real line:              deletedList[ 1 ] = DiskLoc();
End Check: 2
The real line:          else {
End Check: 3
The real line:              DiskLoc i = firstDeletedInCapExtent();
End Check: 3
The real line:              for (; !i.isNull() && nextIsInCapExtent( i ); i = i.drec()->nextDeleted );
End Check: 3
The real line:              deletedList[ 1 ] = i;
End Check: 3
The real line:          }
End Check: 2
The real line:          capExtent = theCapExtent()->xnext.isNull() ? firstExtent : theCapExtent()->xnext;
End Check: 2
The real line:          /* this isn't true if a collection has been renamed...that is ok just used for diagnostics */
End Check: 2
The real line:          //dassert( theCapExtent()->ns == ns );
End Check: 2
The real line:          theCapExtent()->assertOk();
End Check: 2
The real line:          capFirstNewRecord = DiskLoc();
End Check: 2
The real line:      }
End Check: 1
356 : 374
Next: (char *ns )
The real line:      int n_complaints_cap = 0;
Current Name Search: 
Depths: 1:1
[]
The real line:      void NamespaceDetails::maybeComplain( const char *ns, int len ) const {
Current Name Search:      int n_complaints_cap = 0; 
Checking if function:      int n_complaints_cap = 0;      void NamespaceDetails::maybeComplain( const char *ns, int len ) const {
PATTERN 1
Function:  void NamespaceDetails::maybeComplain(char *ns, int len ){
Depths: 2:1
[]
The real line:          if ( ++n_complaints_cap < 8 ) {
End Check: 3
The real line:              out() << "couldn't make room for new record (len: " << len << ") in capped ns " << ns << '\n';
End Check: 3
The real line:              int i = 0;
End Check: 3
The real line:              for ( DiskLoc e = firstExtent; !e.isNull(); e = e.ext()->xnext, ++i ) {
End Check: 4
The real line:                  out() << "  Extent " << i;
End Check: 4
The real line:                  if ( e == capExtent )
End Check: 4
The real line:                      out() << " (capExtent)";
End Check: 4
The real line:                  out() << '\n';
End Check: 4
The real line:                  out() << "    magic: " << hex << e.ext()->magic << dec << " extent->ns: " << e.ext()->nsDiagnostic.buf << '\n';
End Check: 4
The real line:                  out() << "    fr: " << e.ext()->firstRecord.toString() <<
End Check: 4
The real line:                       " lr: " << e.ext()->lastRecord.toString() << " extent->len: " << e.ext()->length << '\n';
End Check: 4
The real line:              }
End Check: 3
The real line:              assert( len * 5 > lastExtentSize ); // assume it is unusually large record; if not, something is broken
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
377 : 392
Next: (char *ns, int len )
The real line:      DiskLoc NamespaceDetails::__capAlloc( int len ) {
Current Name Search: 
Checking if function:      DiskLoc NamespaceDetails::__capAlloc( int len ) {
PATTERN 4
Function: DiskLoc NamespaceDetails::__capAlloc( int len ) {
Depths: 2:1
[]
The real line:          DiskLoc prev = deletedList[ 1 ];
End Check: 2
The real line:          DiskLoc i = firstDeletedInCapExtent();
End Check: 2
The real line:          DiskLoc ret;
End Check: 2
The real line:          for (; !i.isNull() && inCapExtent( i ); prev = i, i = i.drec()->nextDeleted ) {
End Check: 3
The real line:              // We need to keep at least one DR per extent in deletedList[ 0 ],
End Check: 3
The real line:              // so make sure there's space to create a DR at the end.
End Check: 3
The real line:              if ( i.drec()->lengthWithHeaders >= len + 24 ) {
End Check: 4
The real line:                  ret = i;
End Check: 4
The real line:                  break;
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:          /* unlink ourself from the deleted list */
End Check: 2
The real line:          if ( !ret.isNull() ) {
End Check: 3
The real line:              if ( prev.isNull() )
End Check: 3
The real line:                  deletedList[ 0 ] = ret.drec()->nextDeleted;
End Check: 3
The real line:              else
End Check: 3
The real line:                  prev.drec()->nextDeleted = ret.drec()->nextDeleted;
End Check: 3
The real line:              ret.drec()->nextDeleted.setInvalid(); // defensive.
End Check: 3
The real line:              assert( ret.drec()->extentOfs < ret.getOfs() );
End Check: 3
The real line:          }
End Check: 2
The real line:          return ret;
End Check: 2
The real line:      }
End Check: 1
394 : 418
Next: ( int len )
The real line:      void NamespaceDetails::checkMigrate() {
Current Name Search: 
Checking if function:      void NamespaceDetails::checkMigrate() {
PATTERN 4
Function: void NamespaceDetails::checkMigrate() {
Depths: 2:1
[]
The real line:          // migrate old NamespaceDetails format
End Check: 2
The real line:          if ( capped && capExtent.a() == 0 && capExtent.getOfs() == 0 ) {
End Check: 3
The real line:              capFirstNewRecord = DiskLoc();
End Check: 3
The real line:              capFirstNewRecord.setInvalid();
End Check: 3
The real line:              // put all the DeletedRecords in deletedList[ 0 ]
End Check: 3
The real line:              for ( int i = 1; i < Buckets; ++i ) {
End Check: 4
The real line:                  DiskLoc first = deletedList[ i ];
End Check: 4
The real line:                  if ( first.isNull() )
End Check: 4
The real line:                      continue;
End Check: 4
The real line:                  DiskLoc last = first;
End Check: 4
The real line:                  for (; !last.drec()->nextDeleted.isNull(); last = last.drec()->nextDeleted );
End Check: 4
The real line:                  last.drec()->nextDeleted = deletedList[ 0 ];
End Check: 4
The real line:                  deletedList[ 0 ] = first;
End Check: 4
The real line:                  deletedList[ i ] = DiskLoc();
End Check: 4
The real line:              }
End Check: 3
The real line:              // NOTE deletedList[ 1 ] set to DiskLoc() in above
End Check: 3
The real line:              // Last, in case we're killed before getting here
End Check: 3
The real line:              capExtent = firstExtent;
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
420 : 441
Next: ()
The real line:      /* alloc with capped table handling. */
Current Name Search: 
Depths: 1:1
[]
The real line:      DiskLoc NamespaceDetails::_alloc(const char *ns, int len) {
Current Name Search:       
Checking if function:            DiskLoc NamespaceDetails::_alloc(const char *ns, int len) {
PATTERN 4
Function: DiskLoc NamespaceDetails::_alloc(const char *ns, int len) {
Depths: 2:1
[]
The real line:          if ( !capped )
End Check: 2
The real line:              return __stdAlloc(len);
End Check: 2
The real line:          // capped.
End Check: 2
The real line:          // signal done allocating new extents.
End Check: 2
The real line:          if ( !deletedList[ 1 ].isValid() )
End Check: 2
The real line:              deletedList[ 1 ] = DiskLoc();
End Check: 2
The real line:          assert( len < 400000000 );
End Check: 2
The real line:          int passes = 0;
End Check: 2
The real line: -        const int maxPasses = len / 30; // 30 is about the smallest entry that could go in the oplog
End Check: 2
LINE TO PARSE FOR KEYWORD:        const int maxpasses = len / 30; 
The real line: +        int maxPasses = len / 32; // 30 is about the smallest entry that could go in the oplog
End Check: 2
LINE TO PARSE FOR KEYWORD:        int maxpasses = len / 32; 
The real line: +        if ( maxPasses < 5000 ){
End Check: 3
LINE TO PARSE FOR KEYWORD:        if ( maxpasses < 5000 ){
The real line: +            // this is for bacwards safety since 5000 was the old value
End Check: 3
LINE TO PARSE FOR KEYWORD:            
The real line: +            maxPasses = 5000;
End Check: 3
LINE TO PARSE FOR KEYWORD:            maxpasses = 5000;
The real line: +        }
End Check: 2
LINE TO PARSE FOR KEYWORD:        }
The real line:          DiskLoc loc;
End Check: 2
The real line:          // delete records until we have room and the max # objects limit achieved.
End Check: 2
The real line:          /* this fails on a rename -- that is ok but must keep commented out */
End Check: 2
The real line:          //assert( theCapExtent()->ns == ns );
End Check: 2
The real line:          theCapExtent()->assertOk();
End Check: 2
The real line:          DiskLoc firstEmptyExtent;
End Check: 2
The real line:          while ( 1 ) {
End Check: 3
The real line:              if ( nrecords < max ) {
End Check: 4
The real line:                  loc = __capAlloc( len );
End Check: 4
The real line:                  if ( !loc.isNull() )
End Check: 4
The real line:                      break;
End Check: 4
The real line:              }
End Check: 3
The real line:              // If on first iteration through extents, don't delete anything.
End Check: 3
The real line:              if ( !capFirstNewRecord.isValid() ) {
End Check: 4
The real line:                  advanceCapExtent( ns );
End Check: 4
The real line:                  if ( capExtent != firstExtent )
End Check: 4
The real line:                      capFirstNewRecord.setInvalid();
End Check: 4
The real line:                  // else signal done with first iteration through extents.
End Check: 4
The real line:                  continue;
End Check: 4
The real line:              }
End Check: 3
The real line:              if ( !capFirstNewRecord.isNull() &&
End Check: 3
The real line:                      theCapExtent()->firstRecord == capFirstNewRecord ) {
End Check: 4
The real line:                  // We've deleted all records that were allocated on the previous
End Check: 4
The real line:                  // iteration through this extent.
End Check: 4
The real line:                  advanceCapExtent( ns );
End Check: 4
The real line:                  continue;
End Check: 4
The real line:              }
End Check: 3
The real line:              if ( theCapExtent()->firstRecord.isNull() ) {
End Check: 4
The real line:                  if ( firstEmptyExtent.isNull() )
End Check: 4
The real line:                      firstEmptyExtent = capExtent;
End Check: 4
The real line:                  advanceCapExtent( ns );
End Check: 4
The real line:                  if ( firstEmptyExtent == capExtent ) {
End Check: 5
The real line:                      maybeComplain( ns, len );
End Check: 5
The real line:                      return DiskLoc();
End Check: 5
The real line:                  }
End Check: 4
The real line:                  continue;
End Check: 4
The real line:              }
End Check: 3
The real line:              massert( 10344 ,  "Capped collection full and delete not allowed", cappedMayDelete() );
End Check: 3
The real line:              DiskLoc fr = theCapExtent()->firstRecord;
End Check: 3
The real line:              theDataFileMgr.deleteRecord(ns, fr.rec(), fr, true);
End Check: 3
The real line:              compact();
End Check: 3
The real line: -            if( ++passes >= maxPasses ) {
End Check: 3
LINE TO PARSE FOR KEYWORD:            if( ++passes >= maxpasses ) {
The real line: +            if( ++passes > maxPasses ) {
End Check: 4
LINE TO PARSE FOR KEYWORD:            if( ++passes > maxpasses ) {
The real line:                  log() << "passes ns:" << ns << " len:" << len << " maxPasses: " << maxPasses << '\n';
End Check: 4
The real line:                  log() << "passes max:" << max << " nrecords:" << nrecords << " datasize: " << datasize << endl;
End Check: 4
The real line:                  massert( 10345 ,  "passes >= maxPasses in capped collection alloc", false );
End Check: 4
The real line:              }
End Check: 3
The real line:          }
End Check: 2
The real line:          // Remember first record allocated on this iteration through capExtent.
End Check: 2
The real line:          if ( capFirstNewRecord.isValid() && capFirstNewRecord.isNull() )
End Check: 2
The real line:              capFirstNewRecord = loc;
End Check: 2
The real line:          return loc;
End Check: 2
The real line:      }
End Check: 1
444 : 523
Next: (const char *ns, int len)
The real line:      /* you MUST call when adding an index.  see pdfile.cpp */
Current Name Search: 
Depths: 1:1
[]
The real line:      IndexDetails& NamespaceDetails::addIndex(const char *thisns) {
Current Name Search:       
Checking if function:            IndexDetails& NamespaceDetails::addIndex(const char *thisns) {
PATTERN 4
Function: IndexDetails& NamespaceDetails::addIndex(const char *thisns) {
Depths: 2:1
[]
The real line:          assert( nsdetails(thisns) == this );
End Check: 2
The real line:          if( nIndexes == NIndexesBase && extraOffset == 0 ) { 
End Check: 3
The real line:              nsindex(thisns)->allocExtra(thisns);
End Check: 3
The real line:          }
End Check: 2
The real line:          IndexDetails& id = idx(nIndexes);
End Check: 2
The real line:          nIndexes++;
End Check: 2
The real line:          NamespaceDetailsTransient::get_w(thisns).addedIndex();
End Check: 2
The real line:          return id;
End Check: 2
The real line:      }
End Check: 1
526 : 537
Next: (const char *thisns)
The real line:      // must be called when renaming a NS to fix up extra
Current Name Search: 
Depths: 1:1
[]
The real line:      void NamespaceDetails::copyingFrom(const char *thisns, NamespaceDetails *src) { 
Current Name Search:       
Checking if function:            void NamespaceDetails::copyingFrom(const char *thisns, NamespaceDetails *src) {
PATTERN 4
Function: void NamespaceDetails::copyingFrom(const char *thisns, NamespaceDetails *src) {
Depths: 2:1
[]
The real line:          if( extraOffset ) {
End Check: 3
The real line:              extraOffset = 0; // so allocExtra() doesn't assert.
End Check: 3
The real line:              Extra *e = nsindex(thisns)->allocExtra(thisns);
End Check: 3
The real line:              memcpy(e, src->extra(), sizeof(Extra));
End Check: 3
The real line:          } 
End Check: 2
The real line:      }
End Check: 1
540 : 546
Next: (const char *thisns, NamespaceDetails *src)
The real line:      /* returns index of the first index in which the field is present. -1 if not present.
Current Name Search: 
Depths: 1:1
[]
The real line:         (aug08 - this method not currently used)
The real line:      */
The real line:      int NamespaceDetails::fieldIsIndexed(const char *fieldName) {
Current Name Search:       
Checking if function:            int NamespaceDetails::fieldIsIndexed(const char *fieldName) {
PATTERN 4
Function: int NamespaceDetails::fieldIsIndexed(const char *fieldName) {
Depths: 2:1
[]
The real line:          massert( 10346 , "not implemented", false);
End Check: 2
The real line:          /*
End Check: 2
The real line:          for ( int i = 0; i < nIndexes; i++ ) {
The real line:              IndexDetails& idx = indexes[i];
The real line:              BSONObj idxKey = idx.info.obj().getObjectField("key"); // e.g., { ts : -1 }
The real line:              if ( !idxKey.getField(fieldName).eoo() )
The real line:                  return i;
The real line:          }*/
The real line:          return -1;
End Check: 2
The real line:      }
End Check: 1
551 : 561
Next: (const char *fieldName)
The real line:      long long NamespaceDetails::storageSize( int * numExtents ){
Current Name Search: 
Checking if function:      long long NamespaceDetails::storageSize( int * numExtents ){
PATTERN 1
Function:  long NamespaceDetails::storageSize( int * numExtents ){
Depths: 2:1
[]
The real line:          Extent * e = firstExtent.ext();
End Check: 2
The real line:          assert( e );
End Check: 2
The real line:          long long total = 0;
End Check: 2
The real line:          int n = 0;
End Check: 2
The real line:          while ( e ){
End Check: 3
The real line:              total += e->length;
End Check: 3
The real line:              e = e->getNextExtent();
End Check: 3
The real line:              n++;
End Check: 3
The real line:          }
End Check: 2
The real line:          if ( numExtents )
End Check: 2
The real line:              *numExtents = n;
End Check: 2
The real line:          return total;
End Check: 2
The real line:      }
End Check: 1
563 : 579
Next: ( int * numExtents )
The real line:      /* ------------------------------------------------------------------------- */
Current Name Search: 
Depths: 1:1
[]
The real line:      boost::mutex NamespaceDetailsTransient::_qcMutex;
Current Name Search:       
Depths: 1:1
[]
The real line:      map< string, shared_ptr< NamespaceDetailsTransient > > NamespaceDetailsTransient::_map;
Current Name Search:      boost::mutex NamespaceDetailsTransient::_qcMutex; 
Depths: 1:1
[]
The real line:      typedef map< string, shared_ptr< NamespaceDetailsTransient > >::iterator ouriter;
Current Name Search:      map< string, shared_ptr< NamespaceDetailsTransient > > NamespaceDetailsTransient::_map; 
Depths: 1:1
[]
The real line:      void NamespaceDetailsTransient::reset() {
Current Name Search:      typedef map< string, shared_ptr< NamespaceDetailsTransient > >::iterator ouriter; 
Checking if function:      typedef map< string, shared_ptr< NamespaceDetailsTransient > >::iterator ouriter;      void NamespaceDetailsTransient::reset() {
PATTERN 1
Function:  void NamespaceDetailsTransient::reset() {
Depths: 2:1
[]
The real line:          clearQueryCache();
End Check: 2
The real line:          _keysComputed = false;
End Check: 2
The real line:          _indexSpecs.clear();
End Check: 2
The real line:      }
End Check: 1
587 : 591
Next: ()
The real line:  /*    NamespaceDetailsTransient& NamespaceDetailsTransient::get(const char *ns) {
Current Name Search: 
Depths: 1:1
[]
The real line:          shared_ptr< NamespaceDetailsTransient > &t = map_[ ns ];
The real line:          if ( t.get() == 0 )
The real line:              t.reset( new NamespaceDetailsTransient(ns) );
The real line:          return *t;
The real line:      }
The real line:  */
The real line:      void NamespaceDetailsTransient::clearForPrefix(const char *prefix) {
Current Name Search:   
Checking if function:        void NamespaceDetailsTransient::clearForPrefix(const char *prefix) {
PATTERN 4
Function: void NamespaceDetailsTransient::clearForPrefix(const char *prefix) {
Depths: 2:1
[]
The real line:          assertInWriteLock();
End Check: 2
The real line:          vector< string > found;
End Check: 2
The real line:          for( ouriter i = _map.begin(); i != _map.end(); ++i )
End Check: 2
The real line:              if ( strncmp( i->first.c_str(), prefix, strlen( prefix ) ) == 0 )
End Check: 2
The real line:                  found.push_back( i->first );
End Check: 2
The real line:          for( vector< string >::iterator i = found.begin(); i != found.end(); ++i ) {
End Check: 3
The real line:              _map[ *i ].reset();
End Check: 3
The real line:          }
End Check: 2
The real line:      }
End Check: 1
600 : 609
Next: (const char *prefix)
The real line:      void NamespaceDetailsTransient::computeIndexKeys() {
Current Name Search: 
Checking if function:      void NamespaceDetailsTransient::computeIndexKeys() {
PATTERN 4
Function: void NamespaceDetailsTransient::computeIndexKeys() {
Depths: 2:1
[]
The real line:          _keysComputed = true;
End Check: 2
The real line:          _indexKeys.clear();
End Check: 2
The real line:          NamespaceDetails *d = nsdetails(_ns.c_str());
End Check: 2
The real line:          if ( ! d )
End Check: 2
The real line:              return;
End Check: 2
The real line:          NamespaceDetails::IndexIterator i = d->ii();
End Check: 2
The real line:          while( i.more() )
End Check: 2
The real line:              i.next().keyPattern().getFieldNames(_indexKeys);
End Check: 2
The real line:      }
End Check: 1
611 : 620
Next: ()
The real line:      void NamespaceDetailsTransient::cllStart( int logSizeMb ) {
Current Name Search: 
Checking if function:      void NamespaceDetailsTransient::cllStart( int logSizeMb ) {
PATTERN 4
Function: void NamespaceDetailsTransient::cllStart( int logSizeMb ) {
Depths: 2:1
[]
The real line:          assertInWriteLock();
End Check: 2
The real line:          _cll_ns = "local.temp.oplog." + _ns;
End Check: 2
The real line:          _cll_enabled = true;
End Check: 2
The real line:          stringstream spec;
End Check: 2
The real line:          // 128MB
End Check: 2
The real line:          spec << "{size:" << logSizeMb * 1024 * 1024 << ",capped:true,autoIndexId:false}";
End Check: 2
The real line:          Client::Context ct( _cll_ns );
End Check: 2
The real line:          string err;
End Check: 2
The real line:          massert( 10347 ,  "Could not create log ns", userCreateNS( _cll_ns.c_str(), fromjson( spec.str() ), err, false ) );
End Check: 2
The real line:          NamespaceDetails *d = nsdetails( _cll_ns.c_str() );
End Check: 2
The real line:          d->cappedDisallowDelete();
End Check: 2
The real line:      }
End Check: 1
622 : 634
Next: ( int logSizeMb )
The real line:      void NamespaceDetailsTransient::cllInvalidate() {
Current Name Search: 
Checking if function:      void NamespaceDetailsTransient::cllInvalidate() {
PATTERN 4
Function: void NamespaceDetailsTransient::cllInvalidate() {
Depths: 2:1
[]
The real line:          assertInWriteLock();
End Check: 2
The real line:          cllDrop();
End Check: 2
The real line:          _cll_enabled = false;
End Check: 2
The real line:      }
End Check: 1
636 : 640
Next: ()
The real line:      bool NamespaceDetailsTransient::cllValidateComplete() {
Current Name Search: 
Checking if function:      bool NamespaceDetailsTransient::cllValidateComplete() {
PATTERN 4
Function: bool NamespaceDetailsTransient::cllValidateComplete() {
Depths: 2:1
[]
The real line:          assertInWriteLock();
End Check: 2
The real line:          cllDrop();
End Check: 2
The real line:          bool ret = _cll_enabled;
End Check: 2
The real line:          _cll_enabled = false;
End Check: 2
The real line:          _cll_ns = "";
End Check: 2
The real line:          return ret;
End Check: 2
The real line:      }
End Check: 1
642 : 649
Next: ()
The real line:      void NamespaceDetailsTransient::cllDrop() {
Current Name Search: 
Checking if function:      void NamespaceDetailsTransient::cllDrop() {
PATTERN 4
Function: void NamespaceDetailsTransient::cllDrop() {
Depths: 2:1
[]
The real line:          assertInWriteLock();
End Check: 2
The real line:          if ( !_cll_enabled )
End Check: 2
The real line:              return;
End Check: 2
The real line:          Client::Context ctx( _cll_ns );
End Check: 2
The real line:          dropNS( _cll_ns );
End Check: 2
The real line:      }
End Check: 1
651 : 657
Next: ()
The real line:      /* ------------------------------------------------------------------------- */
Current Name Search: 
Depths: 1:1
[]
The real line:      /* add a new namespace to the system catalog (<dbname>.system.namespaces).
Current Name Search:       
Depths: 1:1
[]
The real line:         options: { capped : ..., size : ... }
The real line:      */
The real line:      void addNewNamespaceToCatalog(const char *ns, const BSONObj *options = 0) {
Current Name Search:             
Checking if function:                  void addNewNamespaceToCatalog(const char *ns, const BSONObj *options = 0) {
Namespace:                 void addNewNamespaceToCatalog(const char *ns, const BSONObj *options = 0) {
Depths: 2:2
[]
The real line:          log(1) << "New namespace: " << ns << '\n';
Current Name Search: 
Depths: 2:2
[]
The real line:          if ( strstr(ns, "system.namespaces") ) {
Current Name Search:          log(1) <<  << ns << ; 
Checking if function:          log(1) <<  << ns << ;          if ( strstr(ns, ) ) {
Other type of bracket:          log(1) <<  << ns << ;          if ( strstr(ns, ) ) {
Depths: 3:3
[]
The real line:              // system.namespaces holds all the others, so it is not explicitly listed in the catalog.
Current Name Search: 
Depths: 3:3
[]
The real line:              // TODO: fix above should not be strstr!
Current Name Search:               
Depths: 3:3
[]
The real line:              return;
Current Name Search:                             
Depths: 3:3
[]
The real line:          }
Current Name Search:              return; 
Depths: 2:3
[]
Adjusting depth.
The real line:          {
Current Name Search:              return;          } 
Checking if function:              return;          }          {
Other type of bracket:              return;          }          {
Depths: 3:3
[]
The real line:              BSONObjBuilder b;
Current Name Search: 
Depths: 3:3
[]
The real line:              b.append("name", ns);
Current Name Search:              BSONObjBuilder b; 
Depths: 3:3
[]
The real line:              if ( options )
Current Name Search:              b.append(, ns); 
Depths: 3:3
[]
The real line:                  b.append("options", *options);
Current Name Search:              b.append(, ns);              if ( options ) 
Depths: 3:3
[]
The real line:              BSONObj j = b.done();
Current Name Search:                  b.append(, *options); 
Depths: 3:3
[]
The real line:              char database[256];
Current Name Search:              BSONObj j = b.done(); 
Depths: 3:3
[]
The real line:              nsToDatabase(ns, database);
Current Name Search:              char database[256]; 
Depths: 3:3
[]
The real line:              string s = database;
Current Name Search:              nsToDatabase(ns, database); 
Depths: 3:3
[]
The real line:              s += ".system.namespaces";
Current Name Search:              string s = database; 
Depths: 3:3
[]
The real line:              theDataFileMgr.insert(s.c_str(), j.objdata(), j.objsize(), true);
Current Name Search:              s += ; 
Depths: 3:3
[]
The real line:          }
Current Name Search:              theDataFileMgr.insert(s.c_str(), j.objdata(), j.objsize(), true); 
Depths: 2:3
[]
Adjusting depth.
The real line:      }
Current Name Search:              theDataFileMgr.insert(s.c_str(), j.objdata(), j.objsize(), true);          } 
Depths: 1:2
[]
Adjusting depth.
The real line:      void renameNamespace( const char *from, const char *to ) {
Current Name Search:              theDataFileMgr.insert(s.c_str(), j.objdata(), j.objsize(), true);          }      } 
Checking if function:              theDataFileMgr.insert(s.c_str(), j.objdata(), j.objsize(), true);          }      }      void renameNamespace( const char *from, const char *to ) {
PATTERN 1
Function:  void renameNamespace(char *from,char *to ) {
Depths: 2:1
[]
The real line:  		NamespaceIndex *ni = nsindex( from );
End Check: 2
The real line:  		assert( ni && ni->details( from ) && !ni->details( to ) );
End Check: 2
The real line:  		// Our namespace and index details will move to a different 
End Check: 2
The real line:  		// memory location.  The only references to namespace and 
End Check: 2
The real line:  		// index details across commands are in cursors and nsd
End Check: 2
The real line:  		// transient (including query cache) so clear these.
End Check: 2
The real line:  		ClientCursor::invalidate( from );
End Check: 2
The real line:  		NamespaceDetailsTransient::clearForPrefix( from );
End Check: 2
The real line:  		NamespaceDetails *details = ni->details( from );
End Check: 2
The real line:  		ni->add_ns( to, *details );
End Check: 2
The real line:          NamespaceDetails *todetails = ni->details( to );
End Check: 2
The real line:          try { 
End Check: 3
The real line:              todetails->copyingFrom(to, details); // fixes extraOffset
End Check: 3
The real line:          }
End Check: 2
The real line:          catch( DBException& ) { 
End Check: 3
The real line:              // could end up here if .ns is full - if so try to clean up / roll back a little
End Check: 3
The real line:              ni->kill_ns(to);
End Check: 3
The real line:              throw;
End Check: 3
The real line:          }
End Check: 2
The real line:  		ni->kill_ns( from );
End Check: 2
The real line:  		details = todetails;
End Check: 2
The real line:  		BSONObj oldSpec;
End Check: 2
The real line:  		char database[MaxDatabaseLen];
End Check: 2
The real line:  		nsToDatabase(from, database);
End Check: 2
The real line:  		string s = database;
End Check: 2
The real line:  		s += ".system.namespaces";
End Check: 2
The real line:  		assert( Helpers::findOne( s.c_str(), BSON( "name" << from ), oldSpec ) );
End Check: 2
The real line:  		BSONObjBuilder newSpecB;
End Check: 2
The real line:  		BSONObjIterator i( oldSpec.getObjectField( "options" ) );
End Check: 2
The real line:  		while( i.more() ) {
End Check: 3
The real line:  			BSONElement e = i.next();
End Check: 3
The real line:  			if ( strcmp( e.fieldName(), "create" ) != 0 )
End Check: 3
The real line:  				newSpecB.append( e );
End Check: 3
The real line:  			else
End Check: 3
The real line:  				newSpecB << "create" << to;
End Check: 3
The real line:  		}
End Check: 2
The real line:  		BSONObj newSpec = newSpecB.done();    
End Check: 2
The real line:  		addNewNamespaceToCatalog( to, newSpec.isEmpty() ? 0 : &newSpec );
End Check: 2
The real line:  		deleteObjects( s.c_str(), BSON( "name" << from ), false, false, true );
End Check: 2
The real line:  		// oldSpec variable no longer valid memory
End Check: 2
The real line:  		BSONObj oldIndexSpec;
End Check: 2
The real line:  		s = database;
End Check: 2
The real line:  		s += ".system.indexes";
End Check: 2
The real line:  		while( Helpers::findOne( s.c_str(), BSON( "ns" << from ), oldIndexSpec ) ) {
End Check:. 3
The real line:  			BSONObjBuilder newIndexSpecB;
End Check: 3
The real line:  			BSONObjIterator i( oldIndexSpec );
End Check: 3
The real line:  			while( i.more() ) {
End Check: 4
The real line:  				BSONElement e = i.next();
End Check: 4
The real line:  				if ( strcmp( e.fieldName(), "ns" ) != 0 )
End Check: 4
The real line:  					newIndexSpecB.append( e );
End Check: 4
The real line:  				else
End Check: 4
The real line:  					newIndexSpecB << "ns" << to;
End Check: 4
The real line:  			}
End Check: 3
The real line:  			BSONObj newIndexSpec = newIndexSpecB.done();
End Check: 3
The real line:  			DiskLoc newIndexSpecLoc = theDataFileMgr.insert( s.c_str(), newIndexSpec.objdata(), newIndexSpec.objsize(), true, BSONElement(), false );
End Check: 3
The real line:  			int indexI = details->findIndexByName( oldIndexSpec.getStringField( "name" ) );
End Check: 3
The real line:  			IndexDetails &indexDetails = details->idx(indexI);
End Check: 3
The real line:  			string oldIndexNs = indexDetails.indexNamespace();
End Check: 3
The real line:  			indexDetails.info = newIndexSpecLoc;
End Check: 3
The real line:  			string newIndexNs = indexDetails.indexNamespace();
End Check: 3
The real line:  			BtreeBucket::renameIndexNamespace( oldIndexNs.c_str(), newIndexNs.c_str() );
End Check: 3
The real line:  			deleteObjects( s.c_str(), oldIndexSpec.getOwned(), true, false, true );
End Check: 3
The real line:  		}
End Check: 2
The real line:  	}
End Check: 1
686 : 757
Next: (char *from,char *to )
The real line:      bool legalClientSystemNS( const string& ns , bool write ){
Current Name Search: 
Checking if function:      bool legalClientSystemNS( const string& ns , bool write ){
PATTERN 4
Function: bool legalClientSystemNS(string& ns , bool write ){
Depths: 2:1
[]
The real line:          if ( ns.find( ".system.users" ) != string::npos )
End Check: 2
The real line:              return true;
End Check: 2
The real line:          if ( ns.find( ".system.js" ) != string::npos ){
End Check: 3
The real line:              if ( write )
End Check: 3
The real line:                  Scope::storedFuncMod();
End Check: 3
The real line:              return true;
End Check: 3
The real line:          }
End Check: 2
The real line:          return false;
End Check: 2
The real line:      }
End Check: 1
759 : 770
Next: (string& ns , bool write )
The real line:  } // namespace mongo
Current Name Search: 
Depths: 0:1
[]
Adjusting depth.
Chunk End.
The real line: void mysql_stmt_fetch(THD *thd, char *packet, uint packet_length)
Current Name Search: 
Depths: 0:0
[]
The real line:  {
Current Name Search: void mysql_stmt_fetch(THD *thd, char *packet, uint packet_length) 
Checking if function: void mysql_stmt_fetch(THD *thd, char *packet, uint packet_length)  {
PATTERN 4
Function: void mysql_stmt_fetch(THD *thd, char *packet, uint packet_length)  {
Depths: 1:0
[]
The real line:    /* assume there is always place for 8-16 bytes */
End Check: 1
The real line:    ulong stmt_id= uint4korr(packet);
End Check: 1
The real line:    ulong num_rows= uint4korr(packet+4);
End Check: 1
The real line:    Prepared_statement *stmt;
End Check: 1
The real line:    Statement stmt_backup;
End Check: 1
The real line:    Server_side_cursor *cursor;
End Check: 1
The real line:    DBUG_ENTER("mysql_stmt_fetch");
End Check: 1
The real line:    /* First of all clear possible warnings from the previous command */
End Check: 1
The real line:    mysql_reset_thd_for_next_command(thd);
End Check: 1
The real line:    status_var_increment(thd->status_var.com_stmt_fetch);
End Check: 1
The real line: -  if (!(stmt= find_prepared_statement(thd, stmt_id, "mysql_stmt_fetch")))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt= find_prepared_statement(thd, stmt_id, )))
The real line: +  if (!(stmt= find_prepared_statement(thd, stmt_id)))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt= find_prepared_statement(thd, stmt_id)))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    char llbuf[22];
End Check: 2
LINE TO PARSE FOR KEYWORD:    char llbuf[22];
The real line: +    my_error(ER_UNKNOWN_STMT_HANDLER, MYF(0), sizeof(llbuf),
End Check: 2
LINE TO PARSE FOR KEYWORD:    my_error(er_unknown_stmt_handler, myf(0), sizeof(llbuf),
The real line: +             llstr(stmt_id, llbuf), "mysql_stmt_fetch");
End Check: 2
LINE TO PARSE FOR KEYWORD:             llstr(stmt_id, llbuf), );
The real line:      DBUG_VOID_RETURN;
End Check: 2
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line:    cursor= stmt->cursor;
End Check: 1
The real line:    if (!cursor)
End Check: 1
The real line:    {
End Check: 2
The real line:      my_error(ER_STMT_HAS_NO_OPEN_CURSOR, MYF(0), stmt_id);
End Check: 2
The real line:      DBUG_VOID_RETURN;
End Check: 2
The real line:    }
End Check: 1
The real line:    thd->stmt_arena= stmt;
End Check: 1
The real line:    thd->set_n_backup_statement(stmt, &stmt_backup);
End Check: 1
The real line:    if (!(specialflag & SPECIAL_NO_PRIOR))
End Check: 1
The real line:      my_pthread_setprio(pthread_self(), QUERY_PRIOR);
End Check: 1
The real line:    cursor->fetch(num_rows);
End Check: 1
The real line:    if (!(specialflag & SPECIAL_NO_PRIOR))
End Check: 1
The real line:      my_pthread_setprio(pthread_self(), WAIT_PRIOR);
End Check: 1
The real line:    if (!cursor->is_open())
End Check: 1
The real line:    {
End Check: 2
The real line:      stmt->close_cursor();
End Check: 2
The real line:      thd->cursor= 0;
End Check: 2
The real line:      reset_stmt_params(stmt);
End Check: 2
The real line:    }
End Check: 1
The real line:    thd->restore_backup_statement(stmt, &stmt_backup);
End Check: 1
The real line:    thd->stmt_arena= thd;
End Check: 1
The real line:    DBUG_VOID_RETURN;
End Check: 1
The real line:  }
End Check: 0
2 : 52
Next: (THD *thd, char *packet, uint packet_length)
The real line:  /**
Current Name Search: 
Depths: 0:0
[]
The real line:    Reset a prepared statement in case there was a recoverable error.
The real line:      This function resets statement to the state it was right after prepare.
The real line:      It can be used to:
The real line:      - clear an error happened during mysql_stmt_send_long_data
The real line:      - cancel long data stream for all placeholders without
The real line:        having to call mysql_stmt_execute.
The real line:      - close an open cursor
The real line:      Sends 'OK' packet in case of success (statement was reset)
The real line:      or 'ERROR' packet (unrecoverable error/statement not found/etc).
The real line:    @param thd                Thread handle
The real line:    @param packet             Packet with stmt id
The real line:  */
The real line:  void mysql_stmt_reset(THD *thd, char *packet)
Current Name Search:   
Depths: 0:0
[]
The real line:  {
Current Name Search:    void mysql_stmt_reset(THD *thd, char *packet) 
Checking if function:    void mysql_stmt_reset(THD *thd, char *packet)  {
PATTERN 4
Function: void mysql_stmt_reset(THD *thd, char *packet)  {
Depths: 1:0
[]
The real line:    /* There is always space for 4 bytes in buffer */
End Check: 1
The real line:    ulong stmt_id= uint4korr(packet);
End Check: 1
The real line:    Prepared_statement *stmt;
End Check: 1
The real line:    DBUG_ENTER("mysql_stmt_reset");
End Check: 1
The real line:    /* First of all clear possible warnings from the previous command */
End Check: 1
The real line:    mysql_reset_thd_for_next_command(thd);
End Check: 1
The real line:    status_var_increment(thd->status_var.com_stmt_reset);
End Check: 1
The real line: -  if (!(stmt= find_prepared_statement(thd, stmt_id, "mysql_stmt_reset")))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt= find_prepared_statement(thd, stmt_id, )))
The real line: +  if (!(stmt= find_prepared_statement(thd, stmt_id)))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt= find_prepared_statement(thd, stmt_id)))
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    char llbuf[22];
End Check: 2
LINE TO PARSE FOR KEYWORD:    char llbuf[22];
The real line: +    my_error(ER_UNKNOWN_STMT_HANDLER, MYF(0), sizeof(llbuf),
End Check: 2
LINE TO PARSE FOR KEYWORD:    my_error(er_unknown_stmt_handler, myf(0), sizeof(llbuf),
The real line: +             llstr(stmt_id, llbuf), "mysql_stmt_reset");
End Check: 2
LINE TO PARSE FOR KEYWORD:             llstr(stmt_id, llbuf), );
The real line:      DBUG_VOID_RETURN;
End Check: 2
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line:    stmt->close_cursor();
End Check: 1
The real line:    /*
End Check: 1
The real line:      Clear parameters from data which could be set by
The real line:      mysql_stmt_send_long_data() call.
The real line:    */
The real line:    reset_stmt_params(stmt);
End Check: 1
The real line:    stmt->state= Query_arena::PREPARED;
End Check: 1
The real line:    general_log_print(thd, thd->command, NullS);
End Check: 1
The real line:    my_ok(thd);
End Check: 1
The real line:    DBUG_VOID_RETURN;
End Check: 1
The real line:  }
End Check: 0
72 : 106
Next: (THD *thd, char *packet)
The real line:  /**
Current Name Search: 
Depths: 0:0
[]
The real line:    Delete a prepared statement from memory.
The real line:    @note
The real line:      we don't send any reply to this command.
The real line:  */
The real line:  void mysql_stmt_close(THD *thd, char *packet)
Current Name Search:   
Depths: 0:0
[]
The real line:  {
Current Name Search:    void mysql_stmt_close(THD *thd, char *packet) 
Checking if function:    void mysql_stmt_close(THD *thd, char *packet)  {
PATTERN 4
Function: void mysql_stmt_close(THD *thd, char *packet)  {
Depths: 1:0
[]
The real line:    /* There is always space for 4 bytes in packet buffer */
End Check: 1
The real line:    ulong stmt_id= uint4korr(packet);
End Check: 1
The real line:    Prepared_statement *stmt;
End Check: 1
The real line:    DBUG_ENTER("mysql_stmt_close");
End Check: 1
The real line:    thd->main_da.disable_status();
End Check: 1
The real line: -  if (!(stmt= find_prepared_statement(thd, stmt_id, "mysql_stmt_close")))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt= find_prepared_statement(thd, stmt_id, )))
The real line: +  if (!(stmt= find_prepared_statement(thd, stmt_id)))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt= find_prepared_statement(thd, stmt_id)))
The real line:      DBUG_VOID_RETURN;
End Check: 1
The real line:    /*
End Check: 1
The real line:      The only way currently a statement can be deallocated when it's
The real line:      in use is from within Dynamic SQL.
The real line:    */
The real line: -  DBUG_ASSERT(! (stmt->flags & (uint) Prepared_statement::IS_IN_USE));
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_assert(! (stmt->flags & (uint) prepared_statement::is_in_use));
The real line: -  (void) stmt->deallocate();
End Check: 1
LINE TO PARSE FOR KEYWORD:  (void) stmt->deallocate();
The real line: +  DBUG_ASSERT(! stmt->is_in_use());
End Check: 1
LINE TO PARSE FOR KEYWORD:  dbug_assert(! stmt->is_in_use());
The real line: +  stmt->deallocate();
End Check: 1
LINE TO PARSE FOR KEYWORD:  stmt->deallocate();
The real line:    general_log_print(thd, thd->command, NullS);
End Check: 1
The real line:    DBUG_VOID_RETURN;
End Check: 1
The real line:  }
End Check: 0
117 : 140
Next: (THD *thd, char *packet)
The real line:  /**
Current Name Search: 
Depths: 0:0
[]
The real line:    SQLCOM_DEALLOCATE implementation.
The real line:      Close an SQL prepared statement. As this can be called from Dynamic
The real line:      SQL, we should be careful to not close a statement that is currently
The real line:      being executed.
The real line:    @return
The real line:      none: OK packet is sent in case of success, otherwise an error
The real line:      message is set in THD
The real line:  */
The real line:  void mysql_sql_stmt_close(THD *thd)
Current Name Search:   
Depths: 0:0
[]
The real line:  {
Current Name Search:    void mysql_sql_stmt_close(THD *thd) 
Checking if function:    void mysql_sql_stmt_close(THD *thd)  {
PATTERN 4
Function: void mysql_sql_stmt_close(THD *thd)  {
Depths: 1:0
[]
The real line:    Prepared_statement* stmt;
End Check: 1
The real line:    LEX_STRING *name= &thd->lex->prepared_stmt_name;
End Check: 1
The real line:    DBUG_PRINT("info", ("DEALLOCATE PREPARE: %.*s\n", (int) name->length,
End Check: 1
The real line:                        name->str));
End Check: 1
The real line:    if (! (stmt= (Prepared_statement*) thd->stmt_map.find_by_name(name)))
End Check: 1
The real line: -  {
End Check: 1
LINE TO PARSE FOR KEYWORD:  {
The real line:      my_error(ER_UNKNOWN_STMT_HANDLER, MYF(0),
End Check: 1
The real line:               name->length, name->str, "DEALLOCATE PREPARE");
End Check: 1
The real line: -    return;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return;
The real line: -  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: -
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: -  if (stmt->deallocate() == 0)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (stmt->deallocate() == 0)
The real line: +  else if (stmt->is_in_use())
End Check: 1
LINE TO PARSE FOR KEYWORD:  else if (stmt->is_in_use())
The real line: +    my_error(ER_PS_NO_RECURSION, MYF(0));
End Check: 1
LINE TO PARSE FOR KEYWORD:    my_error(er_ps_no_recursion, myf(0));
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    stmt->deallocate();
End Check: 2
LINE TO PARSE FOR KEYWORD:    stmt->deallocate();
The real line:      my_ok(thd);
End Check: 2
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line:  }
End Check: 0
156 : 177
Next: (THD *thd)
The real line:  /**
Current Name Search: 
Depths: 0:0
[]
The real line:    Handle long data in pieces from client.
The real line:      Get a part of a long data. To make the protocol efficient, we are
The real line:      not sending any return packets here. If something goes wrong, then
The real line:      we will send the error on 'execute' We assume that the client takes
The real line:      care of checking that all parts are sent to the server. (No checking
The real line:      that we get a 'end of column' in the server is performed).
The real line:    @param thd                Thread handle
The real line:    @param packet             String to append
The real line:    @param packet_length      Length of string (including end \\0)
The real line:  */
The real line:  void mysql_stmt_get_longdata(THD *thd, char *packet, ulong packet_length)
Current Name Search:   
Depths: 0:0
[]
The real line:  {
Current Name Search:    void mysql_stmt_get_longdata(THD *thd, char *packet, ulong packet_length) 
Checking if function:    void mysql_stmt_get_longdata(THD *thd, char *packet, ulong packet_length)  {
PATTERN 4
Function: void mysql_stmt_get_longdata(THD *thd, char *packet, ulong packet_length)  {
Depths: 1:0
[]
The real line:    ulong stmt_id;
End Check: 1
The real line:    uint param_number;
End Check: 1
The real line:    Prepared_statement *stmt;
End Check: 1
The real line:    Item_param *param;
End Check: 1
The real line:  #ifndef EMBEDDED_LIBRARY
End Check: 1
The real line:    char *packet_end= packet + packet_length;
End Check: 1
The real line:  #endif
End Check: 1
The real line:    DBUG_ENTER("mysql_stmt_get_longdata");
End Check: 1
The real line:    status_var_increment(thd->status_var.com_stmt_send_long_data);
End Check: 1
The real line:    thd->main_da.disable_status();
End Check: 1
The real line:  #ifndef EMBEDDED_LIBRARY
End Check: 1
The real line:    /* Minimal size of long data packet is 6 bytes */
End Check: 1
The real line:    if (packet_length < MYSQL_LONG_DATA_HEADER)
End Check: 1
The real line: -  {
End Check: 1
LINE TO PARSE FOR KEYWORD:  {
The real line: -    my_error(ER_WRONG_ARGUMENTS, MYF(0), "mysql_stmt_send_long_data");
End Check: 1
LINE TO PARSE FOR KEYWORD:    my_error(er_wrong_arguments, myf(0), );
The real line:      DBUG_VOID_RETURN;
End Check: 1
The real line: -  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line:  #endif
End Check: 1
The real line:    stmt_id= uint4korr(packet);
End Check: 1
The real line:    packet+= 4;
End Check: 1
The real line: -  if (!(stmt=find_prepared_statement(thd, stmt_id,
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt=find_pre.pared_statement(thd, stmt_id,
The real line: -                                     "mysql_stmt_send_long_data")))
End Check: 1
LINE TO PARSE FOR KEYWORD:                                     )))
The real line: +  if (!(stmt=find_prepared_statement(thd, stmt_id)))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!(stmt=find_prepared_statement(thd, stmt_id)))
The real line:      DBUG_VOID_RETURN;
End Check: 1
The real line:    param_number= uint2korr(packet);
End Check: 1
The real line:    packet+= 2;
End Check: 1
The real line:  #ifndef EMBEDDED_LIBRARY
End Check: 1
The real line:    if (param_number >= stmt->param_count)
End Check: 1
The real line:    {
End Check: 2
The real line:      /* Error will be sent in execute call */
End Check: 2
The real line:      stmt->state= Query_arena::ERROR;
End Check: 2
The real line:      stmt->last_errno= ER_WRONG_ARGUMENTS;
End Check: 2
The real line:      sprintf(stmt->last_error, ER(ER_WRONG_ARGUMENTS),
End Check: 2
The real line:              "mysql_stmt_send_long_data");
End Check: 2
The real line:      DBUG_VOID_RETURN;
End Check: 2
The real line:    }
End Check: 1
The real line:  #endif
End Check: 1
The real line:    param= stmt->param_array[param_number];
End Check: 1
The real line:  #ifndef EMBEDDED_LIBRARY
End Check: 1
The real line:    if (param->set_longdata(packet, (ulong) (packet_end - packet)))
End Check: 1
The real line:  #else
End Check: 1
The real line:    if (param->set_longdata(thd->extra_data, thd->extra_length))
End Check: 1
The real line:  #endif
End Check: 1
The real line:    {
End Check: 2
The real line:      stmt->state= Query_arena::ERROR;
End Check: 2
The real line:      stmt->last_errno= ER_OUTOFMEMORY;
End Check: 2
The real line:      sprintf(stmt->last_error, ER(ER_OUTOFMEMORY), 0);
End Check: 2
The real line:    }
End Check: 1
The real line:    general_log_print(thd, thd->command, NullS);
End Check: 1
The real line:    DBUG_VOID_RETURN;
End Check: 1
The real line:  }
End Check: 0
194 : 254
Next: (THD *thd, char *packet, ulong packet_length)
The real line:  /***************************************************************************
Current Name Search: 
Depths: 0:0
[]
The real line:   Select_fetch_protocol_binary
The real line:  ****************************************************************************/
Chunk End.
The real line: + template <class A_Type> class calc
Current Name Search: 
LINE TO PARSE FOR KEYWORD: template <class a_type> class calc
Depths: 0:0
[]
The real line: + {
Current Name Search:  template <class A_Type> class calc 
Checking if function:  template <class A_Type> class calc  {
Class: class calc  {
LINE TO PARSE FOR KEYWORD: {
Depths: 1:1
['calc']
The real line: +  public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  public:
Depths: 1:1
['calc']
The real line: +    A_Type multiply(A_Type x, A_Type y);
Current Name Search:   public: 
LINE TO PARSE FOR KEYWORD:    a_type multiply(a_type x, a_type y);
Depths: 1:1
['calc']
The real line: +    A_Type add(A_Type x, A_Type y);
Current Name Search:     A_Type multiply(A_Type x, A_Type y); 
LINE TO PARSE FOR KEYWORD:    a_type add(a_type x, a_type y);
Depths: 1:1
['calc']
The real line: + };
Current Name Search:     A_Type add(A_Type x, A_Type y); 
LINE TO PARSE FOR KEYWORD: };
Depths: 0:1
['calc']
Adjusting depth.
The real line: + template <class A_Type> A_Type calc<A_Type>::multiply(A_Type x,A_Type y)
Current Name Search:  }; 
LINE TO PARSE FOR KEYWORD: template <class a_type> a_type calc<a_type>::multiply(a_type x,a_type y)
Depths: 0:0
['calc']
The real line: + {
Current Name Search:  };  template <class A_Type> A_Type calc<A_Type>::multiply(A_Type x,A_Type y) 
Checking if function:  };  template <class A_Type> A_Type calc<A_Type>::multiply(A_Type x,A_Type y)  {
PATTERN T1
Function: template <class A_Type> A_Type calc<A_Type>::multiply(A_Type x,A_Type y)  {
LINE TO PARSE FOR KEYWORD: {
Depths: 1:0
['calc']
The real line: +   return x*y;
End Check: 1
LINE TO PARSE FOR KEYWORD:   return x*y;
The real line: + }
End Check: 0
LINE TO PARSE FOR KEYWORD: }
8 : 10
Next: (A_Type x,A_Type y)
The re.al line: + template <class A_Type> A_Type calc<A_Type>::add(A_Type x, A_Type y)
Current Name Search: 
LINE TO PARSE FOR KEYWORD: template <class a_type> a_type calc<a_type>::add(a_type x, a_type y)
Depths: 0:0
['calc']
The real line: + {
Current Name Search:  template <class A_Type> A_Type calc<A_Type>::add(A_Type x, A_Type y) 
Checking if function:  template <class A_Type> A_Type calc<A_Type>::add(A_Type x, A_Type y)  {
PATTERN T1
Function: template <class A_Type> A_Type calc<A_Type>::add(A_Type x, A_Type y)  {
LINE TO PARSE FOR KEYWORD: {
Depths: 1:0
['calc']
The real line: +  return x+y;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return x+y;
The real line: + }
End Check: 0
LINE TO PARSE FOR KEYWORD: }
12 : 14
Next: (A_Type x, A_Type y)
The real line: + template <class A_Type> A_Type calc<A_Type>::divide(A_Type x, A_Type y)
Current Name Search: 
LINE TO PARSE FOR KEYWORD: template <class a_type> a_type calc<a_type>::divide(a_type x, a_type y)
Depths: 0:0
['calc']
The real line: + {
Current Name Search:  template <class A_Type> A_Type calc<A_Type>::divide(A_Type x, A_Type y) 
Checking if function:  template <class A_Type> A_Type calc<A_Type>::divide(A_Type x, A_Type y)  {
PATTERN T1
Function: template <class A_Type> A_Type calc<A_Type>::divide(A_Type x, A_Type y)  {
LINE TO PARSE FOR KEYWORD: {
Depths: 1:0
['calc']
The real line: +  assert(y != 0);
End Check: 1
LINE TO PARSE FOR KEYWORD:  assert(y != 0);
The real line: +  return x/y;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return x/y;
The real line: + }
End Check: 0
LINE TO PARSE FOR KEYWORD: }
16 : 19
Next: (A_Type x, A_Type y)
Chunk End.
The real line: +/*
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + *      Copyright (C) 2012 Team XBMC
The real line: + *      http://www.xbmc.org
The real line: + *
The real line: + *  This Program is free software; you can redistribute it and/or modify
The real line: + *  it under the terms of the GNU General Public License as published by
The real line: + *  the Free Software Foundation; either version 2, or (at your option)
The real line: + *  any later version.
The real line: + *
The real line: + *  This Program is distributed in the hope that it will be useful,
The real line: + *  but WITHOUT ANY WARRANTY; without even the implied warranty of
The real line: + *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
The real line: + *  GNU General Public License for more details.
The real line: + *
The real line: + *  You should have received a copy of the GNU General Public License
The real line: + *  along with XBMC; see the file COPYING.  If not, write to
The real line: + *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
The real line: + *  http://www.gnu.org/copyleft/gpl.html
The real line: + *
The real line: + */
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "DVDInputStreams/DVDInputStream.h"
Current Name Search:   
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "DVDDemuxPVRClient.h"
Current Name Search:   #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "DVDDemuxUtils.h"
Current Name Search:   #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "utils/log.h"
Current Name Search:   #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "pvr/PVRManager.h"
Current Name Search:   #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "pvr/addons/PVRClients.h"
Current Name Search:   #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:   #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +using namespace PVR;
Current Name Search:   #include  #include  #include  #include  #include  #include   
LINE TO PARSE FOR KEYWORD:using namespace pvr;
Depths: 0:0
[]
The real line: +
Current Name Search: using namespace PVR; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDemuxStreamVideoPVRClient::GetStreamInfo(std::string& strInfo)
Current Name Search: using namespace PVR;  
LINE TO PARSE FOR KEYWORD:void cdemuxstreamvideopvrclient::getstreaminfo(std::string& strinfo)
Depths: 0:0
[]
The real line: +{
Current Name Search: using namespace PVR;  void CDemuxStreamVideoPVRClient::GetStreamInfo(std::string& strInfo) 
Checking if function: using namespace PVR;  void CDemuxStreamVideoPVRClient::GetStreamInfo(std::string& strInfo) {
PATTERN 1
Function:  void CDemuxStreamVideoPVRClient::GetStreamInfo(std::string& strInfo) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  switch (codec)
End Check: 1
LINE TO PARSE FOR KEYWORD:  switch (codec)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    case CODEC_ID_MPEG2VIDEO:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_mpeg2video:
The real line: +      strInfo = "mpeg2video";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case CODEC_ID_H264:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_h264:
The real line: +      strInfo = "h264";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    default:
End Check: 2
LINE TO PARSE FOR KEYWORD:    default:
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
32 : 44
Next: (std::string& strInfo)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDemuxStreamAudioPVRClient::GetStreamInfo(std::string& strInfo)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdemuxstreamaudiopvrclient::getstreaminfo(std::string& strinfo)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDemuxStreamAudioPVRClient::GetStreamInfo(std::string& strInfo) 
Checking if function:  void CDemuxStreamAudioPVRClient::GetStreamInfo(std::string& strInfo) {
PATTERN 4
Function: void CDemuxStreamAudioPVRClient::GetStreamInfo(std::string& strInfo) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  switch (codec)
End Check: 1
LINE TO PARSE FOR KEYWORD:  switch (codec)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    case CODEC_ID_AC3:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_ac3:
The real line: +      strInfo = "ac3";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case CODEC_ID_EAC3:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_eac3:
The real line: +      strInfo = "eac3";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case CODEC_ID_MP2:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_mp2:
The real line: +      strInfo = "mpeg2audio";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case CODEC_ID_AAC:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_aac:
The real line: +      strInfo = "aac";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    case CODEC_ID_DTS:
End Check: 2
LINE TO PARSE FOR KEYWORD:    case codec_id_dts:
The real line: +      strInfo = "dts";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strinfo = ;
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +    default:
End Check: 2
LINE TO PARSE FOR KEYWORD:    default:
The real line: +      break;
End Check: 2
LINE TO PARSE FOR KEYWORD:      break;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
47 : 68
Next: (std::string& strInfo)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDemuxStreamSubtitlePVRClient::GetStreamInfo(std::string& strInfo)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdemuxstreamsubtitlepvrclient::getstreaminfo(std::string& strinfo)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDemuxStreamSubtitlePVRClient::GetStreamInfo(std::string& strInfo) 
Checking if function:  void CDemuxStreamSubtitlePVRClient::GetStreamInfo(std::string& strInfo) {
PATTERN 4
Function: void CDemuxStreamSubtitlePVRClient::GetStreamInfo(std::string& strInfo) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
71 : 72
Next: (std::string& strInfo)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +CDVDDemuxPVRClient::CDVDDemuxPVRClient() : CDVDDemux()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:cdvddemuxpvrclient::cdvddemuxpvrclient() : cdvddemux()
Depths: 0:0
[]
The real line: +{
Current Name Search:  CDVDDemuxPVRClient::CDVDDemuxPVRClient() : CDVDDemux() 
Checking if function:  CDVDDemuxPVRClient::CDVDDemuxPVRClient() : CDVDDemux() {
Other type of bracket:  CDVDDemuxPVRClient::CDVDDemuxPVRClient() : CDVDDemux() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
[]
The real line: +  m_pInput = NULL;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  m_pinput = null;
Depths: 1:1
[]
The real line: +  for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL;
Current Name Search:   m_pInput = NULL; 
LINE TO PARSE FOR KEYWORD:  for (int i = 0; i < max_streams; i++) m_streams[i] = null;
Depths: 1:1
[]
The real line: +}
Current Name Search:   for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL; 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search:   for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL; } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +CDVDDemuxPVRClient::~CDVDDemuxPVRClient()
Current Name Search:   for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL; }  
LINE TO PARSE FOR KEYWORD:cdvddemuxpvrclient::~cdvddemuxpvrclient()
Depths: 0:0
[]
The real line: +{
Current Name Search:   for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL; }  CDVDDemuxPVRClient::~CDVDDemuxPVRClient() 
Checking if function:   for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL; }  CDVDDemuxPVRClient::~CDVDDemuxPVRClient() {
Other type of bracket:   for (int i = 0; i < MAX_STREAMS; i++) m_streams[i] = NULL; }  CDVDDemuxPVRClient::~CDVDDemuxPVRClient() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:1
[]
The real line: +  Dispose();
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  dispose();
Depths: 1:1
[]
The real line: +}
Current Name Search:   Dispose(); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search:   Dispose(); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +bool CDVDDemuxPVRClient::Open(CDVDInputStream* pInput)
Current Name Search:   Dispose(); }  
LINE TO PARSE FOR KEYWORD:bool cdvddemuxpvrclient::open(cdvdinputstream* pinput)
Depths: 0:0
[]
The real line: +{
Current Name Search:   Dispose(); }  bool CDVDDemuxPVRClient::Open(CDVDInputStream* pInput) 
Checking if function:   Dispose(); }  bool CDVDDemuxPVRClient::Open(CDVDInputStream* pInput) {
PATTERN 1
Function:  bool CDVDDemuxPVRClient::Open(CDVDInputStream* pInput) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  Abort();
End Check: 1
LINE TO PARSE FOR KEYWORD:  abort();
The real line: +  m_pInput = pInput;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_pinput = pinput;
The real line: +  if (!g_PVRClients->GetPlayingClient(m_pvrClient))
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!g_pvrclients->getplayingclient(m_pvrclient))
The real line: +    return false;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return false;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  RequestStreams();
End Check: 1
LINE TO PARSE FOR KEYWORD:  requeststreams();
The real line: +  return true;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return true;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
86 : 94
Next: (CDVDInputStream* pInput)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::Dispose()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::dispose()
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::Dispose() 
Checking if function:  void CDVDDemuxPVRClient::Dispose() {
PATTERN 4
Function: void CDVDDemuxPVRClient::Dispose() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  for (int i = 0; i < MAX_STREAMS; i++)
End Check: 1
LINE TO PARSE FOR KEYWORD:  for (int i = 0; i < max_streams; i++)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (m_streams[i])
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (m_streams[i])
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      if (m_streams[i]->ExtraData)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (m_streams[i]->extradata)
The real line: +        delete[] (BYTE*)(m_streams[i]->ExtraData);
End Check: 3
LINE TO PARSE FOR KEYWORD:        delete[] (byte*)(m_streams[i]->extradata);
The real line: +      delete m_streams[i];
End Check: 3
LINE TO PARSE FOR KEYWORD:      delete m_streams[i];
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    m_streams[i] = NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[i] = null;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  m_pInput = NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_pinput = null;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
97 : 109
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::Reset()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::reset()
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::Reset() 
Checking if function:  void CDVDDemuxPVRClient::Reset() {
PATTERN 4
Function: void CDVDDemuxPVRClient::Reset() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if(m_pInput && g_PVRManager.IsStarted())
End Check: 1
LINE TO PARSE FOR KEYWORD:  if(m_pinput && g_pvrmanager.isstarted())
The real line: +    m_pvrClient->DemuxReset();
End Check: 1
LINE TO PARSE FOR KEYWORD:    m_pvrclient->demuxreset();
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  CDVDInputStream* pInputStream = m_pInput;
End Check: 1
LINE TO PARSE FOR KEYWORD:  cdvdinputstream* pinputstream = m_pinput;
The real line: +  Dispose();
End Check: 1
LINE TO PARSE FOR KEYWORD:  dispose();
The real line: +  Open(pInputStream);
End Check: 1
LINE TO PARSE FOR KEYWORD:  open(pinputstream);
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
112 : 119
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::Abort()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::abort()
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::Abort() 
Checking if function:  void CDVDDemuxPVRClient::Abort() {
PATTERN 4
Function: void CDVDDemuxPVRClient::Abort() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if(m_pInput)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if(m_pinput)
The real line: +    m_pvrClient->DemuxAbort();
End Check: 1
LINE TO PARSE FOR KEYWORD:    m_pvrclient->demuxabort();
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
122 : 125
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::Flush()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::flush()
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::Flush() 
Checking if function:  void CDVDDemuxPVRClient::Flush() {
PATTERN 4
Function: void CDVDDemuxPVRClient::Flush() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if(m_pInput && g_PVRManager.IsStarted())
End Check: 1
LINE TO PARSE FOR KEYWORD:  if(m_pinput && g_pvrmanager.isstarted())
The real line: +    m_pvrClient->DemuxFlush();
End Check: 1
LINE TO PARSE FOR KEYWORD:    m_pvrclient->demuxflush();
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
128 : 131
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +DemuxPacket* CDVDDemuxPVRClient::Read()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:demuxpacket* cdvddemuxpvrclient::read()
Depths: 0:0
[]
The real line: +{
Current Name Search:  DemuxPacket* CDVDDemuxPVRClient::Read() 
Checking if function:  DemuxPacket* CDVDDemuxPVRClient::Read() {
PATTERN 4
Function: DemuxPacket* CDVDDemuxPVRClient::Read() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if (!g_PVRManager.IsStarted())
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!g_pvrmanager.isstarted())
The real line: +    return CDVDDemuxUtils::AllocateDemuxPacket(0);
End Check: 1
LINE TO PARSE FOR KEYWORD:    return cdvddemuxutils::allocatedemuxpacket(0);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  DemuxPacket* pPacket = m_pvrClient->DemuxRead();
End Check: 1
LINE TO PARSE FOR KEYWORD:  demuxpacket* ppacket = m_pvrclient->demuxread();
The real line: +  if (!pPacket)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!ppacket)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (m_pInput)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (m_pinput)
The real line: +      m_pInput->Close();
End Check: 2
LINE TO PARSE FOR KEYWORD:      m_pinput->close();
The real line: +    return NULL;
End Check: 2
LINE TO PARSE FOR KEYWORD:    return null;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  if (pPacket->iStreamId == DMX_SPECIALID_STREAMINFO)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (ppacket->istreamid == dmx_specialid_streaminfo)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    UpdateStreams((PVR_STREAM_PROPERTIES*)pPacket->pData);
End Check: 2
LINE TO PARSE FOR KEYWORD:    updatestreams((pvr_stream_properties*)ppacket->pdata);
The real line: +    CDVDDemuxUtils::FreeDemuxPacket(pPacket);
End Check: 2
LINE TO PARSE FOR KEYWORD:    cdvddemuxutils::freedemuxpacket(ppacket);
The real line: +    return CDVDDemuxUtils::AllocateDemuxPacket(0);
End Check: 2
LINE TO PARSE FOR KEYWORD:    return cdvddemuxutils::allocatedemuxpacket(0);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +  else if (pPacket->iStreamId == DMX_SPECIALID_STREAMCHANGE)
End Check: 1
LINE TO PARSE FOR KEYWORD:  else if (ppacket->istreamid == dmx_specialid_streamchange)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    Reset();
End Check: 2
LINE TO PARSE FOR KEYWORD:    reset();
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  return pPacket;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return ppacket;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
134 : 158
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +CDemuxStream* CDVDDemuxPVRClient::GetStream(int iStreamId)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:cdemuxstream* cdvddemuxpvrclient::getstream(int istreamid)
Depths: 0:0
[]
The real line: +{
Current Name Search:  CDemuxStream* CDVDDemuxPVRClient::GetStream(int iStreamId) 
Checking if function:  CDemuxStream* CDVDDemuxPVRClient::GetStream(int iStreamId) {
PATTERN 4
Function: CDemuxStream* CDVDDemuxPVRClient::GetStream(int iStreamId) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if (iStreamId < 0 || iStreamId >= MAX_STREAMS) return NULL;
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (istreamid < 0 || istreamid >= max_streams) return null;
The real line: +    return m_streams[iStreamId];
End Check: 1
LINE TO PARSE FOR KEYWORD:    return m_streams[istreamid];
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
161 : 164
Next: (int iStreamId)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::RequestStreams()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::requeststreams()
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::RequestStreams() 
Checking if function:  void CDVDDemuxPVRClient::RequestStreams() {
PATTERN 4
Function: void CDVDDemuxPVRClient::RequestStreams() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if (!g_PVRManager.IsStarted())
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (!g_pvrmanager.isstarted())
The real line: +    return;
End Check: 1
LINE TO PARSE FOR KEYWORD:    return;
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  PVR_STREAM_PROPERTIES props;
End Check: 1
LINE TO PARSE FOR KEYWORD:  pvr_stream_properties props;
The real line: +  m_pvrClient->GetStreamProperties(&props);
End Check: 1
LINE TO PARSE FOR KEYWORD:  m_pvrclient->getstreamproperties(&props);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  for (unsigned int i = 0; i < props.iStreamCount; ++i)
End Check: 1
LINE TO PARSE FOR KEYWORD:  for (unsigned int i = 0; i < props.istreamcount; ++i)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (props.stream[i].iCodecType == AVMEDIA_TYPE_AUDIO)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (props.stream[i].icodectype == avmedia_type_audio)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      CDemuxStreamAudioPVRClient* st = new CDemuxStreamAudioPVRClient(this);
End Check: 3
LINE TO PARSE FOR KEYWORD:      cdemuxstreamaudiopvrclient* st = new cdemuxstreamaudiopvrclient(this);
The real line: +      st->iChannels       = props.stream[i].iChannels;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ichannels       = props.stream[i].ichannels;
The real line: +      st->iSampleRate     = props.stream[i].iSampleRate;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->isamplerate     = props.stream[i].isamplerate;
The real line: +      st->iBlockAlign     = props.stream[i].iBlockAlign;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->iblockalign     = props.stream[i].iblockalign;
The real line: +      st->iBitRate        = props.stream[i].iBitRate;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ibitrate        = props.stream[i].ibitrate;
The real line: +      st->iBitsPerSample  = props.stream[i].iBitsPerSample;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ibitspersample  = props.stream[i].ibitspersample;
The real line: +      m_streams[props.stream[i].iStreamIndex] = st;
End Check: 3
LINE TO PARSE FOR KEYWORD:      m_streams[props.stream[i].istreamindex] = st;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else if (props.stream[i].iCodecType == AVMEDIA_TYPE_VIDEO)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (props.stream[i].icodectype == avmedia_type_video)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      CDemuxStreamVideoPVRClient* st = new CDemuxStreamVideoPVRClient(this);
End Check: 3
LINE TO PARSE FOR KEYWORD:      cdemuxstreamvideopvrclient* st = new cdemuxstreamvideopvrclient(this);
The real line: +      st->iFpsScale       = props.stream[i].iFPSScale;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ifpsscale       = props.stream[i].ifpsscale;
The real line: +      st->iFpsRate        = props.stream[i].iFPSRate;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ifpsrate        = props.stream[i].ifpsrate;
The real line: +      st->iHeight         = props.stream[i].iHeight;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->iheight         = props.stream[i].iheight;
The real line: +      st->iWidth          = props.stream[i].iWidth;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->iwidth          = props.stream[i].iwidth;
The real line: +      st->fAspect         = props.stream[i].fAspect;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->faspect         = props.stream[i].faspect;
The real line: +      m_streams[props.stream[i].iStreamIndex] = st;
End Check: 3
LINE TO PARSE FOR KEYWORD:      m_streams[props.stream[i].istreamindex] = st;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else if (props.stream[i].iCodecId == CODEC_ID_DVB_TELETEXT)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (props.stream[i].icodecid == codec_id_dvb_teletext)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      m_streams[props.stream[i].iStreamIndex] = new CDemuxStreamTeletext();
End Check: 3
LINE TO PARSE FOR KEYWORD:      m_streams[props.stream[i].istreamindex] = new cdemuxstreamteletext();
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else if (props.stream[i].iCodecType == AVMEDIA_TYPE_SUBTITLE)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (props.stream[i].icodectype == avmedia_type_subtitle)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      CDemuxStreamSubtitlePVRClient* st = new CDemuxStreamSubtitlePVRClient(this);
End Check: 3
LINE TO PARSE FOR KEYWORD:      cdemuxstreamsubtitlepvrclient* st = new cdemuxstreamsubtitlepvrclient(this);
The real line: +      st->identifier      = props.stream[i].iIdentifier;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->identifier      = props.stream[i].iidentifier;
The real line: +      m_streams[props.stream[i].iStreamIndex] = st;
End Check: 3
LINE TO PARSE FOR KEYWORD:      m_streams[props.stream[i].istreamindex] = st;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else
End Check: 2
LINE TO PARSE FOR KEYWORD:    else
The real line: +      m_streams[props.stream[i].iStreamIndex] = new CDemuxStream();
End Check: 2
LINE TO PARSE FOR KEYWORD:      m_streams[props.stream[i].istreamindex] = new cdemuxstream();
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    m_streams[props.stream[i].iStreamIndex]->codec       = (CodecID)props.stream[i].iCodecId;
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->codec       = (codecid)props.stream[i].icodecid;
The real line: +    m_streams[props.stream[i].iStreamIndex]->iId         = props.stream[i].iStreamIndex;
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->iid         = props.stream[i].istreamindex;
The real line: +    m_streams[props.stream[i].iStreamIndex]->iPhysicalId = props.stream[i].iPhysicalId;
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->iphysicalid = props.stream[i].iphysicalid;
The real line: +    m_streams[props.stream[i].iStreamIndex]->language[0] = props.stream[i].strLanguage[0];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->language[0] = props.stream[i].strlanguage[0];
The real line: +    m_streams[props.stream[i].iStreamIndex]->language[1] = props.stream[i].strLanguage[1];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->language[1] = props.stream[i].strlanguage[1];
The real line: +    m_streams[props.stream[i].iStreamIndex]->language[2] = props.stream[i].strLanguage[2];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->language[2] = props.stream[i].strlanguage[2];
The real line: +    m_streams[props.stream[i].iStreamIndex]->language[3] = props.stream[i].strLanguage[3];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props.stream[i].istreamindex]->language[3] = props.stream[i].strlanguage[3];
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    CLog::Log(LOGDEBUG,"CDVDDemuxPVRClient::RequestStreams(): added stream %d:%d with codec_id %d",
End Check: 2
LINE TO PARSE FOR KEYWORD:    clog::log(logdebug,,
The real line: +        m_streams[props.stream[i].iStreamIndex]->iId,
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props.stream[i].istreamindex]->iid,
The real line: +        m_streams[props.stream[i].iStreamIndex]->iPhysicalId,
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props.stream[i].istreamindex]->iphysicalid,
The real line: +        m_streams[props.stream[i].iStreamIndex]->codec);
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props.stream[i].istreamindex]->codec);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
167 : 222
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::UpdateStreams(PVR_STREAM_PROPERTIES *props)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::updatestreams(pvr_stream_properties *props)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::UpdateStreams(PVR_STREAM_PROPERTIES *props) 
Checking if function:  void CDVDDemuxPVRClient::UpdateStreams(PVR_STREAM_PROPERTIES *props) {
PATTERN 4
Function: void CDVDDemuxPVRClient::UpdateStreams(PVR_STREAM_PROPERTIES *props) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  bool bGotVideoStream(false);
End Check: 1
LINE TO PARSE FOR KEYWORD:  bool bgotvideostream(false);
The real line: +
End Check: 1
LINE TO PARSE FOR KEYWORD:
The real line: +  for (unsigned int i = 0; i < props->iStreamCount; ++i)
End Check: 1
LINE TO PARSE FOR KEYWORD:  for (unsigned int i = 0; i < props->istreamcount; ++i)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (m_streams[props->stream[i].iStreamIndex] == NULL ||
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (m_streams[props->stream[i].istreamindex] == null ||
The real line: +        m_streams[props->stream[i].iStreamIndex]->codec != (CodecID)props->stream[i].iCodecId)
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props->stream[i].istreamindex]->codec != (codecid)props->stream[i].icodecid)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      CLog::Log(LOGERROR,"Invalid stream inside UpdateStreams");
End Check: 3
LINE TO PARSE FOR KEYWORD:      clog::log(logerror,);
The real line: +      continue;
End Check: 3
LINE TO PARSE FOR KEYWORD:      continue;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    if (m_streams[props->stream[i].iStreamIndex]->type == STREAM_AUDIO)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (m_streams[props->stream[i].istreamindex]->type == stream_audio)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      CDemuxStreamAudioPVRClient* st = (CDemuxStreamAudioPVRClient*) m_streams[props->stream[i].iStreamIndex];
End Check: 3
LINE TO PARSE FOR KEYWORD:      cdemuxstreamaudiopvrclient* st = (cdemuxstreamaudiopvrclient*) m_streams[props->stream[i].istreamindex];
The real line: +      st->iChannels       = props->stream[i].iChannels;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ichannels       = props->stream[i].ichannels;
The real line: +      st->iSampleRate     = props->stream[i].iSampleRate;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->isamplerate     = props->stream[i].isamplerate;
The real line: +      st->iBlockAlign     = props->stream[i].iBlockAlign;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->iblockalign     = props->stream[i].iblockalign;
The real line: +      st->iBitRate        = props->stream[i].iBitRate;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ibitrate        = props->stream[i].ibitrate;
The real line: +      st->iBitsPerSample  = props->stream[i].iBitsPerSample;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ibitspersample  = props->stream[i].ibitspersample;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else if (m_streams[props->stream[i].iStreamIndex]->type == STREAM_VIDEO)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (m_streams[props->stream[i].istreamindex]->type == stream_video)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      if (bGotVideoStream)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (bgotvideostream)
The real line: +      {
End Check: 4
LINE TO PARSE FOR KEYWORD:      {
The real line: +        CLog::Log(LOGDEBUG, "CDVDDemuxPVRClient - %s - skip video stream", __FUNCTION__);
End Check: 4
LINE TO PARSE FOR KEYWORD:        clog::log(logdebug, , __function__);
The real line: +        continue;
End Check: 4
LINE TO PARSE FOR KEYWORD:        continue;
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      CDemuxStreamVideoPVRClient* st = (CDemuxStreamVideoPVRClient*) m_streams[props->stream[i].iStreamIndex];
End Check: 3
LINE TO PARSE FOR KEYWORD:      cdemuxstreamvideopvrclient* st = (cdemuxstreamvideopvrclient*) m_streams[props->stream[i].istreamindex];
The real line: +      if (st->iWidth <= 0 || st->iHeight <= 0)
End Check: 3
LINE TO PARSE FOR KEYWORD:      if (st->iwidth <= 0 || st->iheight <= 0)
The real line: +      {
End Check: 4
LINE TO PARSE FOR KEYWORD:      {
The real line: +        CLog::Log(LOGWARNING, "CDVDDemuxPVRClient - %s - invalid stream data", __FUNCTION__);
End Check: 4
LINE TO PARSE FOR KEYWORD:        clog::log(logwarning, , __function__);
The real line: +        continue;
End Check: 4
LINE TO PARSE FOR KEYWORD:        continue;
The real line: +      }
End Check: 3
LINE TO PARSE FOR KEYWORD:      }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +      st->iFpsScale       = props->stream[i].iFPSScale;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ifpsscale       = props->stream[i].ifpsscale;
The real line: +      st->iFpsRate        = props->stream[i].iFPSRate;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->ifpsrate        = props->stream[i].ifpsrate;
The real line: +      st->iHeight         = props->stream[i].iHeight;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->iheight         = props->stream[i].iheight;
The real line: +      st->iWidth          = props->stream[i].iWidth;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->iwidth          = props->stream[i].iwidth;
The real line: +      st->fAspect         = props->stream[i].fAspect;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->faspect         = props->stream[i].faspect;
The real line: +      bGotVideoStream = true;
End Check: 3
LINE TO PARSE FOR KEYWORD:      bgotvideostream = true;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +    else if (m_streams[props->stream[i].iStreamIndex]->type == STREAM_SUBTITLE)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (m_streams[props->stream[i].istreamindex]->type == stream_subtitle)
The real line: +    {
End Check: 3
LINE TO PARSE FOR KEYWORD:    {
The real line: +      CDemuxStreamSubtitlePVRClient* st = (CDemuxStreamSubtitlePVRClient*) m_streams[props->stream[i].iStreamIndex];
End Check: 3
LINE TO PARSE FOR KEYWORD:      cdemuxstreamsubtitlepvrclient* st = (cdemuxstreamsubtitlepvrclient*) m_streams[props->stream[i].istreamindex];
The real line: +      st->identifier      = props->stream[i].iIdentifier;
End Check: 3
LINE TO PARSE FOR KEYWORD:      st->identifier      = props->stream[i].iidentifier;
The real line: +    }
End Check: 2
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    m_streams[props->stream[i].iStreamIndex]->language[0] = props->stream[i].strLanguage[0];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props->stream[i].istreamindex]->language[0] = props->stream[i].strlanguage[0];
The real line: +    m_streams[props->stream[i].iStreamIndex]->language[1] = props->stream[i].strLanguage[1];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props->stream[i].istreamindex]->language[1] = props->stream[i].strlanguage[1];
The real line: +    m_streams[props->stream[i].iStreamIndex]->language[2] = props->stream[i].strLanguage[2];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props->stream[i].istreamindex]->language[2] = props->stream[i].strlanguage[2];
The real line: +    m_streams[props->stream[i].iStreamIndex]->language[3] = props->stream[i].strLanguage[3];
End Check: 2
LINE TO PARSE FOR KEYWORD:    m_streams[props->stream[i].istreamindex]->language[3] = props->stream[i].strlanguage[3];
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +    CLog::Log(LOGDEBUG,"CDVDDemuxPVRClient::UpdateStreams(): update stream %d:%d with codec_id %d",
End Check: 2
LINE TO PARSE FOR KEYWORD:    clog::log(logdebug,,
The real line: +        m_streams[props->stream[i].iStreamIndex]->iId,
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props->stream[i].istreamindex]->iid,
The real line: +        m_streams[props->stream[i].iStreamIndex]->iPhysicalId,
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props->stream[i].istreamindex]->iphysicalid,
The real line: +        m_streams[props->stream[i].iStreamIndex]->codec);
End Check: 2
LINE TO PARSE FOR KEYWORD:        m_streams[props->stream[i].istreamindex]->codec);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
225 : 284
Next: (PVR_STREAM_PROPERTIES *props)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +int CDVDDemuxPVRClient::GetNrOfStreams()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:int cdvddemuxpvrclient::getnrofstreams()
Depths: 0:0
[]
The real line: +{
Current Name Search:  int CDVDDemuxPVRClient::GetNrOfStreams() 
Checking if function:  int CDVDDemuxPVRClient::GetNrOfStreams() {
PATTERN 4
Function: int CDVDDemuxPVRClient::GetNrOfStreams() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  int i = 0;
End Check: 1
LINE TO PARSE FOR KEYWORD:  int i = 0;
The real line: +  while (i < MAX_STREAMS && m_streams[i]) i++;
End Check: 1
LINE TO PARSE FOR KEYWORD:  while (i < max_streams && m_streams[i]) i++;
The real line: +  return i;
End Check: 1
LINE TO PARSE FOR KEYWORD:  return i;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
287 : 291
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +std::string CDVDDemuxPVRClient::GetFileName()
Current Name Search:  
LINE TO PARSE FOR KEYWORD:std::string cdvddemuxpvrclient::getfilename()
Depths: 0:0
[]
The real line: +{
Current Name Search:  std::string CDVDDemuxPVRClient::GetFileName() 
Checking if function:  std::string CDVDDemuxPVRClient::GetFileName() {
PATTERN 4
Function: std::string CDVDDemuxPVRClient::GetFileName() {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  if(m_pInput)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if(m_pinput)
The real line: +    return m_pInput->GetFileName();
End Check: 1
LINE TO PARSE FOR KEYWORD:    return m_pinput->getfilename();
The real line: +  else
End Check: 1
LINE TO PARSE FOR KEYWORD:  else
The real line: +    return "";
End Check: 1
LINE TO PARSE FOR KEYWORD:    return ;
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
294 : 299
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +void CDVDDemuxPVRClient::GetStreamCodecName(int iStreamId, CStdString &strName)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cdvddemuxpvrclient::getstreamcodecname(int istreamid, cstdstring &strname)
Depths: 0:0
[]
The real line: +{
Current Name Search:  void CDVDDemuxPVRClient::GetStreamCodecName(int iStreamId, CStdString &strName) 
Checking if function:  void CDVDDemuxPVRClient::GetStreamCodecName(int iStreamId, CStdString &strName) {
PATTERN 4
Function: void CDVDDemuxPVRClient::GetStreamCodecName(int iStreamId, CStdString &strName) {
LINE TO PARSE FOR KEYWORD:{
Depths: 1:0
[]
The real line: +  CDemuxStream *stream = GetStream(iStreamId);
End Check: 1
LINE TO PARSE FOR KEYWORD:.  cdemuxstream *stream = getstream(istreamid);
The real line: +  if (stream)
End Check: 1
LINE TO PARSE FOR KEYWORD:  if (stream)
The real line: +  {
End Check: 2
LINE TO PARSE FOR KEYWORD:  {
The real line: +    if (stream->codec == CODEC_ID_AC3)
End Check: 2
LINE TO PARSE FOR KEYWORD:    if (stream->codec == codec_id_ac3)
The real line: +      strName = "ac3";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +    else if (stream->codec == CODEC_ID_MP2)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (stream->codec == codec_id_mp2)
The real line: +      strName = "mp2";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +    else if (stream->codec == CODEC_ID_AAC)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (stream->codec == codec_id_aac)
The real line: +      strName = "aac";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +    else if (stream->codec == CODEC_ID_DTS)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (stream->codec == codec_id_dts)
The real line: +      strName = "dca";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +    else if (stream->codec == CODEC_ID_MPEG2VIDEO)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (stream->codec == codec_id_mpeg2video)
The real line: +      strName = "mpeg2video";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +    else if (stream->codec == CODEC_ID_H264)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (stream->codec == codec_id_h264)
The real line: +      strName = "h264";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +    else if (stream->codec == CODEC_ID_EAC3)
End Check: 2
LINE TO PARSE FOR KEYWORD:    else if (stream->codec == codec_id_eac3)
The real line: +      strName = "eac3";
End Check: 2
LINE TO PARSE FOR KEYWORD:      strname = ;
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
The real line: +}
End Check: 0
LINE TO PARSE FOR KEYWORD:}
302 : 321
Next: (int iStreamId, CStdString &strName)
Chunk End.
The real line: +// Copyright (c) 2009, Google Inc.
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// All rights reserved.
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//
Current Name Search:   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// Redistribution and use in source and binary forms, with or without
Current Name Search:    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// modification, are permitted provided that the following conditions are
Current Name Search:     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// met:
Current Name Search:      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//
Current Name Search:       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//     * Redistributions of source code must retain the above copyright
Current Name Search:        
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// notice, this list of conditions and the following disclaimer.
Current Name Search:         
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//     * Redistributions in binary form must reproduce the above
Current Name Search:          
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// copyright notice, this list of conditions and the following disclaimer
Current Name Search:           
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// in the documentation and/or other materials provided with the
Current Name Search:            
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// distribution.
Current Name Search:             
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//     * Neither the name of Google Inc. nor the names of its
Current Name Search:              
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// contributors may be used to endorse or promote products derived from
Current Name Search:               
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// this software without specific prior written permission.
Current Name Search:                
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//
Current Name Search:                 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
Current Name Search:                  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
Current Name Search:                   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
Current Name Search:                    
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
Current Name Search:                     
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
Current Name Search:                      
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
Current Name Search:                       
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
Current Name Search:                        
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
Current Name Search:                         
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
Current Name Search:                          
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
Current Name Search:                           
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Current Name Search:                            
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:                             
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// linux_ptrace_dumper_unittest.cc:
Current Name Search:                              
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// Unit tests for google_breakpad::LinuxPtraceDumoer.
Current Name Search:                               
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +//
Current Name Search:                                
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// This file was renamed from linux_dumper_unittest.cc and modified due
Current Name Search:                                 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// to LinuxDumper being splitted into two classes.
Current Name Search:                                  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +
Current Name Search:                                   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include <fcntl.h>
Current Name Search:                                    
LINE TO PARSE FOR KEYWORD:#include <fcntl.h>
Depths: 0:0
[]
The real line: +#include <limits.h>
Current Name Search:                                    #include <fcntl.h> 
LINE TO PARSE FOR KEYWORD:#include <limits.h>
Depths: 0:0
[]
The real line: +#include <unistd.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> 
LINE TO PARSE FOR KEYWORD:#include <unistd.h>
Depths: 0:0
[]
The real line: +#include <signal.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> 
LINE TO PARSE FOR KEYWORD:#include <signal.h>
Depths: 0:0
[]
The real line: +#include <stdint.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> 
LINE TO PARSE FOR KEYWORD:#include <stdint.h>
Depths: 0:0
[]
The real line: +#include <sys/mman.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> 
LINE TO PARSE FOR KEYWORD:#include <sys/mman.h>
Depths: 0:0
[]
The real line: +#include <sys/poll.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> 
LINE TO PARSE FOR KEYWORD:#include <sys/poll.h>
Depths: 0:0
[]
The real line: +#include <sys/stat.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> 
LINE TO PARSE FOR KEYWORD:#include <sys/stat.h>
Depths: 0:0
[]
The real line: +#include <sys/types.h>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> 
LINE TO PARSE FOR KEYWORD:#include <sys/types.h>
Depths: 0:0
[]
The real line: +
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include <string>
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  
LINE TO PARSE FOR KEYWORD:#include <string>
Depths: 0:0
[]
The real line: +
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "breakpad_googletest_includes.h"
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "client/linux/minidump_writer/linux_ptrace_dumper.h"
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "common/linux/eintr_wrapper.h"
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "common/linux/file_id.h"
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "common/linux/safe_readlink.h"
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "common/memory.h"
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +using std::string;
Current Name Search:                                    #include <fcntl.h> #include <limits.h> #include <unistd.h> #include <signal.h> #include <stdint.h> #include <sys/mman.h> #include <sys/poll.h> #include <sys/stat.h> #include <sys/types.h>  #include <string>  #include  #include  #include  #include  #include  #include   
LINE TO PARSE FOR KEYWORD:using std::string;
Depths: 0:0
[]
The real line: +using namespace google_breakpad;
Current Name Search: using std::string; 
LINE TO PARSE FOR KEYWORD:using namespace google_breakpad;
Depths: 0:0
[]
The real line: +
Current Name Search: using namespace google_breakpad; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +namespace {
Current Name Search: using namespace google_breakpad;  
Checking if function: using namespace google_breakpad;  namespace {
Namespace:using namespace google_breakpad;  namespace {
LINE TO PARSE FOR KEYWORD:namespace {
Depths: 1:1
[]
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +typedef testing::Test LinuxPtraceDumperTest;
Current Name Search:  
LINE TO PARSE FOR KEYWORD:typedef testing::test linuxptracedumpertest;
Depths: 1:1
[]
The real line: +
Current Name Search: typedef testing::Test LinuxPtraceDumperTest; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +string GetHelperBinary() {
Current Name Search: typedef testing::Test LinuxPtraceDumperTest;  
Checking if function: typedef testing::Test LinuxPtraceDumperTest;  string GetHelperBinary() {
PATTERN 1
Function:  string GetHelperBinary() {
LINE TO PARSE FOR KEYWORD:string gethelperbinary() {
Depths: 2:1
[]
The real line: +  // Locate helper binary next to the current binary.
End Check: 2
LINE TO PARSE FOR KEYWORD:  
The real line: +  char self_path[PATH_MAX];
End Check: 2
LINE TO PARSE FOR KEYWORD:  char self_path[path_max];
The real line: +  if (!SafeReadLink("/proc/self/exe", self_path)) {
End Check: 3
LINE TO PARSE FOR KEYWORD:  if (!safereadlink(, self_path)) {
The real line: +    return "";
End Check: 3
LINE TO PARSE FOR KEYWORD:    return ;
The real line: +  }
End Check: 2
LINE TO PARSE FOR KEYWORD:  }
The real line: +  string helper_path(self_path);
End Check: 2
LINE TO PARSE FOR KEYWORD:  string helper_path(self_path);
The real line: +  size_t pos = helper_path.rfind('/');
End Check: 2
LINE TO PARSE FOR KEYWORD:  size_t pos = helper_path.rfind();
The real line: +  if (pos == string::npos) {
End Check: 3
LINE TO PARSE FOR KEYWORD:  if (pos == string::npos) {
The real line: +    return "";
End Check: 3
LINE TO PARSE FOR KEYWORD:    return ;
The real line: +  }
End Check: 2
LINE TO PARSE FOR KEYWORD:  }
The real line: +  helper_path.erase(pos + 1);
End Check: 2
LINE TO PARSE FOR KEYWORD:  helper_path.erase(pos + 1);
The real line: +  helper_path += "linux_dumper_unittest_helper";
End Check: 2
LINE TO PARSE FOR KEYWORD:  helper_path += ;
The real line: +
End Check: 2
LINE TO PARSE FOR KEYWORD:
The real line: +  return helper_path;
End Check: 2
LINE TO PARSE FOR KEYWORD:  return helper_path;
The real line: +}
End Check: 1
LINE TO PARSE FOR KEYWORD:}
62 : 77
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +}  // namespace
Current Name Search:  
LINE TO PARSE FOR KEYWORD:}  
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search:  }   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +TEST(LinuxPtraceDumperTest, Setup) {
Current Name Search:  }    
Checking if function:  }    TEST(LinuxPtraceDumperTest, Setup) {
Other type of bracket:  }    TEST(LinuxPtraceDumperTest, Setup) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, setup) {
Depths: 1:1
[]
The real line: +  LinuxPtraceDumper dumper(getpid());
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(getpid());
Depths: 1:1
[]
The real line: +}
Current Name Search:   LinuxPtraceDumper dumper(getpid()); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search:   LinuxPtraceDumper dumper(getpid()); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +TEST(LinuxPtraceDumperTest, FindMappings) {
Current Name Search:   LinuxPtraceDumper dumper(getpid()); }  
Checking if function:   LinuxPtraceDumper dumper(getpid()); }  TEST(LinuxPtraceDumperTest, FindMappings) {
Other type of bracket:   LinuxPtraceDumper dumper(getpid()); }  TEST(LinuxPtraceDumperTest, FindMappings) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, findmappings) {
Depths: 1:1
[]
The real line: +  LinuxPtraceDumper dumper(getpid());
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(getpid());
Depths: 1:1
[]
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(getpid()); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
[]
The real line: +
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +  ASSERT_TRUE(dumper.FindMapping(reinterpret_cast<void*>(getpid)));
Current Name Search:   ASSERT_TRUE(dumper.Init());  
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.findmapping(reinterpret_cast<void*>(getpid)));
Depths: 1:1
[]
The real line: +  ASSERT_TRUE(dumper.FindMapping(reinterpret_cast<void*>(printf)));
Current Name Search:   ASSERT_TRUE(dumper.FindMapping(reinterpret_cast<void*>(getpid))); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.findmapping(reinterpret_cast<void*>(printf)));
Depths: 1:1
[]
The real line: +  ASSERT_FALSE(dumper.FindMapping(NULL));
Current Name Search:   ASSERT_TRUE(dumper.FindMapping(reinterpret_cast<void*>(printf))); 
LINE TO PARSE FOR KEYWORD:  assert_false(dumper.findmapping(null));
Depths: 1:1
[]
The real line: +}
Current Name Search:   ASSERT_FALSE(dumper.FindMapping(NULL)); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search:   ASSERT_FALSE(dumper.FindMapping(NULL)); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +TEST(LinuxPtraceDumperTest, ThreadList) {
Current Name Search:   ASSERT_FALSE(dumper.FindMapping(NULL)); }  
Checking if function:   ASSERT_FALSE(dumper.FindMapping(NULL)); }  TEST(LinuxPtraceDumperTest, ThreadList) {
Other type of bracket:   ASSERT_FALSE(dumper.FindMapping(NULL)); }  TEST(LinuxPtraceDumperTest, ThreadList) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, threadlist) {
Depths: 1:1
[]
The real line: +  LinuxPtraceDumper dumper(getpid());
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(getpid());
Depths: 1:1
[]
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(getpid()); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
[]
The real line: +
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
[]
The real line: +  ASSERT_GE(dumper.threads().size(), (size_t)1);
Current Name Search:   ASSERT_TRUE(dumper.Init());  
LINE TO PARSE FOR KEYWORD:  assert_ge(dumper.threads().size(), (size_t)1);
Depths: 1:1
[]
The real line: +  bool found = false;
Current Name Search:   ASSERT_GE(dumper.threads().size(), (size_t)1); 
LINE TO PARSE FOR KEYWORD:  bool found = false;
Depths: 1:1
[]
The real line: +  for (size_t i = 0; i < dumper.threads().size(); ++i) {
Current Name Search:   bool found = false; 
Checking if function:   bool found = false;   for (size_t i = 0; i < dumper.threads().size(); ++i) {
Other type of bracket:   bool found = false;   for (size_t i = 0; i < dumper.threads().size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (size_t i = 0; i < dumper.threads().size(); ++i) {
Depths: 2:2
[]
The real line: +    if (dumper.threads()[i] == getpid()) {
Current Name Search: 
Checking if function:     if (dumper.threads()[i] == getpid()) {
Other type of bracket:     if (dumper.threads()[i] == getpid()) {
LINE TO PARSE FOR KEYWORD:    if (dumper.threads()[i] == getpid()) {
Depths: 3:3
[]
The real line: +      found = true;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      found = true;
Depths: 3:3
[]
The real line: +      break;
Current Name Search:       found = true; 
LINE TO PARSE FOR KEYWORD:      break;
Depths: 3:3
[]
The real line: +    }
Current Name Search:       break; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
[]
Adjusting depth.
The real line: +  }
Current Name Search:       break;     } 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
[]
Adjusting depth.
The real line: +}
Current Name Search:       break;     }   } 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
[]
Adjusting depth.
The real line: +
Current Name Search:       break;     }   } } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// Helper stack class to close a file descriptor and unmap
Current Name Search:       break;     }   } }  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +// a mmap'ed mapping.
Current Name Search:       break;     }   } }   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +class StackHelper {
Current Name Search:       break;     }   } }    
Checking if function:       break;     }   } }    class StackHelper {
Class: class stackhelper {
LINE TO PARSE FOR KEYWORD:class stackhelper {
Depths: 1:1
['stackhelper']
The real line: + public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD: public:
Depths: 1:1
['stackhelper']
The real line: +  StackHelper(int fd, char* mapping, size_t size)
Current Name Search:  public: 
LINE TO PARSE FOR KEYWORD:  stackhelper(int fd, char* mapping, size_t size)
Depths: 1:1
['stackhelper']
The real line: +    : fd_(fd), mapping_(mapping), size_(size) {}
Current Name Search:  public:   StackHelper(int fd, char* mapping, size_t size) 
Checking if function:  public:   StackHelper(int fd, char* mapping, size_t size)     : fd_(fd), mapping_(mapping), size_(size) {
Class context: stackhelper
Checking if a constructor/destructor:  public:   StackHelper(int fd, char* mapping, size_t size)     : fd_(fd), mapping_(mapping), size_(size) {
Function:  public:   StackHelper(int fd, char* mapping, size_t size)     : fd_(fd), mapping_(mapping), size_(size) {
LINE TO PARSE FOR KEYWORD:    : fd_(fd), mapping_(mapping), size_(size) {}
Next: (int fd, char* mapping, size_t size)
Next: (fd)
Next: (mapping)
Next: (size)
Depths: 1:1
['stackhelper']
The real line: +  ~StackHelper() {
Current Name Search: 
Checking if function:   ~StackHelper() {
Class context: stackhelper
Checking if a constructor/destructor:   ~StackHelper() {
Function:   ~StackHelper() {
LINE TO PARSE FOR KEYWORD:  ~stackhelper() {
Depths: 2:1
['stackhelper']
The real line: +    munmap(mapping_, size_);
End Check: 2
LINE TO PARSE FOR KEYWORD:    munmap(mapping_, size_);
The real line: +    close(fd_);
End Check: 2
LINE TO PARSE FOR KEYWORD:    close(fd_);
The real line: +  }
End Check: 1
LINE TO PARSE FOR KEYWORD:  }
114 : 117
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: + private:
Current Name Search:  
LINE TO PARSE FOR KEYWORD: private:
Depths: 1:1
['stackhelper']
The real line: +  int fd_;
Current Name Search:   private: 
LINE TO PARSE FOR KEYWORD:  int fd_;
Depths: 1:1
['stackhelper']
The real line: +  char* mapping_;
Current Name Search:   int fd_; 
LINE TO PARSE FOR KEYWORD:  char* mapping_;
Depths: 1:1
['stackhelper']
The real line: +  size_t size_;
Current Name Search:   char* mapping_; 
LINE TO PARSE FOR KEYWORD:  size_t size_;
Depths: 1:1
['stackhelper']
The real line: +};
Current Name Search:   size_t size_; 
LINE TO PARSE FOR KEYWORD:};
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, MergedMappings) {
Current Name Search: };  
Checking if function: };  TEST(LinuxPtraceDumperTest, MergedMappings) {
Class context: stackhelper
Checking if a constructor/destructor: };  TEST(LinuxPtraceDumperTest, MergedMappings) {
Other type of bracket: };  TEST(LinuxPtraceDumperTest, MergedMappings) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, mergedmappings) {
Depths: 1:1
['stackhelper']
The real line: +  string helper_path(GetHelperBinary());
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  string helper_path(gethelperbinary());
Depths: 1:1
['stackhelper']
The real line: +  if (helper_path.empty()) {
Current Name Search:   string helper_path(GetHelperBinary()); 
Checking if function:   string helper_path(GetHelperBinary());   if (helper_path.empty()) {
Class context: stackhelper
Checking if a constructor/destructor:   string helper_path(GetHelperBinary());   if (helper_path.empty()) {
Other type of bracket:   string helper_path(GetHelperBinary());   if (helper_path.empty()) {
LINE TO PARSE FOR KEYWORD:  if (helper_path.empty()) {
Depths: 2:2
['stackhelper']
The real line: +    FAIL() << "Couldn't find helper binary";
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    fail() << ;
Depths: 2:2
['stackhelper']
The real line: +    exit(1);
Current Name Search:     FAIL() << ; 
LINE TO PARSE FOR KEYWORD:    exit(1);
Depths: 2:2
['stackhelper']
The real line: +  }
Current Name Search:     exit(1); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:     exit(1);   } 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // mmap two segments out of the helper binary, one
Current Name Search:     exit(1);   }  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  // enclosed in the other, but with different protections.
Current Name Search:     exit(1);   }     
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  const size_t kPageSize = sysconf(_SC_PAGESIZE);
Current Name Search:     exit(1);   }        
LINE TO PARSE FOR KEYWORD:  const size_t kpagesize = sysconf(_sc_pagesize);
Depths: 1:1
['stackhelper']
The real line: +  const size_t kMappingSize = 3 * kPageSize;
Current Name Search:   const size_t kPageSize = sysconf(_SC_PAGESIZE); 
LINE TO PARSE FOR KEYWORD:  const size_t kmappingsize = 3 * kpagesize;
Depths: 1:1
['stackhelper']
The real line: +  int fd = open(helper_path.c_str(), O_RDONLY);
Current Name Search:   const size_t kMappingSize = 3 * kPageSize; 
LINE TO PARSE FOR KEYWORD:  int fd = open(helper_path.c_str(), o_rdonly);
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_NE(-1, fd);
Current Name Search:   int fd = open(helper_path.c_str(), O_RDONLY); 
LINE TO PARSE FOR KEYWORD:  assert_ne(-1, fd);
Depths: 1:1
['stackhelper']
The real line: +  char* mapping =
Current Name Search:   ASSERT_NE(-1, fd); 
LINE TO PARSE FOR KEYWORD:  char* mapping =
Depths: 1:1
['stackhelper']
The real line: +    reinterpret_cast<char*>(mmap(NULL,
Current Name Search:   ASSERT_NE(-1, fd);   char* mapping = 
LINE TO PARSE FOR KEYWORD:    reinterpret_cast<char*>(mmap(null,
Depths: 1:1
['stackhelper']
The real line: +                                 kMappingSize,
Current Name Search:   ASSERT_NE(-1, fd);   char* mapping =     reinterpret_cast<char*>(mmap(NULL, 
LINE TO PARSE FOR KEYWORD:                                 kmappingsize,
Depths: 1:1
['stackhelper']
The real line: +                                 PROT_READ,
Current Name Search:   ASSERT_NE(-1, fd);   char* mapping =     reinterpret_cast<char*>(mmap(NULL,                                  kMappingSize, 
LINE TO PARSE FOR KEYWORD:                                 prot_read,
Depths: 1:1
['stackhelper']
The real line: +                                 MAP_SHARED,
Current Name Search:   ASSERT_NE(-1, fd);   char* mapping =     reinterpret_cast<char*>(mmap(NULL,                                  kMappingSize,                                  PROT_READ, 
LINE TO PARSE FOR KEYWORD:                                 map_shared,
Depths: 1:1
['stackhelper']
The real line: +                                 fd,
Current Name Search:   ASSERT_NE(-1, fd);   char* mapping =     reinterpret_cast<char*>(mmap(NULL,                                  kMappingSize,                                  PROT_READ,                                  MAP_SHARED, 
LINE TO PARSE FOR KEYWORD:                                 fd,
Depths: 1:1
['stackhelper']
The real line: +                                 0));
Current Name Search:   ASSERT_NE(-1, fd);   char* mapping =     reinterpret_cast<char*>(mmap(NULL,                                  kMappingSize,                                  PROT_READ,                                  MAP_SHARED,                                  fd, 
LINE TO PARSE FOR KEYWORD:                                 0));
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(mapping);
Current Name Search:                                  0)); 
LINE TO PARSE FOR KEYWORD:  assert_true(mapping);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(mapping); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  const uintptr_t kMappingAddress = reinterpret_cast<uintptr_t>(mapping);
Current Name Search:   ASSERT_TRUE(mapping);  
LINE TO PARSE FOR KEYWORD:  const uintptr_t kmappingaddress = reinterpret_cast<uintptr_t>(mapping);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   const uintptr_t kMappingAddress = reinterpret_cast<uintptr_t>(mapping); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Ensure that things get cleaned up.
Current Name Search:   const uintptr_t kMappingAddress = reinterpret_cast<uintptr_t>(mapping);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  StackHelper helper(fd, mapping, kMappingSize);
Current Name Search:   const uintptr_t kMappingAddress = reinterpret_cast<uintptr_t>(mapping);     
LINE TO PARSE FOR KEYWORD:  stackhelper helper(fd, mapping, kmappingsize);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Carve a page out of the first mapping with different permissions.
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  char* inside_mapping =  reinterpret_cast<char*>(
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);     
LINE TO PARSE FOR KEYWORD:  char* inside_mapping =  reinterpret_cast<char*>(
Depths: 1:1
['stackhelper']
The real line: +      mmap(mapping + 2 *kPageSize,
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>( 
LINE TO PARSE FOR KEYWORD:      mmap(mapping + 2 *kpagesize,
Depths: 1:1
['stackhelper']
The real line: +           kPageSize,
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize, 
LINE TO PARSE FOR KEYWORD:           kpagesize,
Depths: 1:1
['stackhelper']
The real line: +           PROT_NONE,
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize,            kPageSize, 
LINE TO PARSE FOR KEYWORD:           prot_none,
Depths: 1:1
['stackhelper']
The real line: +           MAP_SHARED | MAP_FIXED,
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize,            kPageSize,            PROT_NONE, 
LINE TO PARSE FOR KEYWORD:           map_shared | map_fixed,
Depths: 1:1
['stackhelper']
The real line: +           fd,
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize,            kPageSize,            PROT_NONE,            MAP_SHARED | MAP_FIXED, 
LINE TO PARSE FOR KEYWORD:           fd,
Depths: 1:1
['stackhelper']
The real line: +           // Map a different offset just to
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize,            kPageSize,            PROT_NONE,            MAP_SHARED | MAP_FIXED,            fd, 
LINE TO PARSE FOR KEYWORD:           
Depths: 1:1
['stackhelper']
The real line: +           // better test real-world conditions.
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize,            kPageSize,            PROT_NONE,            MAP_SHARED | MAP_FIXED,            fd,             
LINE TO PARSE FOR KEYWORD:           
Depths: 1:1
['stackhelper']
The real line: +           kPageSize));
Current Name Search:   StackHelper helper(fd, mapping, kMappingSize);       char* inside_mapping =  reinterpret_cast<char*>(       mmap(mapping + 2 *kPageSize,            kPageSize,            PROT_NONE,            MAP_SHARED | MAP_FIXED,            fd,                         
LINE TO PARSE FOR KEYWORD:           kpagesize));
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(inside_mapping);
Current Name Search:            kPageSize)); 
LINE TO PARSE FOR KEYWORD:  assert_true(inside_mapping);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(inside_mapping); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Now check that LinuxPtraceDumper interpreted the mappings properly.
Current Name Search:   ASSERT_TRUE(inside_mapping);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(getpid());
Current Name Search:   ASSERT_TRUE(inside_mapping);     
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(getpid());
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(getpid()); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
['stackhelper']
The real line: +  int mapping_count = 0;
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:  int mapping_count = 0;
Depths: 1:1
['stackhelper']
The real line: +  for (unsigned i = 0; i < dumper.mappings().size(); ++i) {
Current Name Search:   int mapping_count = 0; 
Checking if function:   int mapping_count = 0;   for (unsigned i = 0; i < dumper.mappings().size(); ++i) {
Class context: stackhelper
Checking if a constructor/destructor:   int mapping_count = 0;   for (unsigned i = 0; i < dumper.mappings().size(); ++i) {
Other type of bracket:   int mapping_count = 0;   for (unsigned i = 0; i < dumper.mappings().size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (unsigned i = 0; i < dumper.mappings().size(); ++i) {
Depths: 2:2
['stackhelper']
The real line: +    const MappingInfo& mapping = *dumper.mappings()[i];
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    const mappinginfo& mapping = *dumper.mappings()[i];
Depths: 2:2
['stackhelper']
The real line: +    if (strcmp(mapping.name, helper_path.c_str()) == 0) {
Current Name Search:     const MappingInfo& mapping = *dumper.mappings()[i]; 
Checking if function:     const MappingInfo& mapping = *dumper.mappings()[i];     if (strcmp(mapping.name, helper_path.c_str()) == 0) {
Class context: stackhelper
Checking if a constructor/destructor:     const MappingInfo& mapping = *dumper.mappings()[i];     if (strcmp(mapping.name, helper_path.c_str()) == 0) {
Other type of bracket:     const MappingInfo& mapping = *dumper.mappings()[i];     if (strcmp(mapping.name, helper_path.c_str()) == 0) {
LINE TO PARSE FOR KEYWORD:    if (strcmp(mapping.name, helper_path.c_str()) == 0) {
Depths: 3:3
['stackhelper']
The real line: +      // This mapping should encompass the entire original mapped
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      
Depths: 3:3
['stackhelper']
The real line: +      // range.
Current Name Search:        
LINE TO PARSE FOR KEYWORD:      
Depths: 3:3
['stackhelper']
The real line: +      EXPECT_EQ(kMappingAddress, mapping.start_addr);
Current Name Search:               
LINE TO PARSE FOR KEYWORD:      expect_eq(kmappingaddress, mapping.start_addr);
Depths: 3:3
['stackhelper']
The real line: +      EXPECT_EQ(kMappingSize, mapping.size);
Current Name Search:       EXPECT_EQ(kMappingAddress, mapping.start_addr); 
LINE TO PARSE FOR KEYWORD:      expect_eq(kmappingsize, mapping.size);
Depths: 3:3
['stackhelper']
The real line: +      EXPECT_EQ(0, mapping.offset);
Current Name Search:       EXPECT_EQ(kMappingSize, mapping.size); 
LINE TO PARSE FOR KEYWORD:      expect_eq(0, mapping.offset);
Depths: 3:3
['stackhelper']
The real line: +      mapping_count++;
Current Name Search:       EXPECT_EQ(0, mapping.offset); 
LINE TO PARSE FOR KEYWORD:      mapping_count++;
Depths: 3:3
['stackhelper']
The real line: +    }
Current Name Search:       mapping_count++; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
['stackhelper']
Adjusting depth.
The real line: +  }
Current Name Search:       mapping_count++;     } 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  EXPECT_EQ(1, mapping_count);
Current Name Search:       mapping_count++;     }   } 
LINE TO PARSE FOR KEYWORD:  expect_eq(1, mapping_count);
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   EXPECT_EQ(1, mapping_count); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:   EXPECT_EQ(1, mapping_count); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
Current Name Search:   EXPECT_EQ(1, mapping_count); }  
Checking if function:   EXPECT_EQ(1, mapping_count); }  TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
Class context: stackhelper
Checking if a constructor/destructor:   EXPECT_EQ(1, mapping_count); }  TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
Other type of bracket:   EXPECT_EQ(1, mapping_count); }  TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, verifystackreadwithmultiplethreads) {
Depths: 1:1
['stackhelper']
The real line: +  static const int kNumberOfThreadsInHelperProgram = 5;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  static const int knumberofthreadsinhelperprogram = 5;
Depths: 1:1
['stackhelper']
The real line: +  char kNumberOfThreadsArgument[2];
Current Name Search:   static const int kNumberOfThreadsInHelperProgram = 5; 
LINE TO PARSE FOR KEYWORD:  char knumberofthreadsargument[2];
Depths: 1:1
['stackhelper']
The real line: +  sprintf(kNumberOfThreadsArgument, "%d", kNumberOfThreadsInHelperProgram);
Current Name Search:   char kNumberOfThreadsArgument[2]; 
LINE TO PARSE FOR KEYWORD:  sprintf(knumberofthreadsargument, , knumberofthreadsinhelperprogram);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   sprintf(kNumberOfThreadsArgument, , kNumberOfThreadsInHelperProgram); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  int fds[2];
Current Name Search:   sprintf(kNumberOfThreadsArgument, , kNumberOfThreadsInHelperProgram);  
LINE TO PARSE FOR KEYWORD:  int fds[2];
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_NE(-1, pipe(fds));
Current Name Search:   int fds[2]; 
LINE TO PARSE FOR KEYWORD:  assert_ne(-1, pipe(fds));
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_NE(-1, pipe(fds)); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  pid_t child_pid = fork();
Current Name Search:   ASSERT_NE(-1, pipe(fds));  
LINE TO PARSE FOR KEYWORD:  pid_t child_pid = fork();
Depths: 1:1
['stackhelper']
The real line: +  if (child_pid == 0) {
Current Name Search:   pid_t child_pid = fork(); 
Checking if function:   pid_t child_pid = fork();   if (child_pid == 0) {
Class context: stackhelper
Checking if a constructor/destructor:   pid_t child_pid = fork();   if (child_pid == 0) {
Other type of bracket:   pid_t child_pid = fork();   if (child_pid == 0) {
LINE TO PARSE FOR KEYWORD:  if (child_pid == 0) {
Depths: 2:2
['stackhelper']
The real line: +    // In child process.
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +    close(fds[0]);
Current Name Search:      
LINE TO PARSE FOR KEYWORD:    close(fds[0]);
Depths: 2:2
['stackhelper']
The real line: +
Current Name Search:     close(fds[0]); 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['stackhelper']
The real line: +    string helper_path(GetHelperBinary());
Current Name Search:     close(fds[0]);  
LINE TO PARSE FOR KEYWORD:    string helper_path(gethelperbinary());
Depths: 2:2
['stackhelper']
The real line: +    if (helper_path.empty()) {
Current Name Search:     string helper_path(GetHelperBinary()); 
Checking if function:     string helper_path(GetHelperBinary());     if (helper_path.empty()) {
Class context: stackhelper
Checking if a constructor/destructor:     string helper_path(GetHelperBinary());     if (helper_path.empty()) {
Other type of bracket:     string helper_path(GetHelperBinary());     if (helper_path.empty()) {
LINE TO PARSE FOR KEYWORD:    if (helper_path.empty()) {
Depths: 3:3
['stackhelper']
The real line: +      FAIL() << "Couldn't find helper binary";
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      fail() << ;
Depths: 3:3
['stackhelper']
The real line: +      exit(1);
Current Name Search:       FAIL() << ; 
LINE TO PARSE FOR KEYWORD:      exit(1);
Depths: 3:3
['stackhelper']
The real line: +    }
Current Name Search:       exit(1); 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:       exit(1);     } 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['stackhelper']
The real line: +    // Pass the pipe fd and the number of threads as arguments.
Current Name Search:       exit(1);     }  
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +    char pipe_fd_string[8];
Current Name Search:       exit(1);     }       
LINE TO PARSE FOR KEYWORD:    char pipe_fd_string[8];
Depths: 2:2
['stackhelper']
The real line: +    sprintf(pipe_fd_string, "%d", fds[1]);
Current Name Search:     char pipe_fd_string[8]; 
LINE TO PARSE FOR KEYWORD:    sprintf(pipe_fd_string, , fds[1]);
Depths: 2:2
['stackhelper']
The real line: +    execl(helper_path.c_str(),
Current Name Search:     sprintf(pipe_fd_string, , fds[1]); 
LINE TO PARSE FOR KEYWORD:    execl(helper_path.c_str(),
Depths: 2:2
['stackhelper']
The real line: +          "linux_dumper_unittest_helper",
Current Name Search:     sprintf(pipe_fd_string, , fds[1]);     execl(helper_path.c_str(), 
LINE TO PARSE FOR KEYWORD:          ,
Depths: 2:2
['stackhelper']
The real line: +          pipe_fd_string,
Current Name Search:     sprintf(pipe_fd_string, , fds[1]);     execl(helper_path.c_str(),           , 
LINE TO PARSE FOR KEYWORD:          pipe_fd_string,
Depths: 2:2
['stackhelper']
The real line: +          kNumberOfThreadsArgument,
Current Name Search:     sprintf(pipe_fd_string, , fds[1]);     execl(helper_path.c_str(),           ,           pipe_fd_string, 
LINE TO PARSE FOR KEYWORD:          knumberofthreadsargument,
Depths: 2:2
['stackhelper']
The real line: +          NULL);
Current Name Search:     sprintf(pipe_fd_string, , fds[1]);     execl(helper_path.c_str(),           ,           pipe_fd_string,           kNumberOfThreadsArgument, 
LINE TO PARSE FOR KEYWORD:          null);
Depths: 2:2
['stackhelper']
The real line: +    // Kill if we get here.
Current Name Search:           NULL); 
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +    printf("Errno from exec: %d", errno);
Current Name Search:           NULL);      
LINE TO PARSE FOR KEYWORD:    printf(, errno);
Depths: 2:2
['stackhelper']
The real line: +    FAIL() << "Exec of " << helper_path << " failed: " << strerror(errno);
Current Name Search:     printf(, errno); 
LINE TO PARSE FOR KEYWORD:    fail() <<  << helper_path <<  << strerror(errno);
Depths: 2:2
['stackhelper']
The real line: +    exit(0);
Current Name Search:     FAIL() <<  << helper_path <<  << strerror(errno); 
LINE TO PARSE FOR KEYWORD:    exit(0);
Depths: 2:2
['stackhelper']
The real line: +  }
Current Name Search:     exit(0); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  close(fds[1]);
Current Name Search:     exit(0);   } 
LINE TO PARSE FOR KEYWORD:  close(fds[1]);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   close(fds[1]); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Wait for all child threads to indicate that they have started
Current Name Search:   close(fds[1]);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  for (int threads = 0; threads < kNumberOfThreadsInHelperProgram; threads++) {
Current Name Search:   close(fds[1]);     
Checking if function:   close(fds[1]);       for (int threads = 0; threads < kNumberOfThreadsInHelperProgram; threads++) {
Class context: stackhelper
Checking if a constructor/destructor:   close(fds[1]);       for (int threads = 0; threads < kNumberOfThreadsInHelperProgram; threads++) {
Other type of bracket:   close(fds[1]);       for (int threads = 0; threads < kNumberOfThreadsInHelperProgram; threads++) {
LINE TO PARSE FOR KEYWORD:  for (int threads = 0; threads < knumberofthreadsinhelperprogram; threads++) {
Depths: 2:2
['stackhelper']
The real line: +    struct pollfd pfd;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    struct pollfd pfd;
Depths: 2:2
['stackhelper']
The real line: +    memset(&pfd, 0, sizeof(pfd));
Current Name Search:     struct pollfd pfd; 
LINE TO PARSE FOR KEYWORD:    memset(&pfd, 0, sizeof(pfd));
Depths: 2:2
['stackhelper']
The real line: +    pfd.fd = fds[0];
Current Name Search:     memset(&pfd, 0, sizeof(pfd)); 
LINE TO PARSE FOR KEYWORD:    pfd.fd = fds[0];
Depths: 2:2
['stackhelper']
The real line: +    pfd.events = POLLIN | POLLERR;
Current Name Search:     pfd.fd = fds[0]; 
LINE TO PARSE FOR KEYWORD:    pfd.events = pollin | pollerr;
Depths: 2:2
['stackhelper']
The real line: +
Current Name Search:     pfd.events = POLLIN | POLLERR; 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['stackhelper']
The real line: +    const int r = HANDLE_EINTR(poll(&pfd, 1, 1000));
Current Name Search:     pfd.events = POLLIN | POLLERR;  
LINE TO PARSE FOR KEYWORD:    const int r = handle_eintr(poll(&pfd, 1, 1000));
Depths: 2:2
['stackhelper']
The real line: +    ASSERT_EQ(1, r);
Current Name Search:     const int r = HANDLE_EINTR(poll(&pfd, 1, 1000)); 
LINE TO PARSE FOR KEYWORD:    assert_eq(1, r);
Depths: 2:2
['stackhelper']
The real line: +    ASSERT_TRUE(pfd.revents & POLLIN);
Current Name Search:     ASSERT_EQ(1, r); 
LINE TO PARSE FOR KEYWORD:    assert_true(pfd.revents & pollin);
Depths: 2:2
['stackhelper']
The real line: +    uint8_t junk;
Current Name Search:     ASSERT_TRUE(pfd.revents & POLLIN); 
LINE TO PARSE FOR KEYWORD:    uint8_t junk;
Depths: 2:2
['stackhelper']
The real line: +    ASSERT_EQ(read(fds[0], &junk, sizeof(junk)), sizeof(junk));
Current Name Search:     uint8_t junk; 
LINE TO PARSE FOR KEYWORD:    assert_eq(read(fds[0], &junk, sizeof(junk)), sizeof(junk));
Depths: 2:2
['stackhelper']
The real line: +  }
Current Name Search:     ASSERT_EQ(read(fds[0], &junk, sizeof(junk)), sizeof(junk)); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  close(fds[0]);
Current Name Search:     ASSERT_EQ(read(fds[0], &junk, sizeof(junk)), sizeof(junk));   } 
LINE TO PARSE FOR KEYWORD:  close(fds[0]);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   close(fds[0]); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // There is a race here because we may stop a child thread before
Current Name Search:   close(fds[0]);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  // it is actually running the busy loop. Empirically this sleep
Current Name Search:   close(fds[0]);     
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  // is sufficient to avoid the race.
Current Name Search:   close(fds[0]);        
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  usleep(100000);
Current Name Search:   close(fds[0]);           
LINE TO PARSE FOR KEYWORD:  usleep(100000);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   usleep(100000); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Children are ready now.
Current Name Search:   usleep(100000);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(child_pid);
Current Name Search:   usleep(100000);     
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(child_pid);
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(child_pid); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_EQ((size_t)kNumberOfThreadsInHelperProgram, dumper.threads().size());
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:  expect_eq((size_t)knumberofthreadsinhelperprogram, dumper.threads().size());
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_TRUE(dumper.ThreadsSuspend());
Current Name Search:   EXPECT_EQ((size_t)kNumberOfThreadsInHelperProgram, dumper.threads().size()); 
LINE TO PARSE FOR KEYWORD:  expect_true(dumper.threadssuspend());
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   EXPECT_TRUE(dumper.ThreadsSuspend()); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  ThreadInfo one_thread;
Current Name Search:   EXPECT_TRUE(dumper.ThreadsSuspend());  
LINE TO PARSE FOR KEYWORD:  threadinfo one_thread;
Depths: 1:1
['stackhelper']
The real line: +  for (size_t i = 0; i < dumper.threads().size(); ++i) {
Current Name Search:   ThreadInfo one_thread; 
Checking if function:   ThreadInfo one_thread;   for (size_t i = 0; i < dumper.threads().size(); ++i) {
Class context: stackhelper
Checking if a constructor/destructor:   ThreadInfo one_thread;   for (size_t i = 0; i < dumper.threads().size(); ++i) {
Other type of bracket:   ThreadInfo one_thread;   for (size_t i = 0; i < dumper.threads().size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (size_t i = 0; i < dumper.threads().size(); ++i) {
Depths: 2:2
['stackhelper']
The real line: +    EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &one_thread));
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    expect_true(dumper.getthreadinfobyindex(i, &one_thread));
Depths: 2:2
['stackhelper']
The real line: +    // In the helper program, we stored a pointer to the thread id in a
Current Name Search:     EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &one_thread)); 
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +    // specific register. Check that we can recover its value.
Current Name Search:     EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &one_thread));      
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +#if defined(__ARM_EABI__)
Current Name Search:     EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &one_thread));           
LINE TO PARSE FOR KEYWORD:#if defined(__arm_eabi__)
Depths: 2:2
['stackhelper']
The real line: +    pid_t *process_tid_location = (pid_t *)(one_thread.regs.uregs[3]);
Current Name Search:     EXPECT_TRUE(dumper.GetThreadInfoByIndex(i, &one_thread));           #if defined(__ARM_EABI__) 
LINE TO PARSE FOR KEYWORD:    pid_t *process_tid_location = (pid_t *)(one_thread.regs.uregs[3]);
Depths: 2:2
['stackhelper']
The real line: +#elif defined(__i386)
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.uregs[3]); 
LINE TO PARSE FOR KEYWORD:#elif defined(__i386)
Depths: 2:2
['stackhelper']
The real line: +    pid_t *process_tid_location = (pid_t *)(one_thread.regs.ecx);
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.uregs[3]); #elif defined(__i386) 
LINE TO PARSE FOR KEYWORD:    pid_t *process_tid_location = (pid_t *)(one_thread.regs.ecx);
Depths: 2:2
['stackhelper']
The real line: +#elif defined(__x86_64)
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.ecx); 
LINE TO PARSE FOR KEYWORD:#elif defined(__x86_64)
Depths: 2:2
['stackhelper']
The real line: +    pid_t *process_tid_location = (pid_t *)(one_thread.regs.rcx);
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.ecx); #elif defined(__x86_64) 
LINE TO PARSE FOR KEYWORD:    pid_t *process_tid_location = (pid_t *)(one_thread.regs.rcx);
Depths: 2:2
['stackhelper']
The real line: +#else
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.rcx); 
LINE TO PARSE FOR KEYWORD:#else
Depths: 2:2
['stackhelper']
The real line: +#error This test has not been ported to this platform.
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.rcx); #else 
LINE TO PARSE FOR KEYWORD:#error this test has not been ported to this platform.
Depths: 2:2
['stackhelper']
The real line: +#endif
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.rcx); #else #error This test has not been ported to this platform. 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 2:2
['stackhelper']
The real line: +    pid_t one_thread_id;
Current Name Search:     pid_t *process_tid_location = (pid_t *)(one_thread.regs.rcx); #else #error This test has not been ported to this platform. #endif 
LINE TO PARSE FOR KEYWORD:    pid_t one_thread_id;
Depths: 2:2
['stackhelper']
The real line: +    dumper.CopyFromProcess(&one_thread_id,
Current Name Search:     pid_t one_thread_id; 
LINE TO PARSE FOR KEYWORD:    dumper.copyfromprocess(&one_thread_id,
Depths: 2:2
['stackhelper']
The real line: +                           dumper.threads()[i],
Current Name Search:     pid_t one_thread_id;     dumper.CopyFromProcess(&one_thread_id, 
LINE TO PARSE FOR KEYWORD:                           dumper.threads()[i],
Depths: 2:2
['stackhelper']
The real line: +                           process_tid_location,
Current Name Search:     pid_t one_thread_id;     dumper.CopyFromProcess(&one_thread_id,                            dumper.threads()[i], 
LINE TO PARSE FOR KEYWORD:                           process_tid_location,
Depths: 2:2
['stackhelper']
The real line: +                           4);
Current Name Search:     pid_t one_thread_id;     dumper.CopyFromProcess(&one_thread_id,                            dumper.threads()[i],                            process_tid_location, 
LINE TO PARSE FOR KEYWORD:                           4);
Depths: 2:2
['stackhelper']
The real line: +    EXPECT_EQ(dumper.threads()[i], one_thread_id);
Current Name Search:                            4); 
LINE TO PARSE FOR KEYWORD:    expect_eq(dumper.threads()[i], one_thread_id);
Depths: 2:2
['stackhelper']
The real line: +  }
Current Name Search:     EXPECT_EQ(dumper.threads()[i], one_thread_id); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  EXPECT_TRUE(dumper.ThreadsResume());
Current Name Search:     EXPECT_EQ(dumper.threads()[i], one_thread_id);   } 
LINE TO PARSE FOR KEYWORD:  expect_true(dumper.threadsresume());
Depths: 1:1
['stackhelper']
The real line: +  kill(child_pid, SIGKILL);
Current Name Search:   EXPECT_TRUE(dumper.ThreadsResume()); 
LINE TO PARSE FOR KEYWORD:  kill(child_pid, sigkill);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   kill(child_pid, SIGKILL); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Reap child
Current Name Search:   kill(child_pid, SIGKILL);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  int status;
Current Name Search:   kill(child_pid, SIGKILL);     
LINE TO PARSE FOR KEYWORD:  int status;
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_NE(-1, HANDLE_EINTR(waitpid(child_pid, &status, 0)));
Current Name Search:   int status; 
LINE TO PARSE FOR KEYWORD:  assert_ne(-1, handle_eintr(waitpid(child_pid, &status, 0)));
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(WIFSIGNALED(status));
Current Name Search:   ASSERT_NE(-1, HANDLE_EINTR(waitpid(child_pid, &status, 0))); 
LINE TO PARSE FOR KEYWORD:  assert_true(wifsignaled(status));
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_EQ(SIGKILL, WTERMSIG(status));
Current Name Search:   ASSERT_TRUE(WIFSIGNALED(status)); 
LINE TO PARSE FOR KEYWORD:  assert_eq(sigkill, wtermsig(status));
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   ASSERT_EQ(SIGKILL, WTERMSIG(status)); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:   ASSERT_EQ(SIGKILL, WTERMSIG(status)); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, BuildProcPath) {
Current Name Search:   ASSERT_EQ(SIGKILL, WTERMSIG(status)); }  
Checking if function:   ASSERT_EQ(SIGKILL, WTERMSIG(status)); }  TEST(LinuxPtraceDumperTest, BuildProcPath) {
Class context: stackhelper
Checking if a constructor/destructor:   ASSERT_EQ(SIGKILL, WTERMSIG(status)); }  TEST(LinuxPtraceDumperTest, BuildProcPath) {
Other type of bracket:   ASSERT_EQ(SIGKILL, WTERMSIG(status)); }  TEST(LinuxPtraceDumperTest, BuildProcPath) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, buildprocpath) {
Depths: 1:1
['stackhelper']
The real line: +  const pid_t pid = getpid();
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  const pid_t pid = getpid();
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(pid);
Current Name Search:   const pid_t pid = getpid(); 
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(pid);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   LinuxPtraceDumper dumper(pid); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  char maps_path[NAME_MAX] = "";
Current Name Search:   LinuxPtraceDumper dumper(pid);  
LINE TO PARSE FOR KEYWORD:  char maps_path[name_max] = ;
Depths: 1:1
['stackhelper']
The real line: +  char maps_path_expected[NAME_MAX];
Current Name Search:   char maps_path[NAME_MAX] = ; 
LINE TO PARSE FOR KEYWORD:  char maps_path_expected[name_max];
Depths: 1:1
['stackhelper']
The real line: +  snprintf(maps_path_expected, sizeof(maps_path_expected),
Current Name Search:   char maps_path_expected[NAME_MAX]; 
LINE TO PARSE FOR KEYWORD:  snprintf(maps_path_expected, sizeof(maps_path_expected),
Depths: 1:1
['stackhelper']
The real line: +           "/proc/%d/maps", pid);
Current Name Search:   char maps_path_expected[NAME_MAX];   snprintf(maps_path_expected, sizeof(maps_path_expected), 
LINE TO PARSE FOR KEYWORD:           , pid);
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_TRUE(dumper.BuildProcPath(maps_path, pid, "maps"));
Current Name Search:            , pid); 
LINE TO PARSE FOR KEYWORD:  expect_true(dumper.buildprocpath(maps_path, pid, ));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_STREQ(maps_path_expected, maps_path);
Current Name Search:   EXPECT_TRUE(dumper.BuildProcPath(maps_path, pid, )); 
LINE TO PARSE FOR KEYWORD:  expect_streq(maps_path_expected, maps_path);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   EXPECT_STREQ(maps_path_expected, maps_path); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_FALSE(dumper.BuildProcPath(NULL, pid, "maps"));
Current Name Search:   EXPECT_STREQ(maps_path_expected, maps_path);  
LINE TO PARSE FOR KEYWORD:  expect_false(dumper.buildprocpath(null, pid, ));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_FALSE(dumper.BuildProcPath(maps_path, 0, "maps"));
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(NULL, pid, )); 
LINE TO PARSE FOR KEYWORD:  expect_false(dumper.buildprocpath(maps_path, 0, ));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_FALSE(dumper.BuildProcPath(maps_path, pid, ""));
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 0, )); 
LINE TO PARSE FOR KEYWORD:  expect_false(dumper.buildprocpath(maps_path, pid, ));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_FALSE(dumper.BuildProcPath(maps_path, pid, NULL));
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, pid, )); 
LINE TO PARSE FOR KEYWORD:  expect_false(dumper.buildprocpath(maps_path, pid, null));
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, pid, NULL)); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  char long_node[NAME_MAX];
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, pid, NULL));  
LINE TO PARSE FOR KEYWORD:  char long_node[name_max];
Depths: 1:1
['stackhelper']
The real line: +  size_t long_node_len = NAME_MAX - strlen("/proc/123") - 1;
Current Name Search:   char long_node[NAME_MAX]; 
LINE TO PARSE FOR KEYWORD:  size_t long_node_len = name_max - strlen() - 1;
Depths: 1:1
['stackhelper']
The real line: +  memset(long_node, 'a', long_node_len);
Current Name Search:   size_t long_node_len = NAME_MAX - strlen() - 1; 
LINE TO PARSE FOR KEYWORD:  memset(long_node, , long_node_len);
Depths: 1:1
['stackhelper']
The real line: +  long_node[long_node_len] = '\0';
Current Name Search:   memset(long_node, , long_node_len); 
LINE TO PARSE FOR KEYWORD:  long_node[long_node_len] = ;
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node));
Current Name Search:   long_node[long_node_len] = ; 
LINE TO PARSE FOR KEYWORD:  expect_false(dumper.buildprocpath(maps_path, 123, long_node));
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +#if !defined(__ARM_EABI__)
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); }  
LINE TO PARSE FOR KEYWORD:#if !defined(__arm_eabi__)
Depths: 0:0
['stackhelper']
The real line: +// Ensure that the linux-gate VDSO is included in the mapping list.
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); }  #if !defined(__ARM_EABI__) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, MappingsIncludeLinuxGate) {
Current Name Search:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); }  #if !defined(__ARM_EABI__)  
Checking if function:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); }  #if !defined(__ARM_EABI__)  TEST(LinuxPtraceDumperTest, MappingsIncludeLinuxGate) {
Class context: stackhelper
Checking if a constructor/destructor:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); }  #if !defined(__ARM_EABI__)  TEST(LinuxPtraceDumperTest, MappingsIncludeLinuxGate) {
Other type of bracket:   EXPECT_FALSE(dumper.BuildProcPath(maps_path, 123, long_node)); }  #if !defined(__ARM_EABI__)  TEST(LinuxPtraceDumperTest, MappingsIncludeLinuxGate) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, mappingsincludelinuxgate) {
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(getpid());
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(getpid());
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(getpid()); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  void* linux_gate_loc = dumper.FindBeginningOfLinuxGateSharedLibrary(getpid());
Current Name Search:   ASSERT_TRUE(dumper.Init());  
LINE TO PARSE FOR KEYWORD:  void* linux_gate_loc = dumper.findbeginningoflinuxgatesharedlibrary(getpid());
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(linux_gate_loc);
Current Name Search:   void* linux_gate_loc = dumper.FindBeginningOfLinuxGateSharedLibrary(getpid()); 
LINE TO PARSE FOR KEYWORD:  assert_true(linux_gate_loc);
Depths: 1:1
['stackhelper']
The real line: +  bool found_linux_gate = false;
Current Name Search:   ASSERT_TRUE(linux_gate_loc); 
LINE TO PARSE FOR KEYWORD:  bool found_linux_gate = false;
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   bool found_linux_gate = false; 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  const wasteful_vector<MappingInfo*> mappings = dumper.mappings();
Current Name Search:   bool found_linux_gate = false;  
LINE TO PARSE FOR KEYWORD:  const wasteful_vector<mappinginfo*> mappings = dumper.mappings();
Depths: 1:1
['stackhelper']
The real line: +  const MappingInfo* mapping;
Current Name Search:   const wasteful_vector<MappingInfo*> mappings = dumper.mappings(); 
LINE TO PARSE FOR KEYWORD:  const mappinginfo* mapping;
Depths: 1:1
['stackhelper']
The real line: +  for (unsigned i = 0; i < mappings.size(); ++i) {
Current Name Search:   const MappingInfo* mapping; 
Checking if function:   const MappingInfo* mapping;   for (unsigned i = 0; i < mappings.size(); ++i) {
Class context: stackhelper
Checking if a constructor/destructor:   const MappingInfo* mapping;   for (unsigned i = 0; i < mappings.size(); ++i) {
Other type of bracket:   const MappingInfo* mapping;   for (unsigned i = 0; i < mappings.size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (unsigned i = 0; i < mappings.size(); ++i) {
Depths: 2:2
['stackhelper']
The real line: +    mapping = mappings[i];
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    mapping = mappings[i];
Depths: 2:2
['stackhelper']
The real line: +    if (!strcmp(mapping->name, kLinuxGateLibraryName)) {
Current Name Search:     mapping = mappings[i]; 
Checking if function:     mapping = mappings[i];     if (!strcmp(mapping->name, kLinuxGateLibraryName)) {
Class context: stackhelper
Checking if a constructor/destructor:     mapping = mappings[i];     if (!strcmp(mapping->name, kLinuxGateLibraryName)) {
Other type of bracket:     mapping = mappings[i];     if (!strcmp(mapping->name, kLinuxGateLibraryName)) {
LINE TO PARSE FOR KEYWORD:    if (!strcmp(mapping->name, klinuxgatelibraryname)) {
Depths: 3:3
['stackhelper']
The real line: +      found_linux_gate = true;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      found_linux_gate = true;
Depths: 3:3
['stackhelper']
The real line: +      break;
Current Name Search:       found_linux_gate = true; 
LINE TO PARSE FOR KEYWORD:      break;
Depths: 3:3
['stackhelper']
The real line: +    }
Current Name Search:       break; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
['stackhelper']
Adjusting depth.
The real line: +  }
Current Name Search:       break;     } 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  EXPECT_TRUE(found_linux_gate);
Current Name Search:       break;     }   } 
LINE TO PARSE FOR KEYWORD:  expect_true(found_linux_gate);
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_EQ(linux_gate_loc, reinterpret_cast<void*>(mapping->start_addr));
Current Name Search:   EXPECT_TRUE(found_linux_gate); 
LINE TO PARSE FOR KEYWORD:  expect_eq(linux_gate_loc, reinterpret_cast<void*>(mapping->start_addr));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG));
Current Name Search:   EXPECT_EQ(linux_gate_loc, reinterpret_cast<void*>(mapping->start_addr)); 
LINE TO PARSE FOR KEYWORD:  expect_eq(0, memcmp(linux_gate_loc, elfmag, selfmag));
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +// Ensure that the linux-gate VDSO can generate a non-zeroed File ID.
Current Name Search:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); }  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, LinuxGateMappingID) {
Current Name Search:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); }   
Checking if function:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); }   TEST(LinuxPtraceDumperTest, LinuxGateMappingID) {
Class context: stackhelper
Checking if a constructor/destructor:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); }   TEST(LinuxPtraceDumperTest, LinuxGateMappingID) {
Other type of bracket:   EXPECT_EQ(0, memcmp(linux_gate_loc, ELFMAG, SELFMAG)); }   TEST(LinuxPtraceDumperTest, LinuxGateMappingID) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, linuxgatemappingid) {
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(getpid());
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(getpid());
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(getpid()); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  bool found_linux_gate = false;
Current Name Search:   ASSERT_TRUE(dumper.Init());  
LINE TO PARSE FOR KEYWORD:  bool found_linux_gate = false;
Depths: 1:1
['stackhelper']
The real line: +  const wasteful_vector<MappingInfo*> mappings = dumper.mappings();
Current Name Search:   bool found_linux_gate = false; 
LINE TO PARSE FOR KEYWORD:  const wasteful_vector<mappinginfo*> mappings = dumper.mappings();
Depths: 1:1
['stackhelper']
The real line: +  unsigned index = 0;
Current Name Search:   const wasteful_vector<MappingInfo*> mappings = dumper.mappings(); 
LINE TO PARSE FOR KEYWORD:  unsigned index = 0;
Depths: 1:1
['stackhelper']
The real line: +  for (unsigned i = 0; i < mappings.size(); ++i) {
Current Name Search:   unsigned index = 0; 
Checking if function:   unsigned index = 0;   for (unsigned i = 0; i < mappings.size(); ++i) {
Class context: stackhelper
Checking if a constructor/destructor:   unsigned index = 0;   for (unsigned i = 0; i < mappings.size(); ++i) {
Other type of bracket:   unsigned index = 0;   for (unsigned i = 0; i < mappings.size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (unsigned i = 0; i < mappings.size(); ++i) {
Depths: 2:2
['stackhelper']
The real line: +    if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
Current Name Search: 
Checking if function:     if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
Class context: stackhelper
Checking if a constructor/destructor:     if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
Other type of bracket:     if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
LINE TO PARSE FOR KEYWORD:    if (!strcmp(mappings[i]->name, klinuxgatelibraryname)) {
Depths: 3:3
['stackhelper']
The real line: +      found_linux_gate = true;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      found_linux_gate = true;
Depths: 3:3
['stackhelper']
The real line: +      index = i;
Current Name Search:       found_linux_gate = true; 
LINE TO PARSE FOR KEYWORD:      index = i;
Depths: 3:3
['stackhelper']
The real line: +      break;
Current Name Search:       index = i; 
LINE TO PARSE FOR KEYWORD:      break;
Depths: 3:3
['stackhelper']
The real line: +    }
Current Name Search:       break; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
['stackhelper']
Adjusting depth.
The real line: +  }
Current Name Search:       break;     } 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  ASSERT_TRUE(found_linux_gate);
Current Name Search:       break;     }   } 
LINE TO PARSE FOR KEYWORD:  assert_true(found_linux_gate);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(found_linux_gate); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  uint8_t identifier[sizeof(MDGUID)];
Current Name Search:   ASSERT_TRUE(found_linux_gate);  
LINE TO PARSE FOR KEYWORD:  uint8_t identifier[sizeof(mdguid)];
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],
Current Name Search:   uint8_t identifier[sizeof(MDGUID)]; 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.elffileidentifierformapping(*mappings[index],
Depths: 1:1
['stackhelper']
The real line: +                                                 true,
Current Name Search:   uint8_t identifier[sizeof(MDGUID)];   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index], 
LINE TO PARSE FOR KEYWORD:                                                 true,
Depths: 1:1
['stackhelper']
The real line: +                                                 index,
Current Name Search:   uint8_t identifier[sizeof(MDGUID)];   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],                                                  true, 
LINE TO PARSE FOR KEYWORD:                                                 index,
Depths: 1:1
['stackhelper']
The real line: +                                                 identifier));
Current Name Search:   uint8_t identifier[sizeof(MDGUID)];   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],                                                  true,                                                  index, 
LINE TO PARSE FOR KEYWORD:                                                 identifier));
Depths: 1:1
['stackhelper']
The real line: +  uint8_t empty_identifier[sizeof(MDGUID)];
Current Name Search:                                                  identifier)); 
LINE TO PARSE FOR KEYWORD:  uint8_t empty_identifier[sizeof(mdguid)];
Depths: 1:1
['stackhelper']
The real line: +  memset(empty_identifier, 0, sizeof(empty_identifier));
Current Name Search:   uint8_t empty_identifier[sizeof(MDGUID)]; 
LINE TO PARSE FOR KEYWORD:  memset(empty_identifier, 0, sizeof(empty_identifier));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier)));
Current Name Search:   memset(empty_identifier, 0, sizeof(empty_identifier)); 
LINE TO PARSE FOR KEYWORD:  expect_ne(0, memcmp(empty_identifier, identifier, sizeof(identifier)));
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +
Current Name Search:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +// Ensure that the linux-gate VDSO can generate a non-zeroed File ID
Current Name Search:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); }  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +// from a child process.
Current Name Search:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); }   
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, LinuxGateMappingIDChild) {
Current Name Search:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); }    
Checking if function:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); }    TEST(LinuxPtraceDumperTest, LinuxGateMappingIDChild) {
Class context: stackhelper
Checking if a constructor/destructor:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); }    TEST(LinuxPtraceDumperTest, LinuxGateMappingIDChild) {
Other type of bracket:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); }    TEST(LinuxPtraceDumperTest, LinuxGateMappingIDChild) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, linuxgatemappingidchild) {
Depths: 1:1
['stackhelper']
The real line: +  int fds[2];
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  int fds[2];
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_NE(-1, pipe(fds));
Current Name Search:   int fds[2]; 
LINE TO PARSE FOR KEYWORD:  assert_ne(-1, pipe(fds));
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_NE(-1, pipe(fds)); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Fork a child so ptrace works.
Current Name Search:   ASSERT_NE(-1, pipe(fds));  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  const pid_t child = fork();
Current Name Search:   ASSERT_NE(-1, pipe(fds));     
LINE TO PARSE FOR KEYWORD:  const pid_t child = fork();
Depths: 1:1
['stackhelper']
The real line: +  if (child == 0) {
Current Name Search:   const pid_t child = fork(); 
Checking if function:   const pid_t child = fork();   if (child == 0) {
Class context: stackhelper
Checking if a constructor/destructor:   const pid_t child = fork();   if (child == 0) {
Other type of bracket:   const pid_t child = fork();   if (child == 0) {
LINE TO PARSE FOR KEYWORD:  if (child == 0) {
Depths: 2:2
['stackhelper']
The real line: +    close(fds[1]);
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    close(fds[1]);
Depths: 2:2
['stackhelper']
The real line: +    // Now wait forever for the parent.
Current Name Search:     close(fds[1]); 
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +    char b;
Current Name Search:     close(fds[1]);      
LINE TO PARSE FOR KEYWORD:    char b;
Depths: 2:2
['stackhelper']
The real line: +    HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
Current Name Search:     char b; 
LINE TO PARSE FOR KEYWORD:    handle_eintr(read(fds[0], &b, sizeof(b)));
Depths: 2:2
['stackhelper']
The real line: +    close(fds[0]);
Current Name Search:     HANDLE_EINTR(read(fds[0], &b, sizeof(b))); 
LINE TO PARSE FOR KEYWORD:    close(fds[0]);
Depths: 2:2
['stackhelper']
The real line: +    syscall(__NR_exit);
Current Name Search:     close(fds[0]); 
LINE TO PARSE FOR KEYWORD:    syscall(__nr_exit);
Depths: 2:2
['stackhelper']
The real line: +  }
Current Name Search:     syscall(__NR_exit); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  close(fds[0]);
Current Name Search:     syscall(__NR_exit);   } 
LINE TO PARSE FOR KEYWORD:  close(fds[0]);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   close(fds[0]); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(child);
Current Name Search:   close(fds[0]);  
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(child);
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(child); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  bool found_linux_gate = false;
Current Name Search:   ASSERT_TRUE(dumper.Init());  
LINE TO PARSE FOR KEYWORD:  bool found_linux_gate = false;
Depths: 1:1
['stackhelper']
The real line: +  const wasteful_vector<MappingInfo*> mappings = dumper.mappings();
Current Name Search:   bool found_linux_gate = false; 
LINE TO PARSE FOR KEYWORD:  const wasteful_vector<mappinginfo*> mappings = dumper.mappings();
Depths: 1:1
['stackhelper']
The real line: +  unsigned index = 0;
Current Name Search:   const wasteful_vector<MappingInfo*> mappings = dumper.mappings(); 
LINE TO PARSE FOR KEYWORD:  unsigned index = 0;
Depths: 1:1
['stackhelper']
The real line: +  for (unsigned i = 0; i < mappings.size(); ++i) {
Current Name Search:   unsigned index = 0; 
Checking if function:   unsigned index = 0;   for (unsigned i = 0; i < mappings.size(); ++i) {
Class context: stackhelper
Checking if a constructor/destructor:   unsigned index = 0;   for (unsigned i = 0; i < mappings.size(); ++i) {
Other type of bracket:   unsigned index = 0;   for (unsigned i = 0; i < mappings.size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (unsigned i = 0; i < mappings.size(); ++i) {
Depths: 2:2
['stackhelper']
The real line: +    if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
Current Name Search: 
Checking if function:     if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
Class context: stackhelper
Checking if a constructor/destructor:     if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
Other type of bracket:     if (!strcmp(mappings[i]->name, kLinuxGateLibraryName)) {
LINE TO PARSE FOR KEYWORD:    if (!strcmp(mappings[i]->name, klinuxgatelibraryname)) {
Depths: 3:3
['stackhelper']
The real line: +      found_linux_gate = true;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      found_linux_gate = true;
Depths: 3:3
['stackhelper']
The real line: +      index = i;
Current Name Search:       found_linux_gate = true; 
LINE TO PARSE FOR KEYWORD:      index = i;
Depths: 3:3
['stackhelper']
The real line: +      break;
Current Name Search:       index = i; 
LINE TO PARSE FOR KEYWORD:      break;
Depths: 3:3
['stackhelper']
The real line: +    }
Current Name Search:       break; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
['stackhelper']
Adjusting depth.
The real line: +  }
Current Name Search:       break;     } 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  ASSERT_TRUE(found_linux_gate);
Current Name Search:       break;     }   } 
LINE TO PARSE FOR KEYWORD:  assert_true(found_linux_gate);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(found_linux_gate); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Need to suspend the child so ptrace actually works.
Current Name Search:   ASSERT_TRUE(found_linux_gate);  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.ThreadsSuspend());
Current Name Search:   ASSERT_TRUE(found_linux_gate);     
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.threadssuspend());
Depths: 1:1
['stackhelper']
The real line: +  uint8_t identifier[sizeof(MDGUID)];
Current Name Search:   ASSERT_TRUE(dumper.ThreadsSuspend()); 
LINE TO PARSE FOR KEYWORD:  uint8_t identifier[sizeof(mdguid)];
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],
Current Name Search:   uint8_t identifier[sizeof(MDGUID)]; 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.elffileidentifierformapping(*mappings[index],
Depths: 1:1
['stackhelper']
The real line: +                                                 true,
Current Name Search:   uint8_t identifier[sizeof(MDGUID)];   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index], 
LINE TO PARSE FOR KEYWORD:                                                 true,
Depths: 1:1
['stackhelper']
The real line: +                                                 index,
Current Name Search:   uint8_t identifier[sizeof(MDGUID)];   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],                                                  true, 
LINE TO PARSE FOR KEYWORD:                                                 index,
Depths: 1:1
['stackhelper']
The real line: +                                                 identifier));
Current Name Search:   uint8_t identifier[sizeof(MDGUID)];   ASSERT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[index],                                                  true,                                                  index, 
LINE TO PARSE FOR KEYWORD:                                                 identifier));
Depths: 1:1
['stackhelper']
The real line: +  uint8_t empty_identifier[sizeof(MDGUID)];
Current Name Search:                                                  identifier)); 
LINE TO PARSE FOR KEYWORD:  uint8_t empty_identifier[sizeof(mdguid)];
Depths: 1:1
['stackhelper']
The real line: +  memset(empty_identifier, 0, sizeof(empty_identifier));
Current Name Search:   uint8_t empty_identifier[sizeof(MDGUID)]; 
LINE TO PARSE FOR KEYWORD:  memset(empty_identifier, 0, sizeof(empty_identifier));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier)));
Current Name Search:   memset(empty_identifier, 0, sizeof(empty_identifier)); 
LINE TO PARSE FOR KEYWORD:  expect_ne(0, memcmp(empty_identifier, identifier, sizeof(identifier)));
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_TRUE(dumper.ThreadsResume());
Current Name Search:   EXPECT_NE(0, memcmp(empty_identifier, identifier, sizeof(identifier))); 
LINE TO PARSE FOR KEYWORD:  expect_true(dumper.threadsresume());
Depths: 1:1
['stackhelper']
The real line: +  close(fds[1]);
Current Name Search:   EXPECT_TRUE(dumper.ThreadsResume()); 
LINE TO PARSE FOR KEYWORD:  close(fds[1]);
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   close(fds[1]); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
The real line: +#endif
Current Name Search:   close(fds[1]); } 
LINE TO PARSE FOR KEYWORD:#endif
Depths: 0:0
['stackhelper']
The real line: +
Current Name Search:   close(fds[1]); } #endif 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['stackhelper']
The real line: +TEST(LinuxPtraceDumperTest, FileIDsMatch) {
Current Name Search:   close(fds[1]); } #endif  
Checking if function:   close(fds[1]); } #endif  TEST(LinuxPtraceDumperTest, FileIDsMatch) {
Class context: stackhelper
Checking if a constructor/destructor:   close(fds[1]); } #endif  TEST(LinuxPtraceDumperTest, FileIDsMatch) {
Other type of bracket:   close(fds[1]); } #endif  TEST(LinuxPtraceDumperTest, FileIDsMatch) {
LINE TO PARSE FOR KEYWORD:test(linuxptracedumpertest, fileidsmatch) {
Depths: 1:1
['stackhelper']
The real line: +  // Calculate the File ID of our binary using both
Current Name Search: 
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  // FileID::ElfFileIdentifier and LinuxDumper::ElfFileIdentifierForMapping
Current Name Search:    
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  // and ensure that we get the same result from both.
Current Name Search:       
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  char exe_name[PATH_MAX];
Current Name Search:          
LINE TO PARSE FOR KEYWORD:  char exe_name[path_max];
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(SafeReadLink("/proc/self/exe", exe_name));
Current Name Search:   char exe_name[PATH_MAX]; 
LINE TO PARSE FOR KEYWORD:  assert_true(safereadlink(, exe_name));
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(SafeReadLink(, exe_name)); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  int fds[2];
Current Name Search:   ASSERT_TRUE(SafeReadLink(, exe_name));  
LINE TO PARSE FOR KEYWORD:  int fds[2];
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_NE(-1, pipe(fds));
Current Name Search:   int fds[2]; 
LINE TO PARSE FOR KEYWORD:  assert_ne(-1, pipe(fds));
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_NE(-1, pipe(fds)); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  // Fork a child so ptrace works.
Current Name Search:   ASSERT_NE(-1, pipe(fds));  
LINE TO PARSE FOR KEYWORD:  
Depths: 1:1
['stackhelper']
The real line: +  const pid_t child = fork();
Current Name Search:   ASSERT_NE(-1, pipe(fds));     
LINE TO PARSE FOR KEYWORD:  const pid_t child = fork();
Depths: 1:1
['stackhelper']
The real line: +  if (child == 0) {
Current Name Search:   const pid_t child = fork(); 
Checking if function:   const pid_t child = fork();   if (child == 0) {
Class context: stackhelper
Checking if a constructor/destructor:   const pid_t child = fork();   if (child == 0) {
Other type of bracket:   const pid_t child = fork();   if (child == 0) {
LINE TO PARSE FOR KEYWORD:  if (child == 0) {
Depths: 2:2
['stackhelper']
The real line: +    close(fds[1]);
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    close(fds[1]);
Depths: 2:2
['stackhelper']
The real line: +    // Now wait forever for the parent.
Current Name Search:     close(fds[1]); 
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['stackhelper']
The real line: +    char b;
Current Name Search:     close(fds[1]);      
LINE TO PARSE FOR KEYWORD:    char b;
Depths: 2:2
['stackhelper']
The real line: +    HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
Current Name Search:     char b; 
LINE TO PARSE FOR KEYWORD:    handle_eintr(read(fds[0], &b, sizeof(b)));
Depths: 2:2
['stackhelper']
The real line: +    close(fds[0]);
Current Name Search:     HANDLE_EINTR(read(fds[0], &b, sizeof(b))); 
LINE TO PARSE FOR KEYWORD:    close(fds[0]);
Depths: 2:2
['stackhelper']
The real line: +    syscall(__NR_exit);
Current Name Search:     close(fds[0]); 
LINE TO PARSE FOR KEYWORD:    syscall(__nr_exit);
Depths: 2:2
['stackhelper']
The real line: +  }
Current Name Search:     syscall(__NR_exit); 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  close(fds[0]);
Current Name Search:     syscall(__NR_exit);   } 
LINE TO PARSE FOR KEYWORD:  close(fds[0]);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   close(fds[0]); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  LinuxPtraceDumper dumper(child);
Current Name Search:   close(fds[0]);  
LINE TO PARSE FOR KEYWORD:  linuxptracedumper dumper(child);
Depths: 1:1
['stackhelper']
The real line: +  ASSERT_TRUE(dumper.Init());
Current Name Search:   LinuxPtraceDumper dumper(child); 
LINE TO PARSE FOR KEYWORD:  assert_true(dumper.init());
Depths: 1:1
['stackhelper']
The real line: +  const wasteful_vector<MappingInfo*> mappings = dumper.mappings();
Current Name Search:   ASSERT_TRUE(dumper.Init()); 
LINE TO PARSE FOR KEYWORD:  const wasteful_vector<mappinginfo*> mappings = dumper.mappings();
Depths: 1:1
['stackhelper']
The real line: +  bool found_exe = false;
Current Name Search:   const wasteful_vector<MappingInfo*> mappings = dumper.mappings(); 
LINE TO PARSE FOR KEYWORD:  bool found_exe = false;
Depths: 1:1
['stackhelper']
The real line: +  unsigned i;
Current Name Search:   bool found_exe = false; 
LINE TO PARSE FOR KEYWORD:  unsigned i;
Depths: 1:1
['stackhelper']
The real line: +  for (i = 0; i < mappings.size(); ++i) {
Current Name Search:   unsigned i; 
Checking if function:   unsigned i;   for (i = 0; i < mappings.size(); ++i) {
Class context: stackhelper
Checking if a constructor/destructor:   unsigned i;   for (i = 0; i < mappings.size(); ++i) {
Other type of bracket:   unsigned i;   for (i = 0; i < mappings.size(); ++i) {
LINE TO PARSE FOR KEYWORD:  for (i = 0; i < mappings.size(); ++i) {
Depths: 2:2
['stackhelper']
The real line: +    const MappingInfo* mapping = mappings[i];
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    const mappinginfo* mapping = mappings[i];
Depths: 2:2
['stackhelper']
The real line: +    if (!strcmp(mapping->name, exe_name)) {
Current Name Search:     const MappingInfo* mapping = mappings[i]; 
Checking if function:     const MappingInfo* mapping = mappings[i];     if (!strcmp(mapping->name, exe_name)) {
Class context: stackhelper
Checking if a constructor/destructor:     const MappingInfo* mapping = mappings[i];     if (!strcmp(mapping->name, exe_name)) {
Other type of bracket:     const MappingInfo* mapping = mappings[i];     if (!strcmp(mapping->name, exe_name)) {
LINE TO PARSE FOR KEYWORD:    if (!strcmp(mapping->name, exe_name)) {
Depths: 3:3
['stackhelper']
The real line: +      found_exe = true;
Current Name Search: 
LINE TO PARSE FOR KEYWORD:      found_exe = true;
Depths: 3:3
['stackhelper']
The real line: +      break;
Current Name Search:       found_exe = true; 
LINE TO PARSE FOR KEYWORD:      break;
Depths: 3:3
['stackhelper']
The real line: +    }
Current Name Search:       break; 
LINE TO PARSE FOR KEYWORD:    }
Depths: 2:3
['stackhelper']
Adjusting depth.
The real line: +  }
Current Name Search:       break;     } 
LINE TO PARSE FOR KEYWORD:  }
Depths: 1:2
['stackhelper']
Adjusting depth.
The real line: +  ASSERT_TRUE(found_exe);
Current Name Search:       break;     }   } 
LINE TO PARSE FOR KEYWORD:  assert_true(found_exe);
Depths: 1:1
['stackhelper']
The real line: +
Current Name Search:   ASSERT_TRUE(found_exe); 
LINE TO PARSE FOR KEYWORD:
Depths: 1:1
['stackhelper']
The real line: +  uint8_t identifier1[sizeof(MDGUID)];
Current Name Search:   ASSERT_TRUE(found_exe);  
LINE TO PARSE. FOR KEYWORD:  uint8_t identifier1[sizeof(mdguid)];
Depths: 1:1
['stackhelper']
The real line: +  uint8_t identifier2[sizeof(MDGUID)];
Current Name Search:   uint8_t identifier1[sizeof(MDGUID)]; 
LINE TO PARSE FOR KEYWORD:  uint8_t identifier2[sizeof(mdguid)];
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[i], true, i,
Current Name Search:   uint8_t identifier2[sizeof(MDGUID)]; 
LINE TO PARSE FOR KEYWORD:  expect_true(dumper.elffileidentifierformapping(*mappings[i], true, i,
Depths: 1:1
['stackhelper']
The real line: +                                                 identifier1));
Current Name Search:   uint8_t identifier2[sizeof(MDGUID)];   EXPECT_TRUE(dumper.ElfFileIdentifierForMapping(*mappings[i], true, i, 
LINE TO PARSE FOR KEYWORD:                                                 identifier1));
Depths: 1:1
['stackhelper']
The real line: +  FileID fileid(exe_name);
Current Name Search:                                                  identifier1)); 
LINE TO PARSE FOR KEYWORD:  fileid fileid(exe_name);
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_TRUE(fileid.ElfFileIdentifier(identifier2));
Current Name Search:   FileID fileid(exe_name); 
LINE TO PARSE FOR KEYWORD:  expect_true(fileid.elffileidentifier(identifier2));
Depths: 1:1
['stackhelper']
The real line: +  char identifier_string1[37];
Current Name Search:   EXPECT_TRUE(fileid.ElfFileIdentifier(identifier2)); 
LINE TO PARSE FOR KEYWORD:  char identifier_string1[37];
Depths: 1:1
['stackhelper']
The real line: +  char identifier_string2[37];
Current Name Search:   char identifier_string1[37]; 
LINE TO PARSE FOR KEYWORD:  char identifier_string2[37];
Depths: 1:1
['stackhelper']
The real line: +  FileID::ConvertIdentifierToString(identifier1, identifier_string1,
Current Name Search:   char identifier_string2[37]; 
LINE TO PARSE FOR KEYWORD:  fileid::convertidentifiertostring(identifier1, identifier_string1,
Depths: 1:1
['stackhelper']
The real line: +                                    37);
Current Name Search:   char identifier_string2[37];   FileID::ConvertIdentifierToString(identifier1, identifier_string1, 
LINE TO PARSE FOR KEYWORD:                                    37);
Depths: 1:1
['stackhelper']
The real line: +  FileID::ConvertIdentifierToString(identifier2, identifier_string2,
Current Name Search:                                     37); 
LINE TO PARSE FOR KEYWORD:  fileid::convertidentifiertostring(identifier2, identifier_string2,
Depths: 1:1
['stackhelper']
The real line: +                                    37);
Current Name Search:                                     37);   FileID::ConvertIdentifierToString(identifier2, identifier_string2, 
LINE TO PARSE FOR KEYWORD:                                    37);
Depths: 1:1
['stackhelper']
The real line: +  EXPECT_STREQ(identifier_string1, identifier_string2);
Current Name Search:                                     37); 
LINE TO PARSE FOR KEYWORD:  expect_streq(identifier_string1, identifier_string2);
Depths: 1:1
['stackhelper']
The real line: +  close(fds[1]);
Current Name Search:   EXPECT_STREQ(identifier_string1, identifier_string2); 
LINE TO PARSE FOR KEYWORD:  close(fds[1]);
Depths: 1:1
['stackhelper']
The real line: +}
Current Name Search:   close(fds[1]); 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['stackhelper']
Adjusting depth.
Chunk End.
===========================================
GetHelperBinary
62
77
16
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
StackHelper
113
113
1
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
~StackHelper
114
117
4
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 0, 'ut_a Dels': 0}
NO_FUNC_CONTEXT
0
0
0
0
{'ut_ad Adds': 0, 'assert Dels': 0, 'ut_ad Dels': 0, 'ut_a Adds': 0, 'assert Adds': 32, 'ut_a Dels': 0}
===========================================
The real line: @@ -0,0 +1,325 @@
Current Name Search: 
Depths: 0:0
[]
The real line: +/*
Current Name Search: @@ -0,0 +1,325 @@ 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: + * Copyright (C) 2003, 2006 Apple Computer, Inc.  All rights reserved.
The real line: + *
The real line: + * Redistribution and use in source and binary forms, with or without
The real line: + * modification, are permitted provided that the following conditions
The real line: + * are met:
The real line: + * 1. Redistributions of source code must retain the above copyright
The real line: + *    notice, this list of conditions and the following disclaimer.
The real line: + * 2. Redistributions in binary form must reproduce the above copyright
The real line: + *    notice, this list of conditions and the following disclaimer in the
The real line: + *    documentation and/or other materials provided with the distribution.
The real line: + *
The real line: + * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
The real line: + * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
The real line: + * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
The real line: + * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
The real line: + * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
The real line: + * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
The real line: + * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
The real line: + * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
The real line: + * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
The real line: + * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
The real line: + * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
The real line: + */
The real line: +
Current Name Search: @@ -0,0 +1,325 @@  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "config.h"
Current Name Search: @@ -0,0 +1,325 @@   
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search: @@ -0,0 +1,325 @@   #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#if ENABLE(NETSCAPE_PLUGIN_API)
Current Name Search: @@ -0,0 +1,325 @@   #include   
LINE TO PARSE FOR KEYWORD:#if enable(netscape_plugin_api)
Depths: 0:0
[]
The real line: +
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API) 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "c_instance.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include  
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +#include "CRuntimeObject.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "IdentifierRep.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "JSDOMBinding.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "c_class.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "c_runtime.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "c_utility.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "npruntime_impl.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "runtime_method.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include "runtime_root.h"
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include 
Depths: 0:0
[]
The real line: +#include <interpreter/CallFrame.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  
LINE TO PARSE FOR KEYWORD:#include <interpreter/callframe.h>
Depths: 0:0
[]
The real line: +#include <runtime/ArgList.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> 
LINE TO PARSE FOR KEYWORD:#include <runtime/arglist.h>
Depths: 0:0
[]
The real line: +#include <runtime/Error.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> 
LINE TO PARSE FOR KEYWORD:#include <runtime/error.h>
Depths: 0:0
[]
The real line: +#include <runtime/FunctionPrototype.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> 
LINE TO PARSE FOR KEYWORD:#include <runtime/functionprototype.h>
Depths: 0:0
[]
The real line: +#include <runtime/JSLock.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> 
LINE TO PARSE FOR KEYWORD:#include <runtime/jslock.h>
Depths: 0:0
[]
The real line: +#include <runtime/PropertyNameArray.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> 
LINE TO PARSE FOR KEYWORD:#include <runtime/propertynamearray.h>
Depths: 0:0
[]
The real line: +#include <wtf/Assertions.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> #include <runtime/PropertyNameArray.h> 
LINE TO PARSE FOR KEYWORD:#include <>
Depths: 0:0
[]
The real line: +#include <wtf/StdLibExtras.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> #include <runtime/PropertyNameArray.h> #include <wtf/Assertions.h> 
LINE TO PARSE FOR KEYWORD:#include <wtf/stdlibextras.h>
Depths: 0:0
[]
The real line: +#include <wtf/StringExtras.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> #include <runtime/PropertyNameArray.h> #include <wtf/Assertions.h> #include <wtf/StdLibExtras.h> 
LINE TO PARSE FOR KEYWORD:#include <wtf/stringextras.h>
Depths: 0:0
[]
The real line: +#include <wtf/Vector.h>
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> #include <runtime/PropertyNameArray.h> #include <wtf/Assertions.h> #include <wtf/StdLibExtras.h> #include <wtf/StringExtras.h> 
LINE TO PARSE FOR KEYWORD:#include <wtf/vector.h>
Depths: 0:0
[]
The real line: +
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> #include <runtime/PropertyNameArray.h> #include <wtf/Assertions.h> #include <wtf/StdLibExtras.h> #include <wtf/StringExtras.h> #include <wtf/Vector.h> 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +using namespace WebCore;
Current Name Search: @@ -0,0 +1,325 @@   #include   #if ENABLE(NETSCAPE_PLUGIN_API)  #include   #include  #include  #include  #include  #include  #include  #include  #include  #include  #include <interpreter/CallFrame.h> #include <runtime/ArgList.h> #include <runtime/Error.h> #include <runtime/FunctionPrototype.h> #include <runtime/JSLock.h> #include <runtime/PropertyNameArray.h> #include <wtf/Assertions.h> #include <wtf/StdLibExtras.h> #include <wtf/StringExtras.h> #include <wtf/Vector.h>  
LINE TO PARSE FOR KEYWORD:using namespace webcore;
Depths: 0:0
[]
The real line: +
Current Name Search: using namespace WebCore; 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
[]
The real line: +namespace JSC {
Current Name Search: using namespace WebCore;  
Checking if function: using namespace WebCore;  namespace JSC {
Namespace:using namespace WebCore;  namespace JSC {
LINE TO PARSE FOR KEYWORD:namespace jsc {
Depths: 1:1
[]
The real line: +namespace Bindings {
Current Name Search: 
Checking if function: namespace Bindings {
Namespace:namespace Bindings {
LINE TO PARSE FOR KEYWORD:namespace bindings {
Depths: 2:2
[]
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +using JSC::UString;
Current Name Search:  
LINE TO PARSE FOR KEYWORD:using jsc::ustring;
Depths: 2:2
[]
The real line: +
Current Name Search: using JSC::UString; 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +static JSC::UString& globalExceptionString()
Current Name Search: using JSC::UString;  
LINE TO PARSE FOR KEYWORD:static jsc::ustring& globalexceptionstring()
Depths: 2:2
[]
The real line: +{
Current Name Search: using JSC::UString;  static JSC::UString& globalExceptionString() 
Checking if function: using JSC::UString;  static JSC::UString& globalExceptionString() {
PATTERN 1
Function:  JSC::UString& globalExceptionString() {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
[]
The real line: +    DEFINE_STATIC_LOCAL(JSC::UString, exceptionStr, ());
End Check: 3
LINE TO PARSE FOR KEYWORD:    define_static_local(jsc::ustring, exceptionstr, ());
The real line: +    return exceptionStr;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return exceptionstr;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
61 : 64
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +void CInstance::setGlobalException(UString exception)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cinstance::setglobalexception(ustring exception)
Depths: 2:2
[]
The real line: +{
Current Name Search:  void CInstance::setGlobalException(UString exception) 
Checking if function:  void CInstance::setGlobalException(UString exception) {
PATTERN 4
Function: void CInstance::setGlobalException(UString exception) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
[]
The real line: +    globalExceptionString() = exception;
End Check: 3
LINE TO PARSE FOR KEYWORD:    globalexceptionstring() = exception;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
67 : 69
Next: (UString exception)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +void CInstance::moveGlobalExceptionToExecState(ExecState* exec)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cinstance::moveglobalexceptiontoexecstate(execstate* exec)
Depths: 2:2
[]
The real line: +{
Current Name Search:  void CInstance::moveGlobalExceptionToExecState(ExecState* exec) 
Checking if function:  void CInstance::moveGlobalExceptionToExecState(ExecState* exec) {
PATTERN 4
Function: void CInstance::moveGlobalExceptionToExecState(ExecState* exec) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
[]
The real line: +    if (globalExceptionString().isNull())
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (globalexceptionstring().isnull())
The real line: +        return;
End Check: 3
LINE TO PARSE FOR KEYWORD:        return;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +        JSLock lock(SilenceAssertionsOnly);
End Check: 4
LINE TO PARSE FOR KEYWORD:        jslock lock(silenceassertionsonly);
The real line: +        throwError(exec, createError(exec, globalExceptionString()));
End Check: 4
LINE TO PARSE FOR KEYWORD:        throwerror(exec, createerror(exec, globalexceptionstring()));
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    globalExceptionString() = UString();
End Check: 3
LINE TO PARSE FOR KEYWORD:    globalexceptionstring() = ustring();
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
72 : 82
Next: (ExecState* exec)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +CInstance::CInstance(NPObject* o, PassRefPtr<RootObject> rootObject)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:cinstance::cinstance(npobject* o, passrefptr<rootobject> rootobject)
Depths: 2:2
[]
The real line: +    : Instance(rootObject)
Current Name Search:  CInstance::CInstance(NPObject* o, PassRefPtr<RootObject> rootObject) 
LINE TO PARSE FOR KEYWORD:    : instance(rootobject)
Depths: 2:2
[]
The real line: +{
Current Name Search:  CInstance::CInstance(NPObject* o, PassRefPtr<RootObject> rootObject)     : Instance(rootObject) 
Checking if function:  CInstance::CInstance(NPObject* o, PassRefPtr<RootObject> rootObject)     : Instance(rootObject) {
Other type of bracket:  CInstance::CInstance(NPObject* o, PassRefPtr<RootObject> rootObject)     : Instance(rootObject) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:3
[]
The real line: +    _object = _NPN_RetainObject(o);
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    _object = _npn_retainobject(o);
Depths: 3:3
[]
The real line: +    _class = 0;
Current Name Search:     _object = _NPN_RetainObject(o); 
LINE TO PARSE FOR KEYWORD:    _class = 0;
Depths: 3:3
[]
The real line: +}
Current Name Search:     _class = 0; 
LINE TO PARSE FOR KEYWORD:}
Depths: 2:3
[]
Adjusting depth.
The real line: +
Current Name Search:     _class = 0; } 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +CInstance::~CInstance() 
Current Name Search:     _class = 0; }  
LINE TO PARSE FOR KEYWORD:cinstance::~cinstance() 
Depths: 2:2
[]
The real line: +{
Current Name Search:     _class = 0; }  CInstance::~CInstance()  
Checking if function:     _class = 0; }  CInstance::~CInstance()  {
Other type of bracket:     _class = 0; }  CInstance::~CInstance()  {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:3
[]
The real line: +    _NPN_ReleaseObject(_object);
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    _npn_releaseobject(_object);
Depths: 3:3
[]
The real line: +}
Current Name Search:     _NPN_ReleaseObject(_object); 
LINE TO PARSE FOR KEYWORD:}
Depths: 2:3
[]
Adjusting depth.
The real line: +
Current Name Search:     _NPN_ReleaseObject(_object); } 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +RuntimeObject* CInstance::newRuntimeObject(ExecState* exec)
Current Name Search:     _NPN_ReleaseObject(_object); }  
LINE TO PARSE FOR KEYWORD:runtimeobject* cinstance::newruntimeobject(execstate* exec)
Depths: 2:2
[]
The real line: +{
Current Name Search:     _NPN_ReleaseObject(_object); }  RuntimeObject* CInstance::newRuntimeObject(ExecState* exec) 
Checking if function:     _NPN_ReleaseObject(_object); }  RuntimeObject* CInstance::newRuntimeObject(ExecState* exec) {
PATTERN 1
Function:  RuntimeObject* CInstance::newRuntimeObject(ExecState* exec) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
[]
The real line: +    return new (exec) CRuntimeObject(exec, exec->lexicalGlobalObject(), this);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return new (exec) cruntimeobject(exec, exec->lexicalglobalobject(), this);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
97 : 99
Next: (ExecState* exec)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +Class *CInstance::getClass() const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:class *cinstance::getclass() const
Depths: 2:2
[]
The real line: +{
Current Name Search:  Class *CInstance::getClass() const 
Checking if function:  Class *CInstance::getClass() const {
PATTERN 5
Function: Class *CInstance::getClass(){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
[]
The real line: +    if (!_class)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!_class)
The real line: +        _class = CClass::classForIsA(_object->_class);
End Check: 3
LINE TO PARSE FOR KEYWORD:        _class = cclass::classforisa(_object->_class);
The real line: +    return _class;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return _class;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
102 : 106
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +bool CInstance::supportsInvokeDefaultMethod() const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:bool cinstance::supportsinvokedefaultmethod() const
Depths: 2:2
[]
The real line: +{
Current Name Search:  bool CInstance::supportsInvokeDefaultMethod() const 
Checking if function:  bool CInstance::supportsInvokeDefaultMethod() const {
PATTERN 4
Function: bool CInstance::supportsInvokeDefaultMethod(){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
[]
The real line: +    return _object->_class->invokeDefault;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return _object->_class->invokedefault;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
109 : 111
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
[]
The real line: +class CRuntimeMethod : public RuntimeMethod {
Current Name Search:  
Checking if function:  class CRuntimeMethod : public RuntimeMethod {
Class:class cruntimemethod : public runtimemethod {
LINE TO PARSE FOR KEYWORD:class cruntimemethod : public runtimemethod {
Depths: 3:3
['cruntimemethod']
The real line: +public:
Current Name Search: 
LINE TO PARSE FOR KEYWORD:public:
Depths: 3:3
['cruntimemethod']
The real line: +    CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)
Current Name Search: public: 
LINE TO PARSE FOR KEYWORD:    cruntimemethod(execstate* exec, jsglobalobject* globalobject, const identifier& name, bindings::methodlist& list)
Depths: 3:3
['cruntimemethod']
The real line: +        // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object
Current Name Search: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list) 
LINE TO PARSE FOR KEYWORD:        
Depths: 3:3
['cruntimemethod']
The real line: +        // We need to pass in the right global object for "i".
Current Name Search: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)          
LINE TO PARSE FOR KEYWORD:        
Depths: 3:3
['cruntimemethod']
The real line: +        : RuntimeMethod(exec, globalObject, WebCore::deprecatedGetDOMStructure<CRuntimeMethod>(exec), name, list)
Current Name Search: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)                   
LINE TO PARSE FOR KEYWORD:        : runtimemethod(exec, globalobject, webcore::deprecatedgetdomstructure<cruntimemethod>(exec), name, list)
Depths: 3:3
['cruntimemethod']
The real line: +    {
Current Name Search: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)                           : RuntimeMethod(exec, globalObject, WebCore::deprecatedGetDOMStructure<CRuntimeMethod>(exec), name, list) 
Checking if function: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)                           : RuntimeMethod(exec, globalObject, WebCore::deprecatedGetDOMStructure<CRuntimeMethod>(exec), name, list)     {
Class context: cruntimemethod
Checking if a constructor/destructor: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)                           : RuntimeMethod(exec, globalObject, WebCore::deprecatedGetDOMStructure<CRuntimeMethod>(exec), name, list)     {
Function: public:     CRuntimeMethod(ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)                           : RuntimeMethod(exec, globalObject, WebCore::deprecatedGetDOMStructure<CRuntimeMethod>(exec), name, list)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 4:3
['cruntimemethod']
The real line: +        ASSERT(inherits(&s_info));
End Check: 4
LINE TO PARSE FOR KEYWORD:        assert(inherits(&s_info));
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
119 : 121
Next: (ExecState* exec, JSGlobalObject* globalObject, const Identifier& name, Bindings::MethodList& list)
Next: (exec, globalObject, WebCore::deprecatedGetDOMStructure<CRuntimeMethod>(exec)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 3:3
['cruntimemethod']
The real line: +    static Structure* createStructure(JSGlobalData& globalData, JSValue prototype)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static structure* createstructure(jsglobaldata& globaldata, jsvalue prototype)
Depths: 3:3
['cruntimemethod']
The real line: +    {
Current Name Search:      static Structure* createStructure(JSGlobalData& globalData, JSValue prototype) 
Checking if function:      static Structure* createStructure(JSGlobalData& globalData, JSValue prototype)     {
PATTERN 1
Function:  Structure* createStructure(JSGlobalData& globalData, JSValue prototype)     {
LINE TO PARSE FOR KEYWORD:    {
Depths: 4:3
['cruntimemethod']
The real line: +        return Structure::create(globalData, prototype, TypeInfo(ObjectType, StructureFlags), AnonymousSlotCount, &s_info);
End Check: 4
LINE TO PARSE FOR KEYWORD:        return structure::create(globaldata, prototype, typeinfo(objecttype, structureflags), anonymousslotcount, &s_info);
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
124 : 126
Next: (JSGlobalData& globalData, JSValue prototype)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 3:3
['cruntimemethod']
The real line: +    static const ClassInfo s_info;
Current Name Search:  
LINE TO PARSE FOR KEYWORD:    static const classinfo s_info;
Depths: 3:3
['cruntimemethod']
The real line: +};
Current Name Search:     static const ClassInfo s_info; 
LINE TO PARSE FOR KEYWORD:};
Depths: 2:3
['cruntimemethod']
Adjusting depth.
The real line: +
Current Name Search: }; 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +const ClassInfo CRuntimeMethod::s_info = { "CRuntimeMethod", &RuntimeMethod::s_info, 0, 0 };
Current Name Search: };  
Checking if function: const ClassInfo CRuntimeMethod::s_info = {
Class context: cruntimemethod
Checking if a constructor/destructor: const ClassInfo CRuntimeMethod::s_info = {
Other type of bracket: const ClassInfo CRuntimeMethod::s_info = {
LINE TO PARSE FOR KEYWORD:const classinfo cruntimemethod::s_info = { , &runtimemethod::s_info, 0, 0 };
Depths: 2:3
['cruntimemethod']
Adjusting depth.
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::getMethod(ExecState* exec, const Identifier& propertyName)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::getmethod(execstate* exec, const identifier& propertyname)
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::getMethod(ExecState* exec, const Identifier& propertyName) 
Checking if function:  JSValue CInstance::getMethod(ExecState* exec, const Identifier& propertyName) {
PATTERN 4
Function: JSValue CInstance::getMethod(ExecState* exec,Identifier& propertyName) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    MethodList methodList = getClass()->methodsNamed(propertyName, this);
End Check: 3
LINE TO PARSE FOR KEYWORD:    methodlist methodlist = getclass()->methodsnamed(propertyname, this);
The real line: +    return new (exec) CRuntimeMethod(exec, exec->lexicalGlobalObject(), propertyName, methodList);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return new (exec) cruntimemethod(exec, exec->lexicalglobalobject(), propertyname, methodlist);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
134 : 137
Next: (ExecState* exec,Identifier& propertyName)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::invokeMethod(ExecState* exec, RuntimeMethod* runtimeMethod)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::invokemethod(execstate* exec, runtimemethod* runtimemethod)
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::invokeMethod(ExecState* exec, RuntimeMethod* runtimeMethod) 
Checking if function:  JSValue CInstance::invokeMethod(ExecState* exec, RuntimeMethod* runtimeMethod) {
PATTERN 4
Function: JSValue CInstance::invokeMethod(ExecState* exec, RuntimeMethod* runtimeMethod) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    if (!asObject(runtimeMethod)->inherits(&CRuntimeMethod::s_info))
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!asobject(runtimemethod)->inherits(&cruntimemethod::s_info))
The real line: +        return throwError(exec, createTypeError(exec, "Attempt to invoke non-plug-in method on plug-in object."));
End Check: 3
LINE TO PARSE FOR KEYWORD:        return throwerror(exec, createtypeerror(exec, ));
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    const MethodList& methodList = *runtimeMethod->methods();
End Check: 3
LINE TO PARSE FOR KEYWORD:    const methodlist& methodlist = *runtimemethod->methods();
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    // Overloading methods are not allowed by NPObjects.  Should only be one
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    // name match for a particular method.
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    ASSERT(methodList.size() == 1);
End Check: 3
LINE TO PARSE FOR KEYWORD:    assert(methodlist.size() == 1);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    CMethod* method = static_cast<CMethod*>(methodList[0]);
End Check: 3
LINE TO PARSE FOR KEYWORD:    cmethod* method = static_cast<cmethod*>(methodlist[0]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    NPIdentifier ident = method->identifier();
End Check: 3
LINE TO PARSE FOR KEYWORD:    npidentifier ident = method->identifier();
The real line: +    if (!_object->_class->hasMethod(_object, ident))
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!_object->_class->hasmethod(_object, ident))
The real line: +        return jsUndefined();
End Check: 3
LINE TO PARSE FOR KEYWORD:        return jsundefined();
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    unsigned count = exec->argumentCount();
End Check: 3
LINE TO PARSE FOR KEYWORD:    unsigned count = exec->argumentcount();
The real line: +    Vector<NPVariant, 8> cArgs(count);
End Check: 3
LINE TO PARSE FOR KEYWORD:    vector<npvariant, 8> cargs(count);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    unsigned i;
End Check: 3
LINE TO PARSE FOR KEYWORD:    unsigned i;
The real line: +    for (i = 0; i < count; i++)
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < count; i++)
The real line: +        convertValueToNPVariant(exec, exec->argument(i), &cArgs[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:        convertvaluetonpvariant(exec, exec->argument(i), &cargs[i]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    // Invoke the 'C' method.
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    bool retval = true;
End Check: 3
LINE TO PARSE FOR KEYWORD:    bool retval = true;
The real line: +    NPVariant resultVariant;
End Check: 3
LINE TO PARSE FOR KEYWORD:    npvariant resultvariant;
The real line: +    VOID_TO_NPVARIANT(resultVariant);
End Check: 3
LINE TO PARSE FOR KEYWORD:    void_to_npvariant(resultvariant);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +        JSLock::DropAllLocks dropAllLocks(SilenceAssertionsOnly);
End Check: 4
LINE TO PARSE FOR KEYWORD:        jslock::dropalllocks dropalllocks(silenceassertionsonly);
The real line: +        ASSERT(globalExceptionString().isNull());
End Check: 4
LINE TO PARSE FOR KEYWORD:        assert(globalexceptionstring().isnull());
The real line: +        retval = _object->_class->invoke(_object, ident, cArgs.data(), count, &resultVariant);
End Check: 4
LINE TO PARSE FOR KEYWORD:        retval = _object->_class->invoke(_object, ident, cargs.data(), count, &resultvariant);
The real line: +        moveGlobalExceptionToExecState(exec);
End Check: 4
LINE TO PARSE FOR KEYWORD:        moveglobalexceptiontoexecstate(exec);
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +    
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    if (!retval)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!retval)
The real line: +        throwError(exec, createError(exec, "Error calling method on NPObject."));
End Check: 3
LINE TO PARSE FOR KEYWORD:        throwerror(exec, createerror(exec, ));
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    for (i = 0; i < count; i++)
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < count; i++)
The real line: +        _NPN_ReleaseVariantValue(&cArgs[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:        _npn_releasevariantvalue(&cargs[i]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    JSValue resultValue = convertNPVariantToValue(exec, &resultVariant, m_rootObject.get());
End Check: 3
LINE TO PARSE FOR KEYWORD:    jsvalue resultvalue = convertnpvarianttovalue(exec, &resultvariant, m_rootobject.get());
The real line: +    _NPN_ReleaseVariantValue(&resultVariant);
End Check: 3
LINE TO PARSE FOR KEYWORD:    _npn_releasevariantvalue(&resultvariant);
The real line: +    return resultValue;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return resultvalue;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
140 : 184
Next: (ExecState* exec, RuntimeMethod* runtimeMethod)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +
Current Name Search:  
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::invokeDefaultMethod(ExecState* exec)
Current Name Search:   
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::invokedefaultmethod(execstate* exec)
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:   JSValue CInstance::invokeDefaultMethod(ExecState* exec) 
Checking if function:   JSValue CInstance::invokeDefaultMethod(ExecState* exec) {
PATTERN 4
Function: JSValue CInstance::invokeDefaultMethod(ExecState* exec) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    if (!_object->_class->invokeDefault)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!_object->_class->invokedefault)
The real line: +        return jsUndefined();
End Check: 3
LINE TO PARSE FOR KEYWORD:        return jsundefined();
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    unsigned count = exec->argumentCount();
End Check: 3
LINE TO PARSE FOR KEYWORD:    unsigned count = exec->argumentcount();
The real line: +    Vector<NPVariant, 8> cArgs(count);
End Check: 3
LINE TO PARSE FOR KEYWORD:    vector<npvariant, 8> cargs(count);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    unsigned i;
End Check: 3
LINE TO PARSE FOR KEYWORD:    unsigned i;
The real line: +    for (i = 0; i < count; i++)
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < count; i++)
The real line: +        convertValueToNPVariant(exec, exec->argument(i), &cArgs[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:        convertvaluetonpvariant(exec, exec->argument(i), &cargs[i]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    // Invoke the 'C' method.
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    bool retval = true;
End Check: 3
LINE TO PARSE FOR KEYWORD:    bool retval = true;
The real line: +    NPVariant resultVariant;
End Check: 3
LINE TO PARSE FOR KEYWORD:    npvariant resultvariant;
The real line: +    VOID_TO_NPVARIANT(resultVariant);
End Check: 3
LINE TO PARSE FOR KEYWORD:    void_to_npvariant(resultvariant);
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +        JSLock::DropAllLocks dropAllLocks(SilenceAssertionsOnly);
End Check: 4
LINE TO PARSE FOR KEYWORD:        jslock::dropalllocks dropalllocks(silenceassertionsonly);
The real line: +        ASSERT(globalExceptionString().isNull());
End Check: 4
LINE TO PARSE FOR KEYWORD:        assert(globalexceptionstring().isnull());
The real line: +        retval = _object->_class->invokeDefault(_object, cArgs.data(), count, &resultVariant);
End Check: 4
LINE TO PARSE FOR KEYWORD:        retval = _object->_class->invokedefault(_object, cargs.data(), count, &resultvariant);
The real line: +        moveGlobalExceptionToExecState(exec);
End Check: 4
LINE TO PARSE FOR KEYWORD:        moveglobalexceptiontoexecstate(exec);
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +    
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    if (!retval)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!retval)
The real line: +        throwError(exec, createError(exec, "Error calling method on NPObject."));
End Check: 3
LINE TO PARSE FOR KEYWORD:        throwerror(exec, createerror(exec, ));
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    for (i = 0; i < count; i++)
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < count; i++)
The real line: +        _NPN_ReleaseVariantValue(&cArgs[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:        _npn_releasevariantvalue(&cargs[i]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    JSValue resultValue = convertNPVariantToValue(exec, &resultVariant, m_rootObject.get());
End Check: 3
LINE TO PARSE FOR KEYWORD:    jsvalue resultvalue = convertnpvarianttovalue(exec, &resultvariant, m_rootobject.get());
The real line: +    _NPN_ReleaseVariantValue(&resultVariant);
End Check: 3
LINE TO PARSE FOR KEYWORD:    _npn_releasevariantvalue(&resultvariant);
The real line: +    return resultValue;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return resultvalue;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
188 : 219
Next: (ExecState* exec)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +bool CInstance::supportsConstruct() const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:bool cinstance::supportsconstruct() const
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  bool CInstance::supportsConstruct() const 
Checking if function:  bool CInstance::supportsConstruct() const {
PATTERN 4
Function: bool CInstance::supportsConstruct(){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    return _object->_class->construct;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return _object->_class->construct;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
222 : 224
Next: ()
The real line: +    
Current Name Search: 
LINE TO PARSE FOR KEYWORD:    
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::invokeConstruct(ExecState* exec, const ArgList& args)
Current Name Search:      
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::invokeconstruct(execstate* exec, const arglist& args)
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:      JSValue CInstance::invokeConstruct(ExecState* exec, const ArgList& args) 
Checking if function:      JSValue CInstance::invokeConstruct(ExecState* exec, const ArgList& args) {
PATTERN 4
Function: JSValue CInstance::invokeConstruct(ExecState* exec,ArgList& args) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    if (!_object->_class->construct)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!_object->_class->construct)
The real line: +        return jsUndefined();
End Check: 3
LINE TO PARSE FOR KEYWORD:        return jsundefined();
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    unsigned count = args.size();
End Check: 3
LINE TO PARSE FOR KEYWORD:    unsigned count = args.size();
The real line: +    Vector<NPVariant, 8> cArgs(count);
End Check: 3
LINE TO PARSE FOR KEYWORD:    vector<npvariant, 8> cargs(count);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    unsigned i;
End Check: 3
LINE TO PARSE FOR KEYWORD:    unsigned i;
The real line: +    for (i = 0; i < count; i++)
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < count; i++)
The real line: +        convertValueToNPVariant(exec, args.at(i), &cArgs[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:        convertvaluetonpvariant(exec, args.at(i), &cargs[i]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    // Invoke the 'C' method.
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    bool retval = true;
End Check: 3
LINE TO PARSE FOR KEYWORD:    bool retval = true;
The real line: +    NPVariant resultVariant;
End Check: 3
LINE TO PARSE FOR KEYWORD:    npvariant resultvariant;
The real line: +    VOID_TO_NPVARIANT(resultVariant);
End Check: 3
LINE TO PARSE FOR KEYWORD:    void_to_npvariant(resultvariant);
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +        JSLock::DropAllLocks dropAllLocks(SilenceAssertionsOnly);
End Check: 4
LINE TO PARSE FOR KEYWORD:        jslock::dropalllocks dropalllocks(silenceassertionsonly);
The real line: +        ASSERT(globalExceptionString().isNull());
End Check: 4
LINE TO PARSE FOR KEYWORD:        assert(globalexceptionstring().isnull());
The real line: +        retval = _object->_class->construct(_object, cArgs.data(), count, &resultVariant);
End Check: 4
LINE TO PARSE FOR KEYWORD:        retval = _object->_class->construct(_object, cargs.data(), count, &resultvariant);
The real line: +        moveGlobalExceptionToExecState(exec);
End Check: 4
LINE TO PARSE FOR KEYWORD:        moveglobalexceptiontoexecstate(exec);
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +    
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    if (!retval)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!retval)
The real line: +        throwError(exec, createError(exec, "Error calling method on NPObject."));
End Check: 3
LINE TO PARSE FOR KEYWORD:        throwerror(exec, createerror(exec, ));
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    for (i = 0; i < count; i++)
End Check: 3
LINE TO PARSE FOR KEYWORD:    for (i = 0; i < count; i++)
The real line: +        _NPN_ReleaseVariantValue(&cArgs[i]);
End Check: 3
LINE TO PARSE FOR KEYWORD:        _npn_releasevariantvalue(&cargs[i]);
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    JSValue resultValue = convertNPVariantToValue(exec, &resultVariant, m_rootObject.get());
End Check: 3
LINE TO PARSE FOR KEYWORD:    jsvalue resultvalue = convertnpvarianttovalue(exec, &resultvariant, m_rootobject.get());
The real line: +    _NPN_ReleaseVariantValue(&resultVariant);
End Check: 3
LINE TO PARSE FOR KEYWORD:    _npn_releasevariantvalue(&resultvariant);
The real line: +    return resultValue;
End Check: 3
LINE TO PARSE FOR KEYWORD:    return resultvalue;
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
227 : 258
Next: (ExecState* exec,ArgList& args)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::defaultValue(ExecState* exec, PreferredPrimitiveType hint) const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::defaultvalue(execstate* exec, preferredprimitivetype hint) const
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::defaultValue(ExecState* exec, PreferredPrimitiveType hint) const 
Checking if function:  JSValue CInstance::defaultValue(ExecState* exec, PreferredPrimitiveType hint) const {
PATTERN 4
Function: JSValue CInstance::defaultValue(ExecState* exec, PreferredPrimitiveType hint){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    if (hint == PreferString)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (hint == preferstring)
The real line: +        return stringValue(exec);
End Check: 3
LINE TO PARSE FOR KEYWORD:        return stringvalue(exec);
The real line: +    if (hint == PreferNumber)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (hint == prefernumber)
The real line: +        return numberValue(exec);
End Check: 3
LINE TO PARSE FOR KEYWORD:        return numbervalue(exec);
The real line: +    return valueOf(exec);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return valueof(exec);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
261 : 267
Next: (ExecState* exec, PreferredPrimitiveType hint)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::stringValue(ExecState* exec) const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::stringvalue(execstate* exec) const
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::stringValue(ExecState* exec) const 
Checking if function:  JSValue CInstance::stringValue(ExecState* exec) const {
PATTERN 4
Function: JSValue CInstance::stringValue(ExecState* exec){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    char buf[1024];
End Check: 3
LINE TO PARSE FOR KEYWORD:    char buf[1024];
The real line: +    snprintf(buf, sizeof(buf), "NPObject %p, NPClass %p", _object, _object->_class);
End Check: 3
LINE TO PARSE FOR KEYWORD:    snprintf(buf, sizeof(buf), , _object, _object->_class);
The real line: +    return jsString(exec, buf);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return jsstring(exec, buf);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
270 : 274
Next: (ExecState* exec)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::numberValue(ExecState*) const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::numbervalue(execstate*) const
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::numberValue(ExecState*) const 
Checking if function:  JSValue CInstance::numberValue(ExecState*) const {
PATTERN 4
Function: JSValue CInstance::numberValue(ExecState*){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    // FIXME: Implement something sensible.
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    return jsNumber(0);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return jsnumber(0);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
277 : 280
Next: (ExecState*)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::booleanValue() const
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::booleanvalue() const
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::booleanValue() const 
Checking if function:  JSValue CInstance::booleanValue() const {
PATTERN 4
Function: JSValue CInstance::booleanValue(){
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    // FIXME: Implement something sensible.
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    return jsBoolean(false);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return jsboolean(false);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
283 : 286
Next: ()
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +JSValue CInstance::valueOf(ExecState* exec) const 
Current Name Search:  
LINE TO PARSE FOR KEYWORD:jsvalue cinstance::valueof(execstate* exec) const 
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  JSValue CInstance::valueOf(ExecState* exec) const  
Checking if function:  JSValue CInstance::valueOf(ExecState* exec) const  {
PATTERN 4
Function: JSValue CInstance::valueOf(ExecState* exec) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    return stringValue(exec);
End Check: 3
LINE TO PARSE FOR KEYWORD:    return stringvalue(exec);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
289 : 291
Next: (ExecState* exec)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +void CInstance::getPropertyNames(ExecState* exec, PropertyNameArray& nameArray)
Current Name Search:  
LINE TO PARSE FOR KEYWORD:void cinstance::getpropertynames(execstate* exec, propertynamearray& namearray)
Depths: 2:2
['cruntimemethod']
The real line: +{
Current Name Search:  void CInstance::getPropertyNames(ExecState* exec, PropertyNameArray& nameArray) 
Checking if function:  void CInstance::getPropertyNames(ExecState* exec, PropertyNameArray& nameArray) {
PATTERN 4
Function: void CInstance::getPropertyNames(ExecState* exec, PropertyNameArray& nameArray) {
LINE TO PARSE FOR KEYWORD:{
Depths: 3:2
['cruntimemethod']
The real line: +    if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(_object->_class) || !_object->_class->enumerate)
End Check: 3
LINE TO PARSE FOR KEYWORD:    if (!np_class_struct_version_has_enum(_object->_class) || !_object->_class->enumerate)
The real line: +        return;
End Check: 3
LINE TO PARSE FOR KEYWORD:        return;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    uint32_t count;
End Check: 3
LINE TO PARSE FOR KEYWORD:    uint32_t count;
The real line: +    NPIdentifier* identifiers;
End Check: 3
LINE TO PARSE FOR KEYWORD:    npidentifier* identifiers;
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    {
End Check: 4
LINE TO PARSE FOR KEYWORD:    {
The real line: +        JSLock::DropAllLocks dropAllLocks(SilenceAssertionsOnly);
End Check: 4
LINE TO PARSE FOR KEYWORD:        jslock::dropalllocks dropalllocks(silenceassertionsonly);
The real line: +        ASSERT(globalExceptionString().isNull());
End Check: 4
LINE TO PARSE FOR KEYWORD:        assert(globalexceptionstring().isnull());
The real line: +        bool ok = _object->_class->enumerate(_object, &identifiers, &count);
End .
======================================================================
FAIL: test_parseText_Single13 (__main__.logChunktest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "logChunkTest.py", line 415, in test_parseText_Single13
    self.assertTrue(len(funcList) == 2)
AssertionError: False is not true

======================================================================
FAIL: test_parseText_Single2 (__main__.logChunktest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "logChunkTest.py", line 229, in test_parseText_Single2
    self.assertTrue(funcList[0].method=="btr_pcur_release_leaf")
AssertionError: False is not true

======================================================================
FAIL: test_parseText_Single23 (__main__.logChunktest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "logChunkTest.py", line 486, in test_parseText_Single23
    self.assertTrue(funcList[0].method ==  "MDL_ticket::has_pending_conflicting_lock_impl")
AssertionError: False is not true

======================================================================
FAIL: test_parseText_Single31 (__main__.logChunktest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "logChunkTest.py", line 536, in test_parseText_Single31
    self.assertTrue(len(funcList) == 2)
AssertionError: False is not true

======================================================================
FAIL: test_parseText_Single36 (__main__.logChunktest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "logChunkTest.py", line 584, in test_parseText_Single36
    self.assertTrue(len(funcList) == 3) # 2 + 1 Mock
AssertionError: False is not true

----------------------------------------------------------------------
Ran 34 tests in 0.835s

FAILED (failures=5)
Check: 4
LINE TO PARSE FOR KEYWORD:        bool ok = _object->_class->enumerate(_object, &identifiers, &count);
The real line: +        moveGlobalExceptionToExecState(exec);
End Check: 4
LINE TO PARSE FOR KEYWORD:        moveglobalexceptiontoexecstate(exec);
The real line: +        if (!ok)
End Check: 4
LINE TO PARSE FOR KEYWORD:        if (!ok)
The real line: +            return;
End Check: 4
LINE TO PARSE FOR KEYWORD:            return;
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    for (uint32_t i = 0; i < count; i++) {
End Check: 4
LINE TO PARSE FOR KEYWORD:    for (uint32_t i = 0; i < count; i++) {
The real line: +        IdentifierRep* identifier = static_cast<IdentifierRep*>(identifiers[i]);
End Check: 4
LINE TO PARSE FOR KEYWORD:        identifierrep* identifier = static_cast<identifierrep*>(identifiers[i]);
The real line: +
End Check: 4
LINE TO PARSE FOR KEYWORD:
The real line: +        if (identifier->isString())
End Check: 4
LINE TO PARSE FOR KEYWORD:        if (identifier->isstring())
The real line: +            nameArray.add(identifierFromNPIdentifier(exec, identifier->string()));
End Check: 4
LINE TO PARSE FOR KEYWORD:            namearray.add(identifierfromnpidentifier(exec, identifier->string()));
The real line: +        else
End Check: 4
LINE TO PARSE FOR KEYWORD:        else
The real line: +            nameArray.add(Identifier::from(exec, identifier->number()));
End Check: 4
LINE TO PARSE FOR KEYWORD:            namearray.add(identifier::from(exec, identifier->number()));
The real line: +    }
End Check: 3
LINE TO PARSE FOR KEYWORD:    }
The real line: +
End Check: 3
LINE TO PARSE FOR KEYWORD:
The real line: +    // FIXME: This should really call NPN_MemFree but that's in WebKit
End Check: 3
LINE TO PARSE FOR KEYWORD:    
The real line: +    free(identifiers);
End Check: 3
LINE TO PARSE FOR KEYWORD:    free(identifiers);
The real line: +}
End Check: 2
LINE TO PARSE FOR KEYWORD:}
294 : 321
Next: (ExecState* exec, PropertyNameArray& nameArray)
The real line: +
Current Name Search: 
LINE TO PARSE FOR KEYWORD:
Depths: 2:2
['cruntimemethod']
The real line: +}
Current Name Search:  
LINE TO PARSE FOR KEYWORD:}
Depths: 1:2
['cruntimemethod']
Adjusting depth.
The real line: +}
Current Name Search:  } 
LINE TO PARSE FOR KEYWORD:}
Depths: 0:1
['cruntimemethod']
Adjusting depth.
The real line: +
Current Name Search:  } } 
LINE TO PARSE FOR KEYWORD:
Depths: 0:0
['cruntimemethod']
The real line: +#endif // ENABLE(NETSCAPE_PLUGIN_API)
Current Name Search:  } }  
LINE TO PARSE FOR KEYWORD:#endif 
Depths: 0:0
['cruntimemethod']
Chunk End.
